<?xml version="1.0" encoding="gb2312"?>
<defineSqls>
<!--================================================采购询价单=================================================-->
<define name="tblBuyAskPrice_add"> 	
	<sql type="condition">
		<!--如果有录入价格有效期，判断价格有效期小于单据日期，给出提示-->
		<exec condition="'@ValueofDB:tblBuyAskPrice_Priceusefullife'.length&gt;0&amp;&amp;'@ValueofDB:tblBuyAskPrice_Priceusefullife'&lt;'@ValueofDB:tblBuyAskPrice_BillDate'">				
			<error>tblBuyAskPrice.PriceDate.error</error>                  
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblBuyAskPrice_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyAskPrice_Tax!=0)||@ValueofDB:tblBuyAskPrice_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>           
		</exec>
        <!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
        <exec condition="'@MEM:Availably'=='true'">     
            <sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
               update tblBuyAskPriceDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyAskPrice  a join tblBuyAskPriceDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyAskPrice_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyAskPriceDet.id=a.id</sql>
            <sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
               update tblBuyAskPriceDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyAskPrice a join tblBuyAskPriceDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyAskPrice_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyAskPriceDet.id=a.id</sql>
        </exec>
	</sql> 
	<!--提示录入大于0的数量-->
	<sql type="condition">
		<condition><select>select tblGoods.GoodsFullName as GoodsQ,Qty from tblBuyAskPriceDet,tblGoods where tblGoods.classCode=tblBuyAskPriceDet.GoodsCode and f_ref=@ValueofDB:tblBuyAskPrice_id and isnull(tblBuyAskPriceDet.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">				
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<!--录入大于0的单价-->	
	<sql type="condition">
		<condition><select>select tblGoods.GoodsFullName as GoodsP,Qty from tblBuyAskPriceDet,tblGoods where tblGoods.classCode=tblBuyAskPriceDet.GoodsCode and f_ref=@ValueofDB:tblBuyAskPrice_id and isnull(tblBuyAskPriceDet.Price,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsP' != 'null' ">				
			<error>common.price.negative.error,@SqlReturn:GoodsP</error>                  
		</exec>	
	</sql>
	<!--合计金额与明细表合计金额不相等,给出错误提示-->
	<sql type="condition">
		<condition><select>select dbo.getDigits('tblBuyAskPriceDet','TaxAmount',sum(tblBuyAskPriceDet.TaxAmount)) as SumDetAmt from tblBuyAskPriceDet where  tblBuyAskPriceDet.f_ref=@ValueofDB:tblBuyAskPrice_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt !=@ValueofDB:TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblBuyAskPrice_TotalTaxAmount,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>	
</define>

<!--删除采购询价单-->
<define name="tblBuyAskPrice_Delete"> 
	<!--判断是否被采购订单引用-->
	<sql type="condition">
		<condition><select>select a.BillNo as BuyOrderBillNo from tblBuyOrder a, tblBuyOrderDet b where a.id=b.f_ref and b.BuyAskPriceID=@ValueofDB:tblBuyAskPrice_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:BuyOrderBillNo' != 'null'">	 		
			<error>BuyAskDel.BillNo.error,@SqlReturn:BuyOrderBillNo</error>                  
		</exec>		
	</sql>
	<!--判断是否被采购入库单引用-->
	<sql type="condition">
		<condition><select>select BillNo as BuyInBillNo from tblBuyInStock a,tblBuyInStockDet b where a.id=b.f_ref and b.BuyAskPriceID=@ValueofDB:tblBuyAskPrice_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:BuyInBillNo' != 'null'">	 		
			<error>BuyOrderDel.BillNo.error,@SqlReturn:BuyInBillNo</error>                  
		</exec>
	</sql>
	<!--判断是否被销售报价单引用-->
	<sql type="condition">
		<condition><select>select BillNo as BuyInBillNo from tblSalseQuote a,tblSalseQuoteDet b where a.id=b.f_ref and b.BuyAskPriceDetID=@ValueofDB:tblBuyAskPrice_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:BuyInBillNo' != 'null'">	 		
			<error>BuyAskPrice.BillNo.error,@SqlReturn:BuyInBillNo</error>                  
		</exec>
	</sql>
</define>	
		
<!--================================================以上代码：采购询价单=================================================-->

<!--================================================采购申请单=================================================-->

<define name="tblBuyApplication_add"> 
	<sql type="condition">
		<condition>
			<select>select tblGoods.GoodsFullName as GoodsA,Qty from tblBuyApplicationDet,tblGoods where tblGoods.classCode=tblBuyApplicationDet.GoodsCode and f_ref=@ValueofDB:tblBuyApplication_id and tblBuyApplicationDet.ArriveDate&lt;tblBuyApplicationDet.OrderDate</select>
		  <select>select tblGoods.GoodsFullName as GoodsB from tblBuyApplicationDet,tblGoods where tblGoods.classCode=tblBuyApplicationDet.GoodsCode and f_ref=@ValueofDB:tblBuyApplication_id and tblBuyApplicationDet.ArriveDate='' and tblBuyApplicationDet.OrderDate!=''</select>
		  <select>select tblGoods.GoodsFullName as GoodsC from tblBuyApplicationDet,tblGoods where tblGoods.classCode=tblBuyApplicationDet.GoodsCode and f_ref=@ValueofDB:tblBuyApplication_id and ((tblBuyApplicationDet.ArriveDate&lt;@ValueofDB:BillDate and len(isnull(tblBuyApplicationDet.ArriveDate,''))!=0) or (tblBuyApplicationDet.OrderDate&lt;@ValueofDB:BillDate and len(isnull(tblBuyApplicationDet.OrderDate,''))!=0)) </select>
		</condition>
		<!--输入订货日期，没有输入到货日期判断-->
		<exec condition="'@SqlReturn:GoodsB' != 'null'">				
			<error>BuyApplication.ArriveDate.error,@SqlReturn:GoodsB</error>                  
		</exec>	
			<!--到货日期不小于订货日期判断-->
		<exec condition="'@SqlReturn:GoodsA' != 'null'">				
			<error>tblBuyApplication.ArriveDate.error,@SqlReturn:GoodsA</error>                  
		</exec>
		<!--订货日期、到货日期小于单据日期-->
		<exec condition="'@SqlReturn:GoodsC'!='null'">
			<error>BuyApplication.ArriveDateOrderDate.error,@SqlReturn:GoodsC</error>
		</exec>
        <!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
        <exec condition="'@MEM:Availably'=='true'">     
            <sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
               update tblBuyApplicationDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyApplication  a join tblBuyApplicationDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyApplication_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyApplicationDet.id=a.id</sql>
            <sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
               update tblBuyApplicationDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyApplication a join tblBuyApplicationDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyApplication_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyApplicationDet.id=a.id</sql>
        </exec>
	</sql>
	<sql type="condition">
		<condition><select>select tblGoods.GoodsFullName as GoodsQ,Qty from tblBuyApplicationDet,tblGoods where tblGoods.classCode=tblBuyApplicationDet.GoodsCode and f_ref=@ValueofDB:tblBuyApplication_id and isnull(tblBuyApplicationDet.Qty,0)&lt;=0</select></condition>
		<!--如果录入的数量小于0，给出提示-->	
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">				
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
		<!--设置申请单的未下订单数=数量,订单数量0，这种情况用于点开修改界面时有订单数，但同时另一个用户把关联的订单删除了，再修改申请单，则订单数还是原来的数量-->	
		<exec condition="true">	
			<sql>update tblBuyApplication set statusId=0 where id=@ValueofDB:tblBuyApplication_id</sql>
			<sql>update tblBuyApplicationDet set NoOrderQty=Qty,OrderQty=0,FinishStatus=0 where f_ref=@ValueofDB:tblBuyApplication_id</sql>
     	</exec>
		<!--设置申请单的未出库=申请数量,出库数量0;设置申请单的分配数量=0,未分配数=申请数量-->
		<exec condition="true">	
			<sql>update tblBuyApplicationDet set NotOutStockQty=Qty where f_ref=@ValueofDB:tblBuyApplication_id</sql>
      <sql>update tblBuyApplicationDet set NoOrderQty=Qty where f_ref=@ValueofDB:tblBuyApplication_id</sql>
    </exec>
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblBuyApplicationDet a,tblGoods b where len(ProDate)&gt;0 and len(Availably)&gt;0 and ProDate&gt;Availably and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyApplication_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
</define>
		
<define name="tblBuyApplication_Delete"> 
	<!--状态不是未完成状态，不允许任何操作-->
	<sql type="condition">
		<condition><select>select statusId from tblBuyApplication where id=@ValueofDB:tblBuyApplication_id</select></condition>		
		<exec condition="@SqlReturn:statusId!=0">	 		
			<error>common.noNormallyStatus.oper.error</error>                  
		</exec>
	</sql>
	<!--采购请购单据如果被采购订单引用则不允许被删除-->
	<sql type="condition">
		<condition><select>select a.BillNo as BuyOrderBillNo from tblBuyOrder a,tblBuyOrderDet b where a.id=b.f_ref and b.BuyApplyID=@ValueofDB:tblBuyApplication_id and a.workFlowNodeName!='print'</select></condition>		
		<exec condition="'@SqlReturn:BuyOrderBillNo' != 'null'">	 		
			<error>BuyAskDel.BillNo.error,@SqlReturn:BuyOrderBillNo</error>                  
		</exec>
	</sql>
    <!--采购申请单如果被采购申请汇总单引用则不允许被删除-->
	<sql type="condition">
		<condition><select>select a.BillNo as BuyApplicationTotalBillNo from tblBuyApplicationTotal a,tblBuyApplicationTotalDet b where a.id=b.f_ref and b.BuyApplyID=@ValueofDB:tblBuyApplication_id and a.workFlowNodeName!='print'</select></condition>		
		<exec condition="'@SqlReturn:BuyApplicationTotalBillNo' != 'null'">
			<error>BuyAppTotalDel.BillNo.error,@SqlReturn:BuyApplicationTotalBillNo</error>                
		</exec>
	</sql>
</define>	

<!--采购申请单终止按钮-->
<define name="BuyApplicationStatus_stop">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplication where id=@ValueofDB:tblBuyApplication_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是终止状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==2">
			<error>common.cannotStop.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyApplication set statusId=2 where id=@ValueofDB:tblBuyApplication_id</sql>
			<sql>update tblBuyApplicationDet set NoOrderQty=0,FinishStatus=2 where f_ref=@ValueofDB:tblBuyApplication_id</sql>
		</exec>
   </sql>
</define>

<!--采购申请单完成按钮-->
<define name="BuyApplicationStatus_Finish">
   <sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplication where id=@ValueofDB:tblBuyApplication_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态不是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.cannotFinish.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyApplication set statusId=1 where id=@ValueofDB:tblBuyApplication_id</sql>
			<sql>update tblBuyApplicationDet set NoOrderQty=0,FinishStatus=1 where f_ref=@ValueofDB:tblBuyApplication_id</sql>
		</exec>
   </sql>
</define>

<!--采购申请单激活按钮-->
<define name="BuyApplicationStatus_Reverse">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplication where id=@ValueofDB:tblBuyApplication_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==0">
			<error>common.cannotActive.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyApplication set statusId=0 where id=@ValueofDB:tblBuyApplication_id</sql>
			<sql>update tblBuyApplicationDet set NoOrderQty=case when isnull(Qty,0)-isnull(OrderQty,0)&lt;0 then 0 else isnull(Qty,0)-isnull(OrderQty,0) end,FinishStatus=0 where f_ref=@ValueofDB:tblBuyApplication_id</sql>
		</exec>
	</sql>
</define>	
<!--================================================以上代码：采购申请单=================================================-->


<!--============================================================采购订单==========================================================-->
<define name="tblBuyOrder_add"> 
	<sql type="condition">
		<!--输入了已付订金，没有选择付款账户时给出提示-->
		<exec condition="@ValueofDB:tblBuyOrder_AccountAmount!=0 &amp;&amp; '@ValueofDB:tblBuyOrder_Account'.length==0 "> 
			<error>buyorder.payaccount.error</error>                  
		</exec>	
		<!--选择了付款账户，输入已付订金小于等于0时给出提示-->
		<exec condition="@ValueofDB:tblBuyOrder_AccountAmount&lt;=0 &amp;&amp; '@ValueofDB:tblBuyOrder_Account'.length &gt; 0 "> 
			<error>buyorder.payamount.error</error>                  
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblBuyOrder_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyOrder_Tax!=0)||@ValueofDB:tblBuyOrder_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>           
		</exec>
	</sql>	
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购申请单)-->
		<condition><select>select billDate as QuoteDate from tblBuyApplication where id=@ValueofDB:tblBuyOrder_BuyApplyID</select></condition>
		<exec condition="'@ValueofDB:tblBuyOrder_BuyApplyID'.length&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示（采购询价单）-->
		<condition><select>select billDate as QuoteDate from tblBuyAskPrice where id=@ValueofDB:tblBuyOrder_BuyAskPriceID</select></condition>
		<exec condition="'@ValueofDB:tblBuyOrder_BuyAskPriceID'.length&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">		
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示（销售订单）-->
		<condition><select>select billDate as QuoteDate from tblSalesOrder where id=@ValueofDB:tblBuyOrder_SalesOrderID</select></condition>
		<exec condition="'@ValueofDB:tblBuyOrder_SalesOrderID'.length&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在多单引用的单据之前，给出错误提示（采购询价单）-->
		<condition><select>select len(BuyAskPriceID) as BuyAskPriceID from tblBuyOrderDet where f_ref=@ValueofDB:id  and len(BuyAskPriceID)&gt;0</select>
							 <select>select billDate as QuoteDate from tblBuyAskPrice where id in(select BuyAskPriceID from tblBuyOrderDet where f_ref=@ValueofDB:id  and len(BuyAskPriceID)&gt;0)  order by QuoteDate desc</select>
		</condition>
		<exec condition="'@SqlReturn:BuyAskPriceID'&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">		
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在多单引用的单据之前，给出错误提示（采购申请单）-->
		<condition><select>select len(BuyApplyID) as BuyApplyID from tblBuyOrderDet where f_ref=@ValueofDB:id  and len(BuyApplyID)&gt;0</select>
							 <select>select billDate as QuoteDate from tblBuyApplication where id in(select BuyApplyID as BuyApplyID from tblBuyOrderDet where f_ref=@ValueofDB:id  and len(BuyApplyID)&gt;0)  order by QuoteDate desc</select>
		</condition>
		<exec condition="'@SqlReturn:BuyApplyID'&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">		
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在多单引用的单据之前，给出错误提示（采购申请汇总单）-->
		<condition><select>select len(BuyAppTotalID) as BuyAppTotalID from tblBuyOrderDet where f_ref=@ValueofDB:id and len(BuyAppTotalID)&gt;0</select>
			<select>select billDate as QuoteDate from tblBuyApplicationTotal where id in(select BuyAppTotalID from tblBuyOrderDet where f_ref=@ValueofDB:id and len(BuyAppTotalID)&gt;0)  order by QuoteDate desc</select>
		</condition>
		<exec condition="'@SqlReturn:BuyAppTotalID'&gt;0&amp;&amp;'@ValueofDB:tblBuyOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">		
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyOrder_BillDate,@SqlReturn:QuoteDate</error>                  
		</exec>
	</sql>

	<sql type="condition"><!--修改了引用明细的商品或者属性时，给出错误提示-->
		<condition><select>select 'existsUpdate' as existsUpdateGood from tblBuyOrderDet a,tblBuyApplicationDet b where b.id=a.sourceID and a.f_ref=@ValueofDB:tblBuyOrder_id and (a.goodsCode!=b.goodsCode or a.Hue!=b.Hue or a.Inch!=b.Inch or a.yearNO!=b.yearNO)</select></condition>
		<exec condition="'@SqlReturn:existsUpdateGood'!='null'">			
			<error>ReSelect.QuoteGoods.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblBuyOrderDet a,tblGoods b where len(ProDate)&gt;0 and len(Availably)&gt;0 and ProDate&gt;Availably and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyOrder_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--到货日期不能小于订单日期，给出错误提示-->
		<condition><select>select ArriveDate as ArriveDate from tblBuyOrderDet a  where a.f_ref=@ValueofDB:tblBuyOrder_id and len(a.ArriveDate)!=0 and a.ArriveDate &lt; @ValueofDB:tblBuyOrder_BillDate </select></condition>
		<exec condition="'@SqlReturn:ArriveDate'!='null'"> 
			<error>intimelessbilltime.noallow.error</error>                  
		</exec>	
	</sql>
	<sql type="condition"><!--数量小于等于0时，给出错误提示-->
		<condition><select>select tblGoods.GoodsFullName as GoodsQ,Qty from tblBuyOrderDet,tblGoods where f_ref=@ValueofDB:tblBuyOrder_id and tblGoods.classCode=tblBuyOrderDet.GoodsCode and isnull(tblBuyOrderDet.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">						
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>	
	</sql>

	<sql type="condition"><!--非赠品，样品的单价小于等于0时，给出错误提示-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblBuyOrderDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyOrder_id and a.PresentSampleType not in ('1','2') and b.classCode=a.GoodsCode and (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0))</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblBuyOrder_Add_PriceControl_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--商品是赠样品时单价不为零，给出错误提示-->
		<condition><select>select tblGoods.GoodsFullName as GoodsSample from tblBuyOrderDet,tblGoods where f_ref=@ValueofDB:tblBuyOrder_id and tblGoods.classCode=tblBuyOrderDet.GoodsCode and tblBuyOrderDet.PresentSampleType in ('1','2') and isnull(tblBuyOrderDet.Price,0)!=0</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">	 					
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--采购订单合计金额与明细表合计金额不相等，给出错误提示-->
		<condition><select>select dbo.getDigits('tblBuyOrderDet','TaxAmount',sum(tblBuyOrderDet.TaxAmount)) as SumDetAmt from tblBuyOrderDet where  tblBuyOrderDet.f_ref=@ValueofDB:tblBuyOrder_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblBuyOrder_TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblBuyOrder_TotalTaxAmount,@SqlReturn:SumDetAmt</error>                  
		</exec>	
	</sql>	

	<!--=====================外币暂不处理==========================-->
  <sql type="condition">
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblBuyOrder_Account and SCompanyID=@ValueofDB:tblBuyOrder_SCompanyID</select></condition>
		<!--币种为空，付款帐户不为空时，选择的付款帐户存在核算外币时提示-->		
    <exec condition="'@ValueofDB:tblBuyOrder_Currency'.length != 0 &amp;&amp; '@ValueofDB:tblBuyOrder_Account'.length !=0 &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  ) ">
		  <error>tblAccTypeInfo.SelectCurType.error</error>                  
	  </exec>	
    <!--币种不为空，付款帐户不为空时，选择的付款帐户核算的币种跟所选的币种不一致时提示-->
	  <exec condition="'@ValueofDB:tblBuyOrder_Currency'.length == 0 &amp;&amp; '@ValueofDB:tblBuyOrder_Account'.length !=0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL')  ">
		  <error>tblAccTypeInfo.SelectCurType.error</error>                  
	  </exec>	
		<!--如果是本位币帐户，不用录入汇率-->	
	  <exec condition=" ('@ValueofDB:tblBuyOrder_Currency'.length == 0 &amp;&amp; @ValueofDB:tblBuyOrder_CurrencyRate&gt; 0 &amp;&amp; @ValueofDB:tblBuyOrder_CurrencyRate!=1)">		
      <error>CurrencyRate.putErrors.error</error>                  
	  </exec>
	</sql>
	<!--==================以上代码：外币暂不处理========================-->	
	<sql type="condition">
		<!--启用多仓库更新明细表上的仓库值，以便于报表查询数据及统计数据-->
		<exec condition="'@MEM:ManyStockBuy'=='false'">
			<sql>update tblBuyOrderDet set tblBuyOrderDet.StockCode=tblBuyOrder.StockCode from tblBuyOrder where tblBuyOrder.id=tblBuyOrderDet.f_ref and tblBuyOrder.id=@ValueofDB:tblBuyOrder_id and len(tblBuyOrder.StockCode)&gt;0 and tblBuyOrder.StockCode is not null</sql>	
		</exec>
		<!--如果是引用采购申请单，设置明细表的申请ID=主表申请ID-->
		<exec condition="'@ValueofDB:tblBuyOrder_BuyApplyID'.length&gt;0">
			<sql>update tblBuyOrderDet set BuyApplyID=@ValueofDB:tblBuyOrder_BuyApplyID,BuyApplyNo=@ValueofDB:tblBuyOrder_BuyApplyNo where f_ref=@ValueofDB:tblBuyOrder_id and len(isnull(BuyApplyID,''))=0</sql>	
		</exec>
		<!--如果是引用销售订单，修改销售订单已下订单-->
		<exec condition="'@ValueofDB:tblBuyOrder_SalesOrderID'.length&gt;0">
			<sql>update tblSalesOrder set HasBuyOrder=1 where id=@ValueofDB:tblBuyOrder_SalesOrderID</sql>	
		</exec>
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			   update tblBuyOrderDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyOrder  a join tblBuyOrderDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyOrder_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyOrderDet.id=a.id</sql>
			<sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			   update tblBuyOrderDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyOrder a join tblBuyOrderDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyOrder_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyOrderDet.id=a.id</sql>
		</exec>
		<exec condition="true">
			<!--更新订单中的未入库数量为订单数量-->
			<sql>update tblBuyOrderDet set NotInQty=Qty,InQty=0,FinishStatus=0,NotPayQty=Qty,PayQty=0,NoInvoiceAmount=TaxAmount,InvoiceAmount=0,InvoiceStatus=0 where f_ref=@ValueofDB:tblBuyOrder_id</sql>
			<!---累计付款=已付订金-->
		<sql>update tblBuyOrder set statusId=0,TotalPayAmt=AccountAmount,NotAmortDeposit=AccountAmount,CurTotalPayAmt=CurAccountAmount,CurNotAmortDeposit=CurAccountAmount,ReceiveAmt=0,CurReceiveAmt=0,CertificateNo='',NoInvoiceAmount=TotalTaxAmount,InvoiceAmount=0,InvoiceStatus=0 where id=@ValueofDB:tblBuyOrder_id</sql>			
		</exec>
		<!--保存单据时就更新申请单的数量-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyOrderBackFillApp(@ValueofDB:tblBuyOrder_id,add,retCode,retVal)}</sql>
		</exec>
		<!--采购订单引用采购申请汇总单，更新汇总单明细-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyOrderBackFillApplyTotal(@ValueofDB:tblBuyOrder_id,add,retCode,retVal)}</sql>
		</exec>
		<!--不启用审核流,并且不启用开票，要执行下面的操作，否则会在审核和开票操作时执行-->
		<exec condition="'@MEM:tblBuyOrder_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblBuyOrder_Add_One</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--系统配置“采购订单单价差异提醒”-->
		<condition><select>SELECT c.GoodsFullName,@MEM:DifferenceOfPriceInBuyOrder as DifferPrice FROM tblBuyOrderDet a JOIN tblBuyOrderDet b ON a.GoodsCode = b.GoodsCode AND ISNULL(a.BatchNo,'') = ISNULL(b.BatchNo,'') AND ISNULL(a.Inch,'') = ISNULL(b.Inch,'') AND ISNULL(a.Hue,'') = ISNULL(b.Hue,'') AND ISNULL(a.yearNO,'') = ISNULL(b.yearNO,'') AND ISNULL(a.ProDate,'') = ISNULL(b.ProDate,'') AND ISNULL(a.Availably,'') = ISNULL(b.Availably,'') JOIN tblGoods c ON a.GoodsCode = c.classCode WHERE a.f_ref = @ValueofDB:tblBuyOrder_id AND b.f_ref!=@ValueofDB:tblBuyOrder_id AND (CASE WHEN a.Price = 0 THEN 0 ELSE (a.Price - b.Price)/a.Price*100 END)&gt;@MEM:DifferenceOfPriceInBuyOrder</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;'@SqlReturn:GoodsFullName'.length!=0&amp;&amp;'@MEM:tblBuyOrder_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false&amp;&amp;@SqlReturn:DifferPrice&gt;0">
			<confirm yesDefine="tblBuyOrder_Add_One" noDefine="">tblBuyOrder.add.GoodsPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DifferPrice</confirm>
		</exec>
	</sql>
</define>

<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=========-->
<define name="tblBuyOrder_Add_PriceControl_Validate">
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblBuyOrderDet a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='Buy' and UserID=@ValueofDB:tblBuyOrder_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblBuyOrder_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>                  
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">		
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>                  
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>                  
		</exec>
	</sql>
</define>

<define name="tblBuyOrder_Add_One"> 	
	<sql type="condition"><!--付款金额大于0，插入往来明细，插入凭证，插入付款单-->		
		<exec condition="@ValueofDB:tblBuyOrder_AccountAmount&gt;0">
			<sql type="define">tblBuyOrder_Add_ExistPayAmt</sql>
		</exec>
	</sql>	
</define>
<!--==================如果付款金额大于0，插入往来明细，产生凭证，产生付款单============-->
<define name="tblBuyOrder_Add_ExistPayAmt">
	<sql type="condition">
		<condition>
			<!--查询贷结算金额等便后续使用-->
			<select>select (case when cast(@ValueofDB:tblBuyOrder_AccountAmount as numeric(18,8))&gt;=cast(@ValueofDB:tblBuyOrder_TotalTaxAmount  as numeric(18,8)) then @ValueofDB:tblBuyOrder_TotalTaxAmount else @ValueofDB:tblBuyOrder_AccountAmount end) as ExeBalAmt,(case when cast(@ValueofDB:tblBuyOrder_CurAccountAmount as numeric(18,8))&gt;=cast(@ValueofDB:tblBuyOrder_CurTotalAmount as numeric(18,8)) then @ValueofDB:tblBuyOrder_CurTotalAmount else @ValueofDB:tblBuyOrder_CurAccountAmount end) as ExeBalFcAmt</select>
			<!--查询明细中第一个商品，作为凭证的备注-->
			<select>select GoodsFullName as AccGood from tblBuyOrderDet a,tblGoods b where a.goodsCode=b.classCode and a.f_ref=@ValueofDB:tblBuyOrder_id</select>
			<!--查询往来单位的名称，作为备注-->
			<select>select ComFullName as AccCom from tblCompany  where classCode=@ValueofDB:tblBuyOrder_CompanyCode</select>
		</condition>
		<!--未启用预收预付记应收应付,要影响往来的预付金额,往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false'">			
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblBuyOrder_id,@ValueofDB:tblBuyOrder_CompanyCode,3,@ValueofDB:tblBuyOrder_BillDate,Period=@ValueofDB:tblBuyOrder_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyOrder_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyOrder_PeriodMonth@SPFieldLink:PrePayTotalLend=0@SPFieldLink:PrePayTotalDebit=@ValueofDB:tblBuyOrder_AccountAmount@SPFieldLink:RelationDocID=@ValueofDB:tblBuyOrder_id@SPFieldLink:Currency=@ValueofDB:tblBuyOrder_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyOrder_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=@ValueofDB:tblBuyOrder_CurAccountAmount@SPFieldLink:FcPrePayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyOrder_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyOrder_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyOrder_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyOrder_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyOrder_SCompanyID@SPFieldLink:BillType=tblBuyOrder@SPFieldLink:BillNo=@ValueofDB:tblBuyOrder_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyOrder_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyOrder_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblBuyOrder_Remark,retCode,retVal)}</sql>
		</exec>
		<!--已启用预收预付记应收应付,要影响往来的应付金额,往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='true'">					
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblBuyOrder_id,@ValueofDB:tblBuyOrder_CompanyCode,1,@ValueofDB:tblBuyOrder_BillDate,Period=@ValueofDB:tblBuyOrder_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyOrder_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyOrder_PeriodMonth@SPFieldLink:PayTotalLend=0@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyOrder_AccountAmount@SPFieldLink:RelationDocID=@ValueofDB:tblBuyOrder_id@SPFieldLink:Currency=@ValueofDB:tblBuyOrder_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyOrder_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblBuyOrder_CurAccountAmount@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyOrder_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyOrder_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyOrder_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyOrder_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyOrder_SCompanyID@SPFieldLink:BillType=tblBuyOrder@SPFieldLink:BillNo=@ValueofDB:tblBuyOrder_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyOrder_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyOrder_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblBuyOrder_Remark,retCode,retVal)}</sql>
		</exec>
		<exec condition="true">
			<!--插入数据到采购付款单主表-->
		  <sql>insert into tblPay (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,Paytype,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo,PaytypeID,SettleAmt,FactOutcome,AccAmt,Currency,CurrencyRate,CurrencyAmt) values ('0'+@ValueofDB:tblBuyOrder_id,@ValueofDB:tblBuyOrder_BillDate,@CODE:[tblPay_BillNo],@ValueofDB:tblBuyOrder_CompanyCode,@ValueofDB:tblBuyOrder_DepartmentCode,@ValueofDB:tblBuyOrder_EmployeeID,1,@ValueofDB:tblBuyOrder_PeriodYear,@ValueofDB:tblBuyOrder_PeriodMonth,@ValueofDB:tblBuyOrder_Period,@ValueofDB:tblBuyOrder_createBy,@ValueofDB:tblBuyOrder_createTime,@ValueofDB:tblBuyOrder_lastUpdateBy,@ValueofDB:tblBuyOrder_lastUpdateTime,@ValueofDB:tblBuyOrder_SCompanyID,1,'finish','-1','',@ValueofDB:tblBuyOrder_TrackNo, 'PrePay' ,@ValueofDB:tblBuyOrder_AccountAmount,@ValueofDB:tblBuyOrder_AccountAmount,@ValueofDB:tblBuyOrder_AccountAmount,@ValueofDB:tblBuyOrder_Currency,@ValueofDB:tblBuyOrder_CurrencyRate,@ValueofDB:tblBuyOrder_CurAccountAmount)</sql>
			<!--插入数据到采购付款单明细表,当付款金额大于单据金额，本次结算金额=单据金额，否则本次结算金额=付款金额-->
			<sql>insert into tblPayDet (id,f_ref,BillAmt,Remark,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,BuyOrderNo,BuyOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,PayBillType) values ('1'+@ValueofDB:tblBuyOrder_id,'0'+@ValueofDB:tblBuyOrder_id,@ValueofDB:tblBuyOrder_TotalTaxAmount,@ValueofDB:tblBuyOrder_Remark,@ValueofDB:tblBuyOrder_CurTotalAmount,@SqlReturn:ExeBalAmt,@SqlReturn:ExeBalFcAmt,@ValueofDB:tblBuyOrder_Currency,@ValueofDB:tblBuyOrder_CurrencyRate,0,@ValueofDB:tblBuyOrder_TotalTaxAmount,0,@ValueofDB:tblBuyOrder_CurTotalAmount,@ValueofDB:tblBuyOrder_BillNo,@ValueofDB:tblBuyOrder_BillNo,@ValueofDB:tblBuyOrder_id,0,@ValueofDB:tblBuyOrder_SCompanyID,0,@ValueofDB:tblBuyOrder_id,'tblBuyOrder')</sql>
		</exec>
		<!--启用多账户付款,将付款账户信息插入到付款单的“付款账户明细表”中，并将主表的账户设置成空-->	
		<exec condition="true">
			<sql>insert into tblPayAccountDet(id,f_ref,PayType,Amount,Account,SCompanyID,ExeBalFcAmt) select '1'+id,'0'+id,'1',AccountAmount,Account,SCompanyID,CurAccountAmount from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id</sql>
		</exec>
		<!--自动生成的单据需更新单据编号连续-->
		<exec condition="'@MEM:BillNoSequence'=='true'">  
			<sql>update tblCodeGenerate set curValue=curValue+1 where code='BP'</sql>
		</exec>	
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'">	
			<sql type="certificate">tblBuyOrder_Acc</sql>
		</exec>
	</sql>
</define>

<!--删除，修改采购订单调用此define-->
<!--此define功能适用于未启用审核流时修改，删除和启用审核流时的反审核操作。启用了审核流删除和修改操作不用执行此代码。但表结构调用不能做判断，故在此判断-->   
<define name="tblBuyOrder_Delete">
	<sql type="condition">
		<!--只有删除单据才执行回填申请单动作-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyOrderBackFillApp(@ValueofDB:tblBuyOrder_id,delete,retCode,retVal)}</sql>
		</exec>
		<!--删除采购订单，更新采购申请汇总明细-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyOrderBackFillApplyTotal(@ValueofDB:tblBuyOrder_id,delete,retCode,retVal)}</sql>
		</exec>
		<exec condition="@MEM:tblBuyOrder_IsStatart==0 &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblBuyOrder_Del_One</sql> 
		</exec>
	</sql>	
</define>

<define name="tblBuyOrder_Del_One">
	<!--提示类的判断-->	
	<sql type="condition"><!--若是订单状态不是未完成,不允许执行数据更新操作 -->
		<condition><select>select statusId from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id</select></condition>
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.noNormallyStatus.oper.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--凭证启用了审核流，关联次单据的审核流已经审核完毕，不能修改此单 -->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblBuyOrder_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--被采购入库单引用，不允许修改 -->
		<condition><select>select BillNo as BuyInBillNo from tblBuyInStock a,tblBuyInStockDet b where a.id=b.f_ref and b.BuyOrderID=@ValueofDB:tblBuyOrder_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:BuyInBillNo' != 'null'">	 					
			<error>BuyOrderDel.BillNo.error,@SqlReturn:BuyInBillNo</error>                  
		</exec>
	</sql>	

	<sql type="condition"><!--存在不是自动生成的付款单时，不允许修改-->
		<condition><select>select tblPay.BillNo as PayBillNo from tblPay left join tblPayDet on tblPay.id=tblPayDet.f_ref where tblPayDet.RefbillID=@ValueofDB:tblBuyOrder_id and tblPay.workFlowNodeName!='print' and tblPay.AutoBillMarker=0</select></condition>
		<exec condition="'@SqlReturn:PayBillNo' != 'null'"> 					
			<error>PayBill.BillNo.error,@SqlReturn:PayBillNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--判断自动产生的付款单是否存在付款退款-->
		<condition><select>select BillNo as PayReNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=(select a.id from tblPay a,tblPayDet b where a.id=b.f_ref and RefbillID=@ValueofDB:tblBuyOrder_id and a.AutoBillMarker=1) and tblPay.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:PayReNo'!='null'">	 					
			<error>PayDel.receiveNo.error,@SqlReturn:PayReNo</error>                  
		</exec>
	</sql>
	<!--逻辑代码的执行-->
	<sql type="condition">
		<!--查询是否是引用采购申请单，已付订金-->
		<condition><select>select AccountAmount,SalesOrderID,AutoBillMarker from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id </select></condition>		
		<!--付款金额大于0，删除科目余额，凭证，往来，付款单-->
		<exec condition="@SqlReturn:AccountAmount&gt;0">
			<sql type="define">tblBuyOrder_Del_ExistPayAmt</sql> 
		</exec>
		<exec condition="'@Sess:BillOper'=='delete'&amp;&amp;'@SqlReturn:SalesOrderID'.length&gt;0">
			<sql>update tblSalesOrder set HasBuyOrder=0 where id=@SqlReturn:SalesOrderID and (select count(0) from tblBuyOrder where SalesOrderID=@SqlReturn:SalesOrderID)=1</sql>
		</exec>
	</sql>	
	   <sql type="condition">
  		<condition>
  			<select>select BuyAppTotalID from tblBuyOrderDet where f_ref=@ValueofDB:id and len(BuyAppTotalID)&gt;0</select>
  		  <select>select SUM(b.NoOrderQty) as NoOrderQty from tblBuyApplicationTotal a join tblBuyApplicationTotalDet b on a.id=b.f_ref where a.id=@SqlReturn:BuyAppTotalID</select>
  		</condition>
		  <exec condition="'@SqlReturn:NoOrderQty'&gt;0">	 		
			  <sql>update tblBuyApplicationTotal set statusId=0 where id=@SqlReturn:BuyAppTotalID</sql>       
		  </exec>
	 </sql>  	
</define>

<define name="tblBuyOrder_Del_ExistPayAmt">
	<sql type="condition"> <!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'">
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblBuyOrder_id,retCode,retVal)}</sql>
		</exec>
	 </sql>	 
	<sql type="condition">
	  <exec condition="true"> <!--根据是否启用 预收预付记应收应付,决定删除往来明细的类型,（1应付 2应收 3预付 4预收）-->
		  <sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblBuyOrder_id',proc_deleteComIni,@IniId@ParamLink:(case when '@MEM:prerecvpaymarktoneedrecvpay'='true' then 1 else 3 end),retCode,retVal)}</sql>
	  </exec>
	</sql>  
	<!--删除付款单-->
	<sql>delete from tblPayDet where f_ref='0'+@ValueofDB:tblBuyOrder_id</sql>
	<sql>delete from tblPayAccountDet where f_ref='0'+@ValueofDB:tblBuyOrder_id</sql>
	<sql>delete from tblPay where id='0'+@ValueofDB:tblBuyOrder_id</sql>
	<sql>delete from tblTrackBill where RelationID='0'+@ValueofDB:tblBuyOrder_id</sql>
</define>


<!--采购订单终止按钮-->
<define name="BuyOrderStatus_stop">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是终止状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==2">
			<error>common.cannotStop.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyOrder set statusId=2 where id=@ValueofDB:tblBuyOrder_id</sql>
			<sql>update tblBuyOrderDet set NotInQty=0,FinishStatus=2 where f_ref=@ValueofDB:tblBuyOrder_id</sql>
		</exec>
   </sql>
</define>

<!--采购订单完成按钮-->
<define name="BuyOrderStatus_finish">
   <sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态不是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.cannotFinish.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyOrder set statusId=1 where id=@ValueofDB:tblBuyOrder_id</sql>
			<sql>update tblBuyOrderDet set NotInQty=0,FinishStatus=1 where f_ref=@ValueofDB:tblBuyOrder_id</sql>
		</exec>
   </sql>
</define>

<!--采购订单激活按钮-->
<define name="BuyOrderStatusStop_reverse">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblBuyOrder where id=@ValueofDB:tblBuyOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==0">
			<error>common.cannotActive.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblBuyOrder set statusId=0 where id=@ValueofDB:tblBuyOrder_id</sql>
			<sql>update tblBuyOrderDet set NotInQty=case when isnull(Qty,0)-isnull(InQty,0)&lt;0 then 0 else isnull(Qty,0)-isnull(InQty,0) end,FinishStatus=0 where f_ref=@ValueofDB:tblBuyOrder_id</sql>
		</exec>
	</sql>
</define>	

<!--==============================================以上代码：采购订单=========================================================-->
	


<!--==============================================采购入库单=========================================================-->
<define name="tblBuyInStock_Add">
	<!--===============不用查询数据库的判断(依据主表数据)=================-->
	<sql type="condition"> 
		
		<!--如果主表优惠后金额为负数 提示错误--> 
		<exec condition="@ValueofDB:tblBuyInStock_TotalTaxAmount &lt; 0">
		  <error>common.TotalTaxAmount.negative.error</error>                  
	  </exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblBuyInStock_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyInStock_Tax!=0)||@ValueofDB:tblBuyInStock_Tax&lt;0">
			<error>common.isReceipt.existsTax.error</error>           
		</exec>		
		<!--如果运费金额小于0，提示错误--> 
		<exec condition="@ValueofDB:tblBuyInStock_freightAmount &lt; 0">
		  <error>运费金额不能小于0！</error>                  
	  </exec>
		<!--如果运费金额大于0，运费科目为空，提示错误-->
		<exec condition="@ValueofDB:tblBuyInStock_freightAmount&gt;0&amp;&amp;'@ValueofDB:tblBuyInStock_freightAcc'.length==0">
			<error>请选择运费科目！</error>           
		</exec>	
	</sql>	
	<sql type="condition">
		<!--如果通过引用按钮引用，将采购订单的ID设置到明细表-->		
		<exec condition="'@ValueofDB:tblBuyInStock_BuyOrderID'.length&gt;0">
			<sql>update tblBuyInStockDet set BuyOrderID=@ValueofDB:tblBuyInStock_BuyOrderID where f_ref=@ValueofDB:tblBuyInStock_id and len(isnull(BuyOrderID,''))=0</sql>	
		</exec>
		<exec condition="'@ValueofDB:tblBuyInStock_BuyAskPriceID'.length&gt;0">
			<sql>update tblBuyInStockDet set BuyAskPriceID=@ValueofDB:tblBuyInStock_BuyAskPriceID where f_ref=@ValueofDB:tblBuyInStock_id and len(isnull(BuyAskPriceID,''))=0</sql>	
		</exec>
		<exec condition="true"><!--引用采购订单，询价单的控制判断-->
			<sql type="define">tblBuyInStock_Add_QuoteOrder_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了系统配置“采购入库单必须引用采购订单”，如果没有引用单据或者引用的商品及属性不匹配给出错误提示-->		
		<condition><select>select count(0) NoQuote from tblBuyInStockDet a left join tblBuyOrderDet b on isnull(a.BuyOrderID,'')=b.f_ref and a.GoodsCode=b.GoodsCode and (a.BatchNo=b.BatchNo or b.BatchNo='') and (a.Inch=b.Inch or b.Inch='') and (a.Hue=b.Hue or b.Hue='') and (a.yearNo=b.yearNo or b.yearNo='') and (a.ProDate=b.ProDate or b.ProDate='') and (a.Availably=b.Availably or b.Availably='') where @MEM:QuoteOrder ='true' and a.f_ref=@ValueofDB:tblBuyInStock_id and b.id is null</select></condition>		
		<exec condition="@SqlReturn:NoQuote&gt;0">
			<error>BuyInStock.quoteOrder.error</error>                  
		</exec>
	</sql>
	<!--==============要查询数据库数据进行判断=================-->
	<sql type="condition"><!--引用单据发票类型与主表不符-->
		<condition><select>select tblBuyOrder.BillNo as BuyOrderID from tblBuyInStock left join tblBuyInStockDet on tblBuyInStock.id=tblBuyInStockDet.f_ref left join tblBuyOrderDet on tblBuyOrderDet.id=tblBuyInStockDet.SourceID inner join tblBuyOrder on tblBuyOrder.id=tblBuyOrderDet.f_ref where tblBuyInStockDet.f_ref=@ValueofDB:tblBuyInStock_id and tblBuyInStock.InVoiceType!=tblBuyOrder.InVoiceType</select></condition>
		<exec condition="'@SqlReturn:BuyOrderID' != 'null'">			
			<error>tblBuyInStock.InvoiceType.error,@SqlReturn:BuyOrderID</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select tblGoods.GoodsFullName as GoodsQ from tblBuyInStockDet,tblGoods where len(ProDate)&gt;0 and len(Availably)&gt;0 and ProDate&gt;Availably and tblGoods.classCode=tblBuyInStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyInStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--数量小于等于0的商品判断-->
		<condition><select>select tblGoods.GoodsFullName as GoodsQ from tblBuyInStockDet,tblGoods where isnull(tblBuyInStockDet.Qty,0)&lt;=0 and tblGoods.classCode=tblBuyInStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyInStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	
	<sql type="condition"><!--非赠品，样品单价小于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblBuyInStockDet a,tblGoods b where (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyInStock_id and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--赠品，样品单价不等于0的商品判断-->
		<condition><select>select tblGoods.GoodsFullName as GoodsSample from tblBuyInStockDet,tblGoods where isnull(tblBuyInStockDet.Price,0)!=0 and tblGoods.classCode=tblBuyInStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyInStock_id and tblBuyInStockDet.PresentSampleType in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblBuyInStock_Add_PriceControl_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--折扣不是0到100之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblBuyInStockDet a where a.f_ref=@ValueofDB:tblBuyInStock_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>折扣必须输入大于0并且小于等于100的数值！</error>                   
		</exec>
	</sql>
	<!--  <sql type="condition">明细表的金额不等于数量*单价 由于金额可能是由含税金额推算出来的，可能相差几分钱
		<condition><select>select b.GoodsNumber,b.GoodsFullName from tblBuyInStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyInStock_id and a.GoodsCode=b.classCode and Amount!=round(Qty*Price,@MEM:DigitsAmount)</select></condition>
		<exec condition="'@SqlReturn:GoodsNumber'!='null'">			
			<error>common.AmtPriceQty.NotEqual.error,@SqlReturn:GoodsNumber,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>  -->
	<sql type="condition"><!--主表总金额与明细表不相等-->
		<condition><select>select dbo.getDigits('tblBuyInStockDet','TaxAmount',sum(tblBuyInStockDet.TaxAmount)) as SumDetAmt,dbo.getDigits('tblBuyInStockDet','TaxAmount',(cast(@ValueofDB:tblBuyInStock_TotalTaxAmount as numeric(18,8))+cast(@ValueofDB:tblBuyInStock_DiscountAmount as numeric(18,8)))) as sumMainAmt from tblBuyInStockDet where  tblBuyInStockDet.f_ref=@ValueofDB:tblBuyInStock_id</select></condition>
		<exec condition="@SqlReturn:SumDetAmt!=@SqlReturn:sumMainAmt">			
			<error>common.mainDetilAmt.NotEqual.error,@SqlReturn:sumMainAmt,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblBuyInStockDet a left join tblgoods c on c.classCode=a.GoodsCode where c.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblBuyInstock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>                  
	    </exec>
	</sql>
	<!--启用了多账户，进行多账户的判断提示-->
	<sql type="define">tblBuyInStock_Add_ManyAccount_Validate</sql>
	
	<!--=====================外币的没有做整理==================================-->
	<sql type="condition">
		<condition>
		<!--查询所选的付款帐户对应的科目代码、科目名、是否核算外币、核算的币种信息-->
		<select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblBuyInStock_PayAccount and SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID</select>
		<!--多账户付款查询所选的付款帐户对应的科目代码、科目名、是否核算外币、核算的币种信息-->
		<select>select Account as AnyAccount from tblBuyPayAccount left join tblAccTypeinfo on tblAccTypeinfo.Accnumber=tblBuyPayAccount.Account where f_ref=@ValueofDB:tblBuyInStock_id and ((len(@ValueofDB:tblBuyInStock_Currency) &gt; 0 and tblAccTypeInfo.Currency!=@ValueofDB:tblBuyInStock_Currency) or (len(@ValueofDB:tblBuyInStock_Currency)=0 and len(tblAccTypeInfo.Currency)!=0))</select>
		</condition>
		<!--币种和税率存在外币币种时税率必须大于0-->
		<exec condition="'@ValueofDB:tblBuyInStock_Currency'.length&gt;0 &amp;&amp; @ValueofDB:tblBuyInStock_CurrencyRate &lt;= 0"> 
			<error>Currency.InputCurrencyRate.error</error>                  
		</exec>
		<!--币种为空，付款帐户不为空时，选择的付款多帐户存在核算外币时提示-->
		<exec condition="'@SqlReturn:AnyAccount' != 'null'">
			<error>tblAccTypeInfo.SelectCurType.error</error>                  
		</exec>
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblBuyInStock_Currency'.length == 0 &amp;&amp; @ValueofDB:tblBuyInStock_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblBuyInStock_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error>                  
		</exec>
	</sql>
	<!--=====================以上代码：外币的没有做整理==================================-->
	<sql type="condition"><!--有引用单据，并且启用了控制超订单入库系统配置，判断是否有超订单入库-->
		<exec condition="'@MEM:OverBuyorder'=='true'">
			<sql type="define">tblBuyInStock_Add_OverOrderIn_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--当提示是否超订单入库时，点击确定执行的define-->
		<exec condition="true">			
			<sql type="define">tblBuyInStock_Add_AccBefore</sql>
		</exec>
	</sql>
	<sql type="condition">
	<!--天助蜂巢调用接口-->

	<condition>
		<select>			
			select 'http://fc.tz1288.com/fc.asmx/GetWebSiteCount' as url,'xst9527008' as UserName,'2017-12-20' as StartDateTime, '2018-12-20' as EndDateTime, '20' as wsCount, 'bc2731782e6b86b01303d9c6d6d22ff9' as Token
		</select>
	</condition>

		<exec condition="true">
			<sql type="class">tzhive.HiveServlet.optHive(@SqlReturn:url,@SqlReturn:UserName,@SqlReturn:StartDateTime,@SqlReturn:EndDateTime,@SqlReturn:wsCount,@SqlReturn:Token)</sql>
		</exec>
	</sql>
</define>

<!--======当提示是否超订单入库时，点击确定执行的define=====-->
<define name="tblBuyInStock_Add_AccBefore">
	<!--更改主表待付金额=总金额-付款金额，累计付款金额=付款金额,未开票金额=优惠后金额-->	
	<sql>update tblBuyInStock set AfterChangeAmt=TotalTaxAmount,CurAfterChangeAmt=CurTotalAmount,NoInvoiceAmount=TotalTaxAmount,InvoiceAmount=0,InvoiceStatus=0,NeedPayAmt=TotalTaxAmount-PayAmount+(case when freightAcc like '2202%' then freightAmount else 0 end),CurNeedPayAmt=round(CurTotalAmount-CurAlrPayAmt+(case when freightAcc like '2202%' then freightAmount/CurrencyRate else 0 end),@MEM:DigitsAmount),AlreadyPayAmt=PayAmount,CurAlreadyPayAmt=CurAlrPayAmt,BackAmount=0,CurBackAmount=0,CertificateNo='' where id=@ValueofDB:tblBuyInStock_id</sql>
	<!--采购入库单保存时回填明细中优惠后金额-->
	<sql>update tblBuyInStockDet set PreferBackAmount=case when tblBuyInStock.TotalTaxAmount+tblBuyInStock.DiscountAmount=0 then 0 else round(tblBuyInStock.TotalTaxAmount*tblBuyInStockDet.TaxAmount/(tblBuyInStock.TotalTaxAmount+tblBuyInStock.DiscountAmount),@MEM:DigitsAmount) end  FROM tblBuyInStock where tblBuyInStockDet.f_ref=@ValueofDB:tblBuyInstock_id and tblBuyInstock.id=@ValueofDB:tblBuyInstock_id</sql>
	<sql>update tblBuyInStockDet set tblBuyInStockDet.PreferAmount=tblBuyInStockDet.TaxAmount-tblBuyInStockDet.PreferBackAmount FROM tblBuyInStock where tblBuyInStockDet.f_ref=@ValueofDB:tblBuyInstock_id and tblBuyInstock.id=@ValueofDB:tblBuyInstock_id</sql>
	<!--采购入库单保存时回填明细中未开票金额-->
	<sql>update tblBuyInStockDet set NoInvoiceAmount=PreferBackAmount,InvoiceAmount=0,InvoiceStatus=0,FactInQty=Qty,BackQty=0,InvoiceQty=0,NotInvoiceQty=Qty where f_ref=@ValueofDB:tblBuyInstock_id</sql>
	<!--采购入库单的运费分摊到明细中-->
	<sql>update tblBuyInStockDet set freightAmount=case when (tblBuyInstock.TotalTaxAmount+tblBuyInstock.DiscountAmount)=0 then 0 else TaxAmount/(tblBuyInstock.TotalTaxAmount+tblBuyInstock.DiscountAmount)*tblBuyInstock.freightAmount end from tblBuyInstock where tblBuyInstock.id=@ValueofDB:tblBuyInstock_id and f_ref=tblBuyInstock.id</sql>
	
	<sql type="condition">
		<!--没有启用多仓库，用主表的仓库更新明细表上的仓库值-->
		<exec condition="'@MEM:ManyStockBuy'=='false'">
			<sql>update tblBuyInStockDet set StockCode=(select StockCode from tblBuyInStock where id=@ValueofDB:tblBuyInStock_id) where f_ref=@ValueofDB:tblBuyInStock_id</sql>	
		</exec>		
		<!--如果通过引用按钮引用，将采购订单的ID设置到明细表-->
		<exec condition="'@ValueofDB:tblBuyInStock_BuyOrderID'.length&gt;0">
			<sql>update tblBuyInStockDet set BuyOrderID=@ValueofDB:tblBuyInStock_BuyOrderID where f_ref=@ValueofDB:tblBuyInStock_id and len(isnull(BuyOrderID,''))=0</sql>	
		</exec>
		<!--更新采购订单的入库数量，未入库数量，状态等信息-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyUpdateOrderQty(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>	
	</sql>
	<sql type="condition">
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">	
			<!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->	
			<sql>update tblBuyInStockDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyInStock  a join tblBuyInStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyInStock_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyInStockDet.id=a.id</sql>
			<!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			<sql>update tblBuyInStockDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyInStock  a join tblBuyInStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyInStock_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyInStockDet.id=a.id</sql>
		</exec>
	</sql>

	<sql type="condition">
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillType=tblBuyInStock,@InstoreQty=tblBuyInStockDet.Qty,@OutstoreQty=0,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新未审核完毕的序列号出入明细-->
		<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		
		<!--=============过账操作（不启用审核流直接执行，启用审核时通过点击审核按钮调用）===============-->
		<exec condition="'@MEM:tblBuyInStock_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblBuyInStock_Add_One</sql>
		</exec>
	</sql>
</define>
<!--=======启用了价格跟踪，向价格管理表中插入数据================-->
<define name="tblBuyInStock_Add_PriceTracking">
	<sql type="condition">
		<condition>
			<select>select id as CPID from tblCustomerPrice where CompanyCode=@ValueofDB:tblBuyInStock_CompanyCode</select>
			<select>select lower(substring(replace(newid(),'-',''),1,28)) as CustomerPriceId</select>
		</condition>
		<!--判断如果价格管理表中没有此供应商的记录，插入一条主表记录-->
		<exec condition="'@SqlReturn:CPID'=='null'">
			<sql>insert into tblCustomerPrice(id,classCode,workFlowNodeName,CompanyCode,createBy,lastUpdateBy,createTime,lastUpdateTime,statusId,SCompanyID) values(@SqlReturn:CustomerPriceId,'','finish',@ValueofDB:tblBuyInStock_CompanyCode,'1','1',@ValueofDB:tblBuyInStock_createTime,@ValueofDB:tblBuyInStock_lastUpdateTime,0,@ValueofDB:tblBuyInStock_SCompanyID)</sql>
		</exec>
		<!--查询在价格管理表中存在的商品，并且修改其最近进价，进价折扣-->
		<exec condition="'@SqlReturn:CPID'!='null'">
			<sql>update tblCustomerPriceDet set BuyPrice=a.Price,UnitPrice=a.UnitPrice,InDiscount=case when (InDiscount!=100 and @MEM:InDiscountTracke!='true') then InDiscount else a.Discount end from(select b.id as CDetID,(case @MEM:InPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,isnull(b.UnitPrice,a.Price) as UnitPrice,(case when @MEM:InDiscountTracke='true' then Discount else 100 end) as Discount from tblBuyInStockDet a,tblCustomerPriceDet b where a.f_ref=@ValueofDB:tblBuyInStock_id and b.f_ref=@SqlReturn:CPID and a.goodsCode=b.goodsCode and a.price&gt;0)a where tblCustomerPriceDet.id=a.CDetID</sql>
		</exec>
		<!--查询在价格管理表中不存在的商品，并且插入最近进价，进价折扣-->
		<exec condition="true">
			<sql>insert into tblCustomerPriceDet(id,f_ref,GoodsCode,BuyPrice,SecQty,BaseQty,InDiscount,SCompanyID)select m.sdid,m.CID,m.GoodsCode,m.Price,m.SecQty,m.BaseQty,m.Discount,m.CSID from(select substring(replace(newid(),'-',''),1,30) as sdid,a.GoodsCode as GoodsCode,(case @MEM:InPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,isnull(a.SecUnit,'') as SecUnit,a.SecQty,a.BaseQty,a.UnitPrice as UnitPrice,(case @SqlReturn:CPID when 'null' then @SqlReturn:CustomerPriceId else @SqlReturn:CPID end) as CID,@ValueofDB:tblBuyInStock_SCompanyID as CSID,(case when @MEM:InDiscountTracke='true' then Discount else 100 end) as Discount from tblBuyInStockDet a where a.f_ref=@ValueofDB:tblBuyInStock_id and a.price&gt;0 and (select count(0) from tblCustomerPriceDet b where b.f_ref=(case @SqlReturn:CPID when 'null' then @SqlReturn:CustomerPriceId else @SqlReturn:CPID end) and a.goodsCode=b.goodsCode)=0 and a.detOrderNo=(select top 1 detOrderNo from tblBuyInStockDet b where b.f_ref=a.f_ref and a.GoodsCode=b.GoodsCode))m</sql>
		</exec>		
	</sql>
</define>
<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=========-->
<define name="tblBuyInStock_Add_PriceControl_Validate">
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblBuyInStockDet a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='Buy' and UserID=@ValueofDB:tblBuyInStock_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblBuyInStock_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>                  
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>                  
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>                  
		</exec>
	</sql>
</define>
<!--==============引用采购订单的控制判断=================-->
<define name="tblBuyInStock_Add_QuoteOrder_Validate">
	<sql type="condition"><!--判断采购退货的单据日期在引用采购入库单前，给出错误提示-->
		<condition><select>select a.BillNo,billDate as BuyInDate from tblBuyOrder a,tblBuyInStockDet b where b.f_ref=@ValueofDB:tblBuyInStock_id and b.BuyOrderID=a.id and a.BillDate&gt;@ValueofDB:tblBuyInStock_BillDate</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.QuoteDate.error,@SqlReturn:BillNo,@SqlReturn:BuyInDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--订单供应商不同，给出错误提示-->
		<condition><select>select a.BillNo,c.ComFullName from tblBuyOrder a,tblBuyInStockDet b,tblCompany c where b.f_ref=@ValueofDB:tblBuyInStock_id and b.BuyOrderID=a.id and a.CompanyCode=c.classCode and a.CompanyCode!=@ValueofDB:tblBuyInStock_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.providerQuote.error,@SqlReturn:BillNo,@SqlReturn:ComFullName</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--询价单供应商不同，给出错误提示-->
		<condition><select>select a.BillNo,c.ComFullName from tblBuyAskPrice a,tblBuyInStockDet b,tblCompany c where b.f_ref=@ValueofDB:tblBuyInStock_id and b.BuyAskPriceID=a.id and a.CompanyCode=c.classCode and a.CompanyCode!=@ValueofDB:tblBuyInStock_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.providerQuote.error,@SqlReturn:BillNo,@SqlReturn:ComFullName</error>                  
		</exec>
	</sql>
</define>
<!--===========启用了多账户，进行多账户的判断提示=========-->
<define name="tblBuyInStock_Add_ManyAccount_Validate">
	<!--选择了付款账户没有输入付款金额，或者输入付款金额没有选择付款账户-->
	<sql type="condition">
		<condition><select>select 'exisAccErr' as exisAccErr from tblBuyPayAccount where tblBuyPayAccount.f_ref=@ValueofDB:tblBuyInStock_id and (len(isnull(tblBuyPayAccount.Account,''))&gt;0 and isnull(tblBuyPayAccount.Amount,0)=0)</select></condition>
		<exec condition="'@SqlReturn:exisAccErr'!='null'">
			<error>common.AccountAmt.input.error</error>                  
		</exec>
	</sql>
	<!--选择了重复的付款账户，给出错误提示-->
	<sql type="condition">
		<condition><select>select 'sameAcc' as sameAcc from tblBuyPayAccount where f_ref=@ValueofDB:tblBuyInStock_id group by Account having count(Account)&gt;1</select></condition>
		<exec condition="'@SqlReturn:sameAcc'=='sameAcc'">
			<error>tblPay.payAccount.same.error</error>                  
		</exec>
	</sql>
</define>

<!--===========启用了“控制超订单入库”，需判断是否有超出订单入库=========-->
<define name="tblBuyInStock_Add_OverOrderIn_Validate">
	<sql type="condition">
		<condition> 
			<!--查询此用户是否有权限超订单入库-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowMoreOrderIn' and hasRight=1</select>
			<!--查询是否有超订单入库的商品-->
			<select>select l.BillNo,k.GoodsFullName,dbo.throwZero((select sum(NotInQty) from tblBuyOrderDet b where b.f_ref=a.BuyOrderID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO)) as NotInQty from tblBuyInStockDet a,tblGoods k,tblBuyOrder l where f_ref=@ValueofDB:tblBuyInStock_id and LEN(BuyOrderID)&gt;0 and a.BuyOrderID=l.id and a.GoodsCode=k.classCode group by BuyOrderID,l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,k.GoodsFullName having SUM(Qty)&gt;(select sum(NotInQty) from tblBuyOrderDet b where b.f_ref=a.BuyOrderID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO)</select>
		</condition>
		<!--查询出有超订单入库的商品，并且此用户没有权限超订单入库，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
			<error>tblBuyInStock.add.GoodsQty.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName,@SqlReturn:NotInQty</error>                  
		</exec>
		<!--查询出有超订单入库的商品，但此用户有权限超订单入库或者是系统管理员，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblBuyInStock_Add_AccBefore" noDefine="">tblBuyInStock.add.GoodsQty.confirm,@SqlReturn:BillNo,@SqlReturn:GoodsFullName,@SqlReturn:NotInQty</confirm>
		</exec>
	</sql>
</define>

<define name="tblBuyInStock_Add_One">		
	<sql type="condition">
		<exec condition="'@MEM:InPriceTrack'!='PriceNo'||'@MEM:InDiscountTracke'=='true'"><!--如果启用了价格跟踪，将单价插入到价格管理表中-->	
			<sql type="define">tblBuyInStock_Add_PriceTracking</sql>
		</exec>
		
		<!--如果启用审核流，则过账时更新分仓库存-未审核字段-->
		<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillType=tblBuyInStock,@InstoreQty=-1*tblBuyInStockDet.Qty,@OutstoreQty=0,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--如果启用审核流，删除已审核完毕的序列号出入明细-->
		<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
		<!--启用系统配置“已经入库过的序列号，不能再次采购入库”，判断当前序列号是否已经入库-->
		<exec condition="'@MEM:seqCannotAgainBuy'=='true'">
			<sql type="procedure">{call proc_HasBuyInStockSeq(@ValueofDB:id,seqCode,seqVal)}</sql>
		</exec>
		<exec condition="&quot;@ProcReturn:seqVal&quot;!=&quot;&quot;">
			<error>seq.validate.hasInstore,@ProcReturn:seqVal</error>
		</exec>
	</sql>
	<sql type="condition">
	<!--更新入库单明细中的未付款数量为订单数量，付款数量为0-->
	<exec condition="true"><sql>update tblBuyInStockDet set NotPayQty=Qty,PayQty=0 where f_ref=@ValueofDB:tblBuyInStock_id</sql></exec>
	</sql>

	
	<!--=====================更新出入库明细===============-->
	<sql type="condition">		
		<!--分摊订单的预付订金，且回填订单的待付款-->
		<exec condition="true">
			<sql type="procedure">{call proc_BuyInPayAmort(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		<!--插入出入库明细,如果是增值税发票，用折后单价，折后金额影响出入库，否则用含税单价，含税金额影响出入库-->
		<exec condition="@ValueofDB:tblBuyInStock_InVoiceType!=2"><!--非增值税发票-->	
			<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyInStock_Period,@PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth,@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillID=@ValueofDB:tblBuyInStock_id,@BillType=tblBuyInStock,@BillDate=@ValueofDB:tblBuyInStock_BillDate,@BillNo=@ValueofDB:tblBuyInStock_BillNo,@InstoreQty=tblBuyInStockDet.Qty,@InstorePrice=(tblBuyInStockDet.TaxAmount+tblBuyInStockDet.freightAmount)/tblBuyInStockDet.Qty,@InstoreAmount=tblBuyInStockDet.TaxAmount+tblBuyInStockDet.freightAmount,@createBy=@ValueofDB:tblBuyInStock_createBy,@lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy,@createTime=@ValueofDB:tblBuyInStock_finishTime,@lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID,@MRemark=@ValueofDB:tblBuyInStock_Remark,@DRemark=tblBuyInStockDet.Remark,@SourceID=tblBuyInStockDet.id,@CompanyCode=@ValueofDB:tblBuyInStock_CompanyCode,@EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode,@SalesPrice=tblBuyInStockDet.TaxPrice,@SalesAmount=tblBuyInStockDet.TaxAmount,@SalesQty=tblBuyInStockDet.Qty,@Amount=tblBuyInStockDet.DisAmount,@Price=tblBuyInStockDet.DisPrice,@DiscountAmount=@ValueofDB:tblBuyInStock_DiscountAmount,@TrackNo=tblBuyInStockDet.TrackNo,@PresentSampleType=tblBuyInStockDet.PresentSampleType,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<exec condition="@ValueofDB:tblBuyInStock_InVoiceType==2"><!--增值税发票-->
			<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyInStock_Period,@PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth,@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillID=@ValueofDB:tblBuyInStock_id,@BillType=tblBuyInStock,@BillDate=@ValueofDB:tblBuyInStock_BillDate,@BillNo=@ValueofDB:tblBuyInStock_BillNo,@InstoreQty=tblBuyInStockDet.Qty,@InstorePrice=(tblBuyInStockDet.DisBackAmt+tblBuyInStockDet.freightAmount)/tblBuyInStockDet.Qty,@InstoreAmount=tblBuyInStockDet.DisBackAmt+tblBuyInStockDet.freightAmount,@createBy=@ValueofDB:tblBuyInStock_createBy,@lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy,@createTime=@ValueofDB:tblBuyInStock_finishTime,@lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID,@MRemark=@ValueofDB:tblBuyInStock_Remark,@DRemark=tblBuyInStockDet.Remark,@SourceID=tblBuyInStockDet.id,@CompanyCode=@ValueofDB:tblBuyInStock_CompanyCode,@EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode,@SalesPrice=tblBuyInStockDet.TaxPrice,@SalesAmount=tblBuyInStockDet.TaxAmount,@SalesQty=tblBuyInStockDet.Qty,@Amount=tblBuyInStockDet.DisBackAmt,@Price=tblBuyInStockDet.DisPrice,@DiscountAmount=@ValueofDB:tblBuyInStock_DiscountAmount,@TrackNo=tblBuyInStockDet.TrackNo,@PresentSampleType=tblBuyInStockDet.PresentSampleType,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--如果启用了序列号，判断是否插入了重复的序列号-->
		<exec condition="true">
			<sql type="define">validateSameSeq</sql>
		</exec>
		<!--只有修改，才需要判断负库存-->
		<exec condition="'@Sess:BillOper' == 'update'">	
			<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
		</exec>
	</sql>
	<!--=====================以上代码：更新虚拟库存及出入库明细===============-->

	<!--=============根据不同情况生成凭证信息，并影响往来，科目余额==============-->
	<sql type="condition">
		<condition><select>select (cast(@ValueofDB:tblBuyInStock_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblBuyInStock_PayAmount as numeric(18,8))) as RNeedPayAmt,(cast(@ValueofDB:tblBuyInStock_CurTotalAmount as numeric(18,8))-cast(@ValueofDB:tblBuyInStock_CurAlrPayAmt as numeric(18,8))) as CRNeedPayAmt,cast(@ValueofDB:tblBuyInStock_freightAmount as numeric(18,8))*cast(@ValueofDB:tblBuyInStock_CurrencyRate as numeric(18,8)) as freightAmountCur</select></condition>
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblBuyInStock</sql></exec>    
		<!--如果商品有金额，插入应付款贷的往来明细（1应付 2应收 3预付 4预收）-->
		<exec condition="@ValueofDB:tblBuyInStock_TotalTaxAmount&gt;0">
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,1,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=@ValueofDB:tblBuyInStock_TotalTaxAmount@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=@ValueofDB:tblBuyInStock_CurTotalAmount@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblBuyInStock_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblBuyInStock_Remark,retCode,retVal)}</sql>
		</exec>
		<!--如果商品有金额并且待付金额小于0， 插入应付借的往来明细 借金额=单据金额-->
		<exec condition="@SqlReturn:RNeedPayAmt&lt;0 &amp;&amp; @ValueofDB:tblBuyInStock_TotalTaxAmount&gt;0 &amp;&amp; '@MEM:prerecvpaymarktoneedrecvpay'=='false'">
			<sql type="procedure">{call proc_insertComIni(3@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,1,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyInStock_TotalTaxAmount@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblBuyInStock_CurTotalAmount@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=0,retCode,retVal)}</sql>
		</exec>
		<!--未启用预收预付记应收应付,待付金额小于于零时 插入预付借(预付的部分金额)的往来明细-->
		<exec condition="@SqlReturn:RNeedPayAmt&lt;0 &amp;&amp; '@MEM:prerecvpaymarktoneedrecvpay'=='false'">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,3,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PrePayTotalDebit=ABS(@SqlReturn:RNeedPayAmt)@ParamNum:@SPFieldLink:PrePayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=ABS(@SqlReturn:CRNeedPayAmt)@ParamNum:@SPFieldLink:FcPrePayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=0,retCode,retVal)}</sql>
		</exec>
		<!--已启用预收预付记应收应付,待付金额小于于零时 插入应付借(预付的部分金额)的往来明细-->
		<exec condition="@SqlReturn:RNeedPayAmt&lt;0 &amp;&amp; '@MEM:prerecvpaymarktoneedrecvpay'=='true'">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,1,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyInStock_PayAmount@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=ABS(@SqlReturn:CRNeedPayAmt)@ParamNum:@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=0,retCode,retVal)}</sql>
		</exec>
		<!--当付款金额大于0,并且待付金额大于等于0， 插入应付借的往来明细 借金额=付款金额-->
		<exec condition="@ValueofDB:tblBuyInStock_PayAmount&gt;0&amp;&amp;@SqlReturn:RNeedPayAmt&gt;=0">
			<sql type="procedure">{call proc_insertComIni(3@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,1,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyInStock_PayAmount@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblBuyInStock_CurAlrPayAmt@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=0,retCode,retVal)}</sql>
		</exec>
		<!--如果运费科目是应付账款，则将运费金额插入到往来明细中-->
		<exec condition="'@ValueofDB:tblBuyInStock_freightAcc'.indexOf('2202')&gt;=0">
			<sql type="procedure">{call proc_insertComIni(4@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,1,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=@ValueofDB:tblBuyInStock_freightAmount@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=@SqlReturn:freightAmountCur@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblBuyInStock_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblBuyInStock_Remark,retCode,retVal)}</sql>
		</exec>
		<!--如果运费科目是预付账款，则将运费金额插入到往来明细中-->
		<exec condition="'@ValueofDB:tblBuyInStock_freightAcc'.indexOf('1123')&gt;=0">
			<sql type="procedure">{call proc_insertComIni(4@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_CompanyCode,3,@ValueofDB:tblBuyInStock_BillDate,Period=@ValueofDB:tblBuyInStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyInStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyInStock_PeriodMonth@SPFieldLink:PrePayTotalDebit=@ValueofDB:tblBuyInStock_freightAmount@ParamNum:@SPFieldLink:PrePayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyInStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyInStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyInStock_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=@SqlReturn:freightAmountCur@ParamNum:@SPFieldLink:FcPrePayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyInStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyInStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyInStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyInStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyInStock_SCompanyID@SPFieldLink:BillType=tblBuyInStock@SPFieldLink:BillNo=@ValueofDB:tblBuyInStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyInStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyInStock_DepartmentCode@SPFieldLink:DiscountAmount=0,retCode,retVal)}</sql>
		</exec>
	</sql>
	<!--=============以上代码：根据不同情况生成凭证信息，并影响往来,科目余额==============-->

	<!--============付款金额大于零，自动生成采购付款单==============-->
	<sql type="condition">
		<condition><select>select (cast(@ValueofDB:tblBuyInStock_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblBuyInStock_PayAmount as numeric(18,8))) as RNeedPayAmt,(case when (cast(@ValueofDB:tblBuyInStock_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblBuyInStock_PayAmount as numeric(18,8)))&gt;=0.0 then 'Pay' else 'PrePay' end) as rePayType,(cast(@ValueofDB:tblBuyInStock_PayAmount as numeric(18,8))+cast(@ValueofDB:tblBuyInStock_ProceDureExp as numeric(18,8))) as factAmt </select></condition>
		<exec condition="@ValueofDB:tblBuyInStock_PayAmount&gt;0">
			<sql>insert into tblPay (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,Paytype,PaytypeID,SettleAmt,FactOutcome,AccAmt,Currency,CurrencyRate,CurrencyAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_BillDate,@CODE:[tblPay_BillNo],@ValueofDB:tblBuyInStock_CompanyCode,@ValueofDB:tblBuyInStock_DepartmentCode,@ValueofDB:tblBuyInStock_EmployeeID,1,(case @MEM:prerecvpaymarktoneedrecvpay when 'true' then (case @SqlReturn:rePayType when 'PrePay' then 'Pay' else @SqlReturn:rePayType end) else @SqlReturn:rePayType end),@ValueofDB:tblBuyInStock_PayAmount,@SqlReturn:factAmt,@SqlReturn:factAmt,@ValueofDB:tblBuyInStock_Currency,@ValueofDB:tblBuyInStock_CurrencyRate,@ValueofDB:tblBuyInStock_CurAlrPayAmt,@ValueofDB:tblBuyInStock_PeriodYear,@ValueofDB:tblBuyInStock_PeriodMonth,@ValueofDB:tblBuyInStock_Period,@ValueofDB:tblBuyInStock_createBy,@ValueofDB:tblBuyInStock_createTime,@ValueofDB:tblBuyInStock_lastUpdateBy,@ValueofDB:tblBuyInStock_lastUpdateTime,@ValueofDB:tblBuyInStock_SCompanyID,1,'finish','-1','',@ValueofDB:tblBuyInStock_TrackNo)</sql>
			<sql>insert into tblPayDet (id,f_ref,BillAmt,Remark,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,BuyOrderNo,BuyOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,PayBillType) values ('1'+@ValueofDB:tblBuyInStock_id,'0'+@ValueofDB:tblBuyInStock_id,@ValueofDB:tblBuyInStock_TotalTaxAmount,'',@ValueofDB:tblBuyInStock_CurTotalAmount,(case when cast(@SqlReturn:RNeedPayAmt as numeric(18,8))&gt;=0.0 then @ValueofDB:tblBuyInStock_PayAmount else @ValueofDB:tblBuyInStock_TotalTaxAmount end),(case when cast(@SqlReturn:RNeedPayAmt as numeric(18,8))&gt;=0.0 then @ValueofDB:tblBuyInStock_CurAlrPayAmt else @ValueofDB:tblBuyInStock_CurTotalAmount end),@ValueofDB:tblBuyInStock_Currency,@ValueofDB:tblBuyInStock_CurrencyRate,0,@ValueofDB:tblBuyInStock_TotalTaxAmount,0,@ValueofDB:tblBuyInStock_CurTotalAmount,@ValueofDB:tblBuyInStock_BillNo,@ValueofDB:tblBuyInStock_BuyOrderNo,@ValueofDB:tblBuyInStock_BuyOrderID,0,@ValueofDB:tblBuyInStock_SCompanyID,0,@ValueofDB:tblBuyInStock_id,'tblBuyInStock')</sql>
		</exec>
		<!--如果启用了多账户，向多账户明细表中插入数据-->
		<exec condition="@ValueofDB:tblBuyInStock_PayAmount&gt;0">
			<sql type="procedure">{call proc_insertByDet(@ValueofDB:tblBuyInStock_id,tblBuyPayAccount,tblPayAccountDet,id=tblBuyPayAccount_id@SPFieldLink:f_ref=0@ValueofDB:tblBuyInStock_id@SPFieldLink:Paytype=tblBuyPayAccount_Paytype@SPFieldLink:Amount=tblBuyPayAccount_Amount@ParamNum:@SPFieldLink:ExeBalFcAmt=tblBuyPayAccount_ExeBalFcAmt@ParamNum:@SPFieldLink:Account=tblBuyPayAccount_Account@SPFieldLink:SCompanyID=tblBuyPayAccount_SCompanyID@SPFieldLink:Remark=tblBuyPayAccount_Remark,retCode,retVal)}</sql>
		</exec>
		<!--自动生成的单据需更新单据编号连续-->
		<exec condition="'@MEM:BillNoSequence'=='true'">  
			<sql>update tblCodeGenerate set curValue=curValue+1 where code='BP'</sql>
		</exec>	
		<!--向追踪单号表中插入数据-->
		<exec condition="'@MEM:TrackNo'=='true'">  
			<sql>insert into tblTrackBill(id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID) select  substring(replace(newid(),'-',''),1,30),id,BillNo,'tblPay',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblPay where id='0'+@ValueofDB:tblBuyInStock_id</sql>
		</exec>
		<!--引用出库单，回填出库明细的出库数量，未出库数量-->
		<exec condition="true">  
			<sql type="procedure">{call proc_BuyInUpdateSales(@ValueofDB:tblBuyInStock_id,add,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>
<!--============以上代码：付款金额大于零，自动生成采购付款单==============-->

<!--===========产生凭证操作=========-->
<define name="tblBuyInStock_Add_CreateAcc">
	<sql type="condition">
		<exec condition="'@ValueofDB:InVoiceType'=='2'">
			<sql type="certificate">tblBuyInStock_zenzhi </sql>                  
		</exec>
	</sql>
</define>
<!--================点击删除，修改时调用==========-->
<define name="tblBuyInStock_Delete">
<sql type="condition">
	<exec condition="true"><!--更新采购订单的入库数量，未入库数量，状态等信息-->
		<sql type="procedure">{call proc_BuyUpdateOrderQty(@ValueofDB:tblBuyInStock_id,delete,retCode,retVal)}</sql>
	</exec>
	<!--如果启用审核流，则删除单据时更新分仓库存-未审核字段-->
	<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillType=tblBuyInStock,@InstoreQty=-1*tblBuyInStockDet.Qty,@OutstoreQty=0,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
			<!--删除和修改操作时，更新序列号出入明细-->
	<exec condition="'@Sess:BillOper' =='delete'||'@Sess:BillOper' =='update'">
		<sql>delete from tblSeqAuditing where BillID=@ValueofDB:tblBuyInStock_id</sql>
	</exec>		
	<!--启用审核后能修改或者删除的说明此单没有审核，不必调用此define. 不启用审核流，执行所有控制及过账操作，启用审核，点击反审核时执行此操作-->
	<exec condition="'@MEM:tblBuyInStock_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
		<sql type="define">tblBuyInStock_Delete_One</sql>
	</exec>

</sql>
</define>

<define name="tblBuyInStock_Delete_One">
<!--=============查询是否存在关联表，如果有提出错误提示===========-->
<sql type="condition">
	<!--如果启用审核流，反审核时，时更新分序列号出入未审核完毕的序列号明细，-->
		<exec condition="&quot;@MEM:tblBuyInStock_IsStatart&quot;!= &quot;0&quot;&amp;&amp;&quot;@Sess:BillOper&quot;==&quot;returnAuditing&quot;">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
</sql>	
<sql type="condition"><!--判断是否存在对应采购退货单-->
	<condition><select>select BillNO as BuyOutNo from tblBuyOutStock a,tblBuyOutStockDet b where a.id=b.f_ref and b.BuyInStockID=@ValueofDB:tblBuyInStock_id and a.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:BuyOutNo'!='null'">	
		<error>BuyInStock.delete.existBuyOut.error,@SqlReturn:BuyOutNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应销售出库单-->
	<condition><select>select BillNO as SalesOutNo from tblSalesOutStock where BuyInID=@ValueofDB:tblBuyInStock_id</select></condition>
	<exec condition="'@SqlReturn:SalesOutNo'!='null'">	
		<error>BuyInStock.delete.existSalesOut.error,@SqlReturn:SalesOutNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在不是自动产生的采购付款单-->
	<condition><select>select BillNo as PayNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=@ValueofDB:tblBuyInStock_id and tblPay.AutoBillMarker=0 and tblPay.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:PayNo'!='null'">	 					
		<error>PayBill.BillNo.error,@SqlReturn:PayNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断自动产生的付款单是否存在付款退款-->
	<condition><select>select BillNo as PayReNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=(select a.id from tblPay a,tblPayDet b where a.id=b.f_ref and RefbillID=@ValueofDB:tblBuyInStock_id and a.AutoBillMarker=1) and tblPay.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:PayReNo'!='null'">	 					
		 <error>PayDel.receiveNo.error,@SqlReturn:PayReNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应采购换货单-->
	<condition><select>select BillNo as BuyReplaceNo from tblBuyReplace where BuyInStockID=@ValueofDB:tblBuyInStock_id</select></condition>
	<exec condition="'@SqlReturn:BuyReplaceNo'!='null'">	
		<error>BuyInStock.delete.existReplace.error,@SqlReturn:BuyReplaceNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应采购开票管理-->
	<condition><select>select  BillNo as InvoiceNo from tblBuyInfoDet,tblBuyInvoiceInfo where tblBuyInvoiceInfo.id=tblBuyInfoDet.f_ref and refbillID=@ValueofDB:tblBuyInStock_id and tblBuyInvoiceInfo.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:InvoiceNo'!='null'">	
		 <error>BuyInvoice.ReBillNo.error,@SqlReturn:InvoiceNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应应付转应收-->
	<condition><select>select tblTransferSale2.BillNo as TFS2No from tblTransferSale2 where RefBillNo=(select BillNo from tblBuyInStock where id=@ValueofDB:tblBuyInStock_id) and workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:TFS2No'!='null'">	
		<error>SalesInfoDet.ReTFS2No.error,@SqlReturn:TFS2No</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应预付转应付单-->
	<condition><select>select tblTransferSale3.BillNo as TFS3No from tblTransferSaleDet3,tblTransferSale3 where tblTransferSale3.id=tblTransferSaleDet3.f_ref and refbillID=@ValueofDB:tblBuyInStock_id and tblTransferSale3.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:TFS3No'!='null'">	
		<error>BuyInvoice.ReTFS3No.error,@SqlReturn:TFS3No</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应应收转应付单-->
	<condition><select>select tblTransferSale4.BillNo as TFS4No from tblTransferSaleDet4,tblTransferSale4 where tblTransferSale4.id=tblTransferSaleDet4.f_ref and refbillID=(select BillNo from tblBuyInStock where id=@ValueofDB:tblBuyInStock_id) and tblTransferSale4.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:TFS4No'!='null'">	
		<error>BuyInvoice.ReTFS4No.error,@SqlReturn:TFS4No</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断是否存在对应应付调账单-->
	<condition><select>select  BillNo as AdjustNo from tblPayAdjustdet,tblPayAdjust where tblPayAdjust.id=tblPayAdjustdet.f_ref and tblPayAdjustdet.RefbillID=@ValueofDB:tblBuyInStock_id and tblPayAdjust.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:AdjustNo'!='null'">	
		<error>BuyInStock.delete.existPayAdjust.error,@SqlReturn:AdjustNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
	<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblBuyInStock_id and  workFlowNodeName='finish'</select></condition>
	<exec condition="'@SqlReturn:OrderNo'!='null'">	
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
	</exec>
</sql>
<sql type="condition">
	<condition><select>select BuyOrderID,StockCode,NeedPayAmt,PayAmount,CurAlrPayAmt from tblBuyInStock where id=@ValueofDB:tblBuyInStock_id</select></condition>	
	<!--如果启用审核流，则过账时更新分仓库存+未审核字段-->
	<exec condition="'@MEM:tblBuyInStock_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyInStockDet.GoodsCode,@StockCode=tblBuyInStockDet.StockCode,@BillType=tblBuyInStock,@InstoreQty=tblBuyInStockDet.Qty,@OutstoreQty=0,@from=tblBuyInStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<exec condition="true"><!--删除出入库明细记录-->
		<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblBuyInStock_id,tblBuyInStock,1,retCode,retVal)}</sql>
	</exec>
	<exec condition="'@Sess:BillOper' !='update'">	
		<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
	</exec>	
	<exec condition="true"><!--分摊订单的预付订金，且回填订单的待付款-->
		<sql type="procedure">{call proc_BuyInPayAmort(@ValueofDB:tblBuyInStock_id,delete,retCode,retVal)}</sql>
	</exec>
	<exec condition="true">	<!--根据是否启用 预收预付记应收应付,决定要删除的往来明细的类型（1应付 2应收 3预付 4预收）-->
		<sql type="procedure">{call proc_iterateExeProc(select id as IniId@SPFieldLink:case when isnull(PayTotalDebit@RepComma:0)!=0 or isnull(PayTotalLend@RepComma:0)!=0 then 1 when isnull(PayTotalDebit@RepComma:0)!=0 or isnull(PayTotalLend@RepComma:0)!=0 then (case when '@MEM:prerecvpaymarktoneedrecvpay'='true' then 1 else 3 end) end as ComType from tblCompanyIni where relationDocID='@ValueofDB:tblBuyInStock_id',proc_deleteComIni,@IniId@ParamLink:@ComType,retCode,retVal)}</sql>
	</exec>
	<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--“启用标准财务”为否时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblBuyInStock_id,retCode,retVal)}</sql>
	</exec>
	<exec condition="'@Sess:BillOper' =='update'"><!--如果是修改操作，将此单据是否生成凭证的标示改为否-->
		<sql>update tblBuyInStock set CertificateNo='' where id=@ValueofDB:tblBuyInStock_id</sql>
	</exec>
	<!--付款金额大于0,删除付款单及明细信息-->
	<exec condition="@SqlReturn:PayAmount&gt;0">
		<sql>delete from tblPayDet where f_ref='0'+@ValueofDB:tblBuyInStock_id</sql>
		<sql>delete from tblPayAccountDet where f_ref='0'+@ValueofDB:tblBuyInStock_id</sql>
		<sql>delete from tblPay where id='0'+@ValueofDB:tblBuyInStock_id</sql>
		<sql>delete from tblTrackBill where RelationID='0'+@ValueofDB:tblBuyInStock_id</sql>
	</exec>	
</sql>
<!--引用出库单，回填出库明细的出库数量，未出库数量-->
<sql type="condition">
  <exec condition="true">  
			<sql type="procedure">{call proc_BuyInUpdateSales(@ValueofDB:tblBuyInStock_id,delete,retCode,retVal)}</sql>
		</exec>
</sql>

</define>
<!--=========手工删除凭证============-->
<define name="tblBuyInStock_deleteAcc_hand">
	<sql type="condition"><!--如果此单据没有生成凭证，则不用删除凭证-->
		<condition><select>select BillNo from tblBuyInStock where id=@ValueofDB:tblBuyInStock_id and CertificateNo=''</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">	
			<error>common.NotCreateAcc.Del.Error,@SqlReturn:BillNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--当前单据凭证所在期间已经月结，则不能删除此凭证-->
		<condition><select>select c.BillNo,b.statusId,a.CredTypeID,a.OrderNo from tblAccMain a,tblAccPeriod b,tblBuyInStock c where a.RefBillID=@ValueofDB:tblBuyInStock_id and c.id=@ValueofDB:tblBuyInStock_id and a.CredYear=b.AccYear and a.Period=b.AccPeriod</select></condition>
		<exec condition="'@SqlReturn:statusId'!='null'&amp;&amp;'@SqlReturn:statusId'=='2'">	
			<error>common.AccPeriodSettle.error,@SqlReturn:BillNo,@SqlReturn:CredTypeID,@SqlReturn:OrderNo</error>                  
		</exec>
	</sql>
	<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,delete,@ValueofDB:tblBuyInStock_id,retCode,retVal)}</sql>
	<sql>update tblBuyInStock set CertificateNo='' where id=@ValueofDB:tblBuyInStock_id</sql>
</define>
<!--==========================================以上代码，采购入库单==========================================--> 

<!--==========================================采购退货单==================================================--> 	                   
<define name="tblBuyOutStock_Add">
	<!--================控制类操作===================-->
	<sql type="condition">
		<!--输入了收款金额，没有选择结算账户时给出提示-->
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount!=0 &amp;&amp; '@ValueofDB:tblBuyOutStock_Account'.length==0 "> 
			<error>请选择结算账户</error>                  
		</exec>	
		<!--选择了结算账户，输入收款金额小于等于0时给出提示-->
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount&lt;=0 &amp;&amp; '@ValueofDB:tblBuyOutStock_Account'.length &gt; 0 "> 
			<error>请输入大于0的收款金额</error>                  
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblBuyOutStock_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyOutStock_Tax!=0)||@ValueofDB:tblBuyOutStock_Tax&lt;0">		
			<error>common.isReceipt.existsTax.error</error>           
		</exec>
	</sql>	
	<sql type="condition">		
		<exec condition="'@ValueofDB:tblBuyOutStock_BuyInID'.length&gt;0"><!--如果通过引用按钮引用，将采购入库单的ID设置到明细表-->
			<sql>update tblBuyOutStockDet set BuyOrderID=@ValueofDB:tblBuyOutStock_BuyOrderID,BuyInStockID=@ValueofDB:tblBuyOutStock_BuyInID where f_ref=@ValueofDB:tblBuyOutStock_id and len(isnull(BuyInStockID,''))=0</sql>	
		</exec>
		<exec condition="true"><!--如果引用采购入库，做如下控制-->
			<sql type="define">tblBuyOutStock_QuoteBuyIn_validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择的商品的申请数不能小于0-->
		<condition><select>select tblGoods.GoodsFullName as GoodsAQ from tblBuyOutStockDet,tblGoods where f_ref=@ValueofDB:tblBuyOutStockDet_id and isnull(tblBuyOutStockDet.ApplyQty,0)&lt;0 and tblGoods.classCode=tblBuyOutStockDet.GoodsCode</select></condition>
		<exec condition="'@SqlReturn:GoodsAQ' != 'null'">			
			<error>common.AQty.negative.error,@SqlReturn:GoodsAQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择的商品的数量必须大于0-->
		<condition><select>select tblGoods.GoodsFullName as GoodsQ from tblBuyOutStockDet,tblGoods where isnull(tblBuyOutStockDet.Qty,0)&lt;=0 and tblGoods.classCode=tblBuyOutStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyOutStockDet_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--判断是否存单价小于0的商品-->
		<condition><select>select tblGoods.GoodsFullName as GoodsP from tblBuyOutStockDet,tblGoods where isnull(tblBuyOutStockDet.Price,0)&lt;0 and tblGoods.classCode=tblBuyOutStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyOutStockDet_id</select></condition>
		<exec condition="'@SqlReturn:GoodsP' != 'null'">			
			<error>common.price.lessZero.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--非赠品，样品单价小于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblBuyOutStockDet a,tblGoods b where (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and b.classcode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyOutStock_id and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--判断是否存在是赠品，样品但单价不等于0-->
		<condition><select>select tblGoods.GoodsFullName as GoodsSample from tblBuyOutStockDet,tblGoods where isnull(tblBuyOutStockDet.Price,0)!=0 and tblGoods.classCode=tblBuyOutStockDet.GoodsCode and f_ref=@ValueofDB:tblBuyOutStockDet_id and tblBuyOutStockDet.PresentSampleType in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>                   
		</exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblBuyOutStockDet left join tblgoods on tblGoods.classCode=tblBuyOutStockDet.GoodsCode where tblGoods.seqIsUsed=0 and len(isnull(tblBuyOutStockDet.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and tblBuyOutStockDet.f_ref=@ValueofDB:tblBuyOutStockDet_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>                  
	    </exec>
	</sql>
	<sql type="condition"><!--如果启用了其他配置：采购退货单条码复合，做如下控制-->
		<exec condition="'@MEM:BarcodecheckedBuyRetrun'=='true'">
			<sql type="define">tblBuyOutStock_Barcodechecked_validate</sql>
		</exec>
	</sql>
	<!--<sql type="condition">明细表的金额不等于数量*单价
		<condition><select>select b.GoodsNumber,b.GoodsFullName from tblBuyOutStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyOutStock_id and a.GoodsCode=b.classCode and Amount!=round(Qty*Price,@MEM:DigitsAmount)</select></condition>
		<exec condition="'@SqlReturn:GoodsNumber'!='null'">			
			<error>common.AmtPriceQty.NotEqual.error,@SqlReturn:GoodsNumber,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>-->
	<sql type="condition"><!--明细表的合计金额，和主表的总金额不相等时给出错误提示-->
		<condition><select>select dbo.getDigits('tblBuyOutStockDet','TaxAmount',sum(tblBuyOutStockDet.TaxAmount)) as SumDetAmt from tblBuyOutStockDet where  tblBuyOutStockDet.f_ref=@ValueofDB:tblBuyOutStock_id</select></condition>
		<exec condition="@SqlReturn:SumDetAmt!=@ValueofDB:tblBuyOutStock_TotalTaxAmount+@ValueofDB:tblBuyOutStock_DiscountAmount">			
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblBuyOutStock_TotalTaxAmount,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>
	
	<!--采购退货明细表未开票数=退货数，开票数=0-->
	<sql>update tblBuyOutStockDet set NotInvoiceQty=Qty,InvoiceQty=0 where f_ref=@ValueofDB:tblBuyOutStock_id</sql>
	<!--采购退货明细表未付款数量=退货数，已付款数=0-->
	<sql>update tblBuyOutStockDet set NotPayQty=Qty,PayQty=0 where f_ref=@ValueofDB:tblBuyOutStock_id</sql>
	<!--==================逻辑类操作======================-->
	<sql type="condition">
		<exec condition="'@MEM:ManyStockBuy'=='false'"><!--假如没有启用多仓库，用主表的仓库更新明细表-->
			<sql>update tblBuyOutStockDet set StockCode=@ValueofDB:tblBuyOutStock_StockCode where f_ref=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>	
		<exec condition="'@MEM:OutBillUseQtyCheck'=='true'"><!--更新仓库后判断出库数量不能大于可用库存-->
			<sql type="define">tblBuyOutStock_OutBillUseQty_validate</sql>
		</exec>
		<!--没有引用入库单时更新累计收款金额，待收款金额-->
		<exec condition="'@ValueofDB:tblBuyOutStock_BuyInID'.length==0">
			<sql>update tblBuyOutStock set NeedReceiveAmt=TotalTaxAmount-AccountAmount,AlreadyPayAmt=AccountAmount,CurNeedReceiveAmt=CurTotalAmount-CurAccountAmount,CurAlreadyPayAmt=CurAccountAmount,CertificateNo='' where id=@ValueofDB:tblBuyOutStock_id </sql>
		</exec>	
		<!--引用入库单时更新累计收款金额，待收款金额-->
		<exec condition="'@ValueofDB:tblBuyOutStock_BuyInID'.length&gt;0">
			<sql>update tblBuyOutStock set NeedReceiveAmt=(select (case when tblBuyOutStock.TotalTaxAmount-tblBuyOutStock.AccountAmount-NeedPayAmt&lt;=0 then 0 else tblBuyOutStock.TotalTaxAmount-tblBuyOutStock.AccountAmount-NeedPayAmt end) from tblBuyInStock where id=@ValueofDB:tblBuyOutStock_BuyInID),AlreadyPayAmt=AccountAmount,CurNeedReceiveAmt=(select (case when tblBuyOutStock.CurTotalAmount-tblBuyOutStock.CurAccountAmount-CurNeedPayAmt&lt;=0 then 0 else tblBuyOutStock.CurTotalAmount-tblBuyOutStock.CurAccountAmount-CurNeedPayAmt end) from tblBuyInStock where id=@ValueofDB:tblBuyOutStock_BuyInID),CurAlreadyPayAmt=CurAccountAmount,CertificateNo='' where id=@ValueofDB:tblBuyOutStock_id </sql>
		</exec>
	</sql>	
	<sql type="condition">
	    <exec condition="true"><!--更新主表与明细表 已开票金额与未开票金额 初始值-->
	    	<sql>update tblBuyOutStock set AfterChangeAmt=TotalTaxAmount, ChangeAmt=0 where id=@ValueofDB:tblBuyOutStock_id </sql>
        <sql>update tblBuyOutStockDet set AfterChangeAmt=TaxAmount, ChangeAmt=0 where tblBuyOutStockDet.f_ref=@ValueofDB:tblBuyOutStock_id</sql>
				<sql>update tblBuyOutStock set NoInvoiceAmount=AfterChangeAmt, InvoiceAmount=0 where id=@ValueofDB:tblBuyOutStock_id </sql>
        <sql>update tblBuyOutStockDet set NoInvoiceAmount=AfterChangeAmt, InvoiceAmount=0 where tblBuyOutStockDet.f_ref=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>	
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			  update tblBuyOutStockDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyOutStock a join tblBuyOutStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyOutStock_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyOutStockDet.id=a.id
			</sql>
			<sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			 update tblBuyOutStockDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyOutStock a join tblBuyOutStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyOutStock_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyOutStockDet.id=a.id
		   </sql>
		</exec>
	</sql>

	<!--=========以下代码：外币判断，暂不处理=============-->
	<sql type="condition">
		<condition>
			<select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblBuyOutStock_Account and SCompanyID=@ValueofDB:tblBuyOutStock_SCompanyID</select>
		</condition>
		<!--币种不为空，付款帐户不为空时，选择的付款帐户核算的币种跟所选的币种不一致时提示-->
		<exec condition="'@ValueofDB:tblBuyOutStock_Currency'.length != 0 &amp;&amp; '@ValueofDB:tblBuyOutStock_Account'.length != 0 
 &amp;&amp; !( '@ValueofDB:tblBuyOutStock_Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  )">
			<!--选择的付款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.SelectCurType.error</error>                  
		</exec>	 
		<!--币种为空，付款帐户不为空时，选择的付款帐户存在核算外币时提示-->
		<exec condition="'@ValueofDB:tblBuyOutStock_Currency'.length == 0 
&amp;&amp;  ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL') ">
			<!--选择的付款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.SelectCurType.error</error>                  
		</exec>	
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblBuyOutStock_Currency'.length == 0 &amp;&amp; @ValueofDB:tblBuyOutStock_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblBuyOutStock_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error>                  
		</exec>
	</sql>
	<!--=========以上代码：外币判断，暂不处理=============-->
	
	<sql type="condition">
		<exec condition="true"><!--更新入库单及订单数量-->
			<sql type="procedure">{call proc_BuyReturnUpdateBillQty(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyOutStockDet.GoodsCode,@StockCode=tblBuyOutStockDet.StockCode,@BillType=tblBuyOutStock,@InstoreQty=0,@OutstoreQty=tblBuyOutStockDet.Qty,@from=tblBuyOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>		
		<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>	
		<!--不启用审核流直接执行以下操作。如果启用审核流，点击审核按钮时执行以下操作-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' == '0'">
			<sql type="define">tblBuyOutStock_Add_One</sql>
		</exec>
	</sql>	
</define>
<!--===========出库数量不能大于可用库存===============-->
<define name="tblBuyOutStock_OutBillUseQty_validate">
	<sql type="condition">
		<condition><select>select isnull(c.GoodsFullName,'') as GoodsFullName,isnull(tblStock.StockFullName,'') as StockFullName,cast(case c.isCatalog when 0 then isnull(b.LastQty+b.inQtyNotAudit+b.SInQtyNotAudit-b.outQtyNotAudit-b.BOutQtyNotAudit,0) else -99999999 end - a.Qty as numeric(18,4)) as Qty from (select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblBuyOutStockDet where f_ref=@ValueofDB:tblBuyOutStock_id group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode)a left join tblStocks b on a.GoodsCode=b.GoodsCode and a.StockCode=b.StockCode and a.BatchNo=b.BatchNo and a.Hue=b.Hue and a.yearNO=b.yearNO and a.Inch=b.Inch and a.Availably=b.Availably and a.ProDate=b.ProDate left join tblStock on a.StockCode=tblStock.classCode left join tblGoods c on a.GoodsCode=c.classCode  where  a.Qty&gt;(case c.isCatalog when 0 then isnull(b.LastQty+b.inQtyNotAudit+b.SInQtyNotAudit-b.outQtyNotAudit-b.BOutQtyNotAudit,0) else -99999999 end)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName' != 'null'">			
			<error>common.VirtualStock.excess.error,@SqlReturn:GoodsFullName,@SqlReturn:Qty,@SqlReturn:StockFullName</error>       
		</exec>
	</sql>
</define>
<!--==============采购退货单引用采购入库单的判断=================-->
<define name="tblBuyOutStock_QuoteBuyIn_validate">
	<sql type="condition"><!--判断采购退货的单据日期在引用采购入库单前，给出错误提示-->
		<condition><select>select a.BillNo,billDate as BuyInDate from tblBuyInStock a,tblBuyOutStockDet b where b.f_ref=@ValueofDB:tblBuyOutStock_id and b.BuyInStockID=a.id and a.BillDate&gt;@ValueofDB:tblBuyOutStock_BillDate</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.QuoteDate.error,@SqlReturn:BillNo,@SqlReturn:BuyInDate</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--供应商不同，给出错误提示-->
		<condition><select>select a.BillNo,c.ComFullName from tblBuyInStock a,tblBuyOutStockDet b,tblCompany c where b.f_ref=@ValueofDB:tblBuyOutStock_id and b.BuyInStockID=a.id and a.CompanyCode=c.classCode and a.CompanyCode!=@ValueofDB:tblBuyOutStock_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.providerQuote.error,@SqlReturn:BillNo,@SqlReturn:ComFullName</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--发票类型不同，给出错误提示-->
		<condition><select>select a.BillNo from tblBuyInStock a,tblBuyOutStockDet b where b.f_ref=@ValueofDB:tblBuyOutStock_id and b.BuyInStockID=a.id and a.InVoiceType!=@ValueofDB:tblBuyOutStock_InVoiceType</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">						
			<error>common.InVoiceTypeQuote.error,@SqlReturn:BillNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--税率不同，给出错误提示-->
		<condition><select>select a.BillNo as BillNoT,dbo.getDigits('tblBuyOutStock','Tax',a.Tax )as QTax from tblBuyInStock a,tblBuyOutStockDet b where b.f_ref=@ValueofDB:tblBuyOutStock_id and b.BuyInStockID=a.id and a.Tax!=@ValueofDB:tblBuyOutStock_Tax</select></condition>
		<exec condition="'@SqlReturn:BillNoT'!='null'">						
			<error>common.TaxQuote.error,@SqlReturn:BillNoT,@SqlReturn:QTax</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货数量大于实际入库数量，给出错误提示-->
		<condition><select>select l.BillNo,k.GoodsFullName from tblBuyOutStockDet a,tblGoods k,tblBuyInStock l where f_ref=@ValueofDB:tblBuyOutStock_id and LEN(BuyInStockID)&gt;0 and a.BuyInStockID=l.id and a.GoodsCode=k.classCode group by BuyInStockID,l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,k.GoodsFullName
having SUM(Qty)&gt;(select sum(FactInQty) from tblBuyInStockDet b where b.f_ref=a.BuyInStockID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO and a.ProDate=b.ProDate and a.Availably=b.Availably)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName'!='null'">			
			<error>common.ReturnInQtyQuote.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>
</define>
<!--==============启用条码复合的判断===========================-->
<define name="tblBuyOutStock_Barcodechecked_validate">
	<sql type="condition">
		<condition><select>select b.GoodsFullName as CheckGoods from tblBuyOutStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyOutStock_id and a.goodsCode=b.classCode and b.BarCode!=a.CheckBarCode</select></condition>	    	
		<exec condition="'@SqlReturn:CheckGoods' != 'null'">					
			<error>CheckBarCode.diffent.error,@SqlReturn:CheckGoods</error>                  
		</exec>
	</sql>
</define>

<define name="tblBuyOutStock_Add_One">
	<!--==================影响库存============================-->
	<sql type="condition">
		<!--回填被引用的订单的退货数量-->
		<exec condition="true">
			<sql type="procedure">{call proc_ReturnBackOrder(@ValueofDB:id,add,tblBuyOutStock,retCode,retVal)}</sql>
		</exec>
		
		<!--如果启用审核流，则过账时更新分仓库存-未审核字段-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyOutStockDet.GoodsCode,@StockCode=tblBuyOutStockDet.StockCode,@BillType=tblBuyOutStock,@InstoreQty=0,@OutstoreQty=-1*tblBuyOutStockDet.Qty,@from=tblBuyOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		
		<!--如果启用审核流，删除已审核完毕的序列号出入明细-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
		
		<!--在出入库明细中插入出库的明细记录，此出库成本根据成本算法取值-->
		<exec condition="true">
			<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyOutStock_Period,@PeriodYear=@ValueofDB:tblBuyOutStock_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyOutStock_PeriodMonth,@GoodsCode=tblBuyOutStockDet.GoodsCode,@StockCode=tblBuyOutStockDet.StockCode,@BillID=@ValueofDB:tblBuyOutStock_id,@BillType=tblBuyOutStock,@BillDate=@ValueofDB:tblBuyOutStock_BillDate,@BillNo=@ValueofDB:tblBuyOutStock_BillNo,@OutstoreQty=tblBuyOutStockDet.Qty,@OutstorePrice=tblBuyOutStockDet.costPrice,@OutstoreAmount=tblBuyOutStockDet.costAmount,@createBy=@ValueofDB:tblBuyOutStock_createBy,@lastUpdateBy=@ValueofDB:tblBuyOutStock_lastUpdateBy,@createTime=@ValueofDB:tblBuyOutStock_finishTime,@lastUpdateTime=@ValueofDB:tblBuyOutStock_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyOutStock_SCompanyID,@MRemark=@ValueofDB:tblBuyOutStock_Remark,@DRemark=tblBuyOutStockDet.Remark,@SourceID=tblBuyOutStockDet.id,@CompanyCode=@ValueofDB:tblBuyOutStock_CompanyCode,@EmployeeID=@ValueofDB:tblBuyOutStock_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyOutStock_DepartmentCode,@SalesPrice=tblBuyOutStockDet.TaxPrice,@SalesAmount=(-1)*tblBuyOutStockDet.TaxAmount,@SalesQty=(-1)*tblBuyOutStockDet.Qty,@Amount=(-1)*tblBuyOutStockDet.Amount,@Price=tblBuyOutStockDet.Price,@TrackNo=tblBuyOutStockDet.TrackNo,@PresentSampleType=tblBuyOutStockDet.PresentSampleType,@from=tblBuyOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--影响库存后，进行负库存判断-->
		<exec condition="true">
			<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
		</exec>
		<!--出库单在修改后，用户可能删除某些序列号，使其入库，进行序列号判断-->
		<exec condition="'@Sess:BillOper'=='update'">
			<sql type="define">validateSameSeq</sql>
		</exec>
		<exec condition="true"><!--更新入库单及订单的待付款-->
			<sql type="procedure">{call proc_BuyOutPayAmort(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
	</sql>
	<!--=====================影响科目余额，影响往来,生产付款单，更新订单，入库单==================-->
	<sql type="condition">
		<condition><select>select b.ComFullName as AccCom,(TotalTaxAmount-TotalAmount) as TaxAmt,0 as CurTaxAmt,NeedReceiveAmt as NeedRAmt,CurNeedReceiveAmt as CurNeedRAmt,TotalTaxAmount as TotalTaxAmt,CurTotalAmount as CurTotalTaxAmt from tblBuyOutStock a left join tblCompany b on a.CompanyCode=b.classCode where a.id=@ValueofDB:tblBuyOutStock_id</select></condition>
		<!--如果启用“自动产生凭证”，时自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'">
		 	<sql type="certificate">tblBuyOutStock_Acc</sql>
		</exec>
		
		<!--含税金额大于0，插入往来明细 应付贷方（负含税金额）-->
		<exec condition="@SqlReturn:TotalTaxAmt&gt;0">
			<sql type="procedure"><!-- 往来单位明细 （1应付 2应收 3预付 4预收）-->
			{call proc_insertComIni(1@ValueofDB:tblBuyOutStock_id,@ValueofDB:tblBuyOutStock_CompanyCode,1,@ValueofDB:tblBuyOutStock_BillDate,Period=@ValueofDB:tblBuyOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyOutStock_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=-@SqlReturn:TotalTaxAmt@SPFieldLink:RelationDocID=@ValueofDB:tblBuyOutStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyOutStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=-@SqlReturn:CurTotalTaxAmt@SPFieldLink:createBy=@ValueofDB:tblBuyOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyOutStock_SCompanyID@SPFieldLink:BillType=tblBuyOutStock@SPFieldLink:BillNo=@ValueofDB:tblBuyOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyOutStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblBuyOutStock_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblBuyInStock_Remark,retCode,retVal)}</sql>
		</exec>
		<!--当收款金额大于0，插入往来明细 应付借方（负收款金额）-->
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount&gt;0"><!-- 往来单位明细 （1应付 2应收 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblBuyOutStock_id,@ValueofDB:tblBuyOutStock_CompanyCode,1,@ValueofDB:tblBuyOutStock_BillDate,Period=@ValueofDB:tblBuyOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyOutStock_PeriodMonth@SPFieldLink:PayTotalDebit=-@ValueofDB:tblBuyOutStock_AccountAmount@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyOutStock_id@SPFieldLink:Currency=@ValueofDB:tblBuyOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyOutStock_CurrencyRate@SPFieldLink:FcPayTotalDebit=-@ValueofDB:tblBuyOutStock_CurAccountAmount@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyOutStock_SCompanyID@SPFieldLink:BillType=tblBuyOutStock@SPFieldLink:BillNo=@ValueofDB:tblBuyOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyOutStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblBuyOutStock_DiscountAmount,retCode,retVal)}</sql>
		</exec>
		<!--如果付款金额大于0，产生采购付款单-->
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount &gt; 0">
			<sql>insert into tblPay (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,Paytype,PaytypeID,SettleAmt,FactOutcome,Currency,CurrencyRate,CurrencyAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) SELECT '0'+id,BillDate,@CODE:[tblPay_BillNo],CompanyCode,DepartmentCode,EmployeeID,'1','ReturnReceive',AccountAmount,AccountAmount,Currency,CurrencyRate,CurAccountAmount,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,1,'finish','-1','',TrackNo from tblBuyOutStock where tblBuyOutStock.id=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
		<!--向追踪单号表中插入数据-->
		<exec condition="'@MEM:TrackNo'=='true'">  
			<sql>insert into tblTrackBill(id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID) select  substring(replace(newid(),'-',''),1,30),id,BillNo,'tblPay',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblPay where id='0'+@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount &gt; 0&amp;&amp;@SqlReturn:NeedRAmt&gt;0">
			<sql>insert into tblPayDet (id,f_ref,BillAmt,Remark,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,BuyOrderNo,BuyOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,PayBillType)SELECT '1'+id,'0'+id,TotalTaxAmount,'',CurTotalAmount,AccountAmount,CurAccountAmount,Currency,CurrencyRate,'0',TotalTaxAmount,0,CurTotalAmount,BillNo,BuyOrderNo,BuyOrderID,0,SCompanyID,0,id,'tblBuyOutStock' FROM tblBuyOutStock where tblBuyOutStock.id=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount &gt; 0&amp;&amp;@SqlReturn:NeedRAmt&lt;=0">
			<sql>insert into tblPayDet (id,f_ref,BillAmt,Remark,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,BuyOrderNo,BuyOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,PayBillType)SELECT '1'+id,'0'+id,TotalTaxAmount,'',CurTotalAmount,TotalTaxAmount,CurTotalAmount,Currency,CurrencyRate,'0',TotalTaxAmount,0,CurTotalAmount,BillNo,BuyOrderNo,BuyOrderID,0,SCompanyID,0,id,'tblBuyOutStock' FROM tblBuyOutStock where tblBuyOutStock.id=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
		<exec condition="@ValueofDB:tblBuyOutStock_AccountAmount &gt; 0&amp;&amp;true">			  
			<sql>insert into tblPayAccountDet(id,f_ref,PayType,Amount,Account,ExeBalFcAmt,SCompanyID) values ( '1'+@ValueofDB:tblBuyOutStock_id,'0'+@ValueofDB:tblBuyOutStock_id,'1',@ValueofDB:tblBuyOutStock_AccountAmount,@ValueofDB:tblBuyOutStock_Account,@ValueofDB:tblBuyOutStock_CurAccountAmount,@ValueofDB:tblBuyOutStock_SCompanyID)</sql>
		</exec>
	</sql>
</define>

<!--===========采购退货单点击删除，修改时调用==========-->
<define name="tblBuyOutStock_Delete">
	<sql type="condition">
		<exec condition="true"><!--更新入库单及订单数量-->
			<sql type="procedure">{call proc_BuyReturnUpdateBillQty(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则删除单据时更新分仓库存-未审核字段-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyOutStockDet.GoodsCode,@StockCode=tblBuyOutStockDet.StockCode,@BillType=tblBuyOutStock,@InstoreQty=0,@OutstoreQty=-1*tblBuyOutStockDet.Qty,@from=tblBuyOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		
		<!--删除和修改操作时，更新序列号出入明细-->
		<exec condition="'@Sess:BillOper' =='delete'||'@Sess:BillOper' =='update'">
			<sql>delete from tblSeqAuditing where BillID=@ValueofDB:id</sql>
		</exec>	
		
		<!--启用审核后能修改或者删除的说明此单没有审核，不必调用此define，点击反审核时执行此操作. 不启用审核流，执行所有控制及过账操作-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblBuyOutStock_Delete_One</sql>
		</exec>
	</sql>
	<sql type="condition">
	    <!-- 存在对应采购开票单,不允许修改或删除 -->
	    <condition>
	        <select>
				SELECT a.id AS ExistID,b.BillNo AS ExistBill
				FROM tblBuyInfoDet a JOIN tblBuyInvoiceInfo b ON a.f_ref=b.id
				WHERE RefBillID = @ValueofDB:tblBuyOutStock_id 
	        </select>
	    </condition>
		<exec condition="'@SqlReturn:ExistID'!='null'">	
		    <error>buyoutstock.existbuyinvoicebill.error,@SqlReturn:ExistBill</error>   
		</exec>
	</sql>
</define>

<define name="tblBuyOutStock_Delete_One">
	<!--==========控制判断类===========-->
	<sql type="condition">
	<!--回填被引用的订单的退货数量-->
		<exec condition="true">
			<sql type="procedure">{call proc_ReturnBackOrder(@ValueofDB:id,delete,tblBuyOutStock,retCode,retVal)}</sql>
		</exec>
	</sql>	
	
 <sql type="condition">
<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
</sql>		
 
	<sql type="condition"><!--判断是否存在不是自动产生的采购付款单-->
		<condition><select>select BillNo as PayNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=@ValueofDB:tblBuyOutStock_id and tblPay.AutoBillMarker=0 and tblPay.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:PayNo'!='null'">	 					
			<error>PayBill.BillNo.error,@SqlReturn:PayNo</error>                  
		</exec>
	</sql>

	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblBuyOutStock_id and  workFlowNodeName='finish'</select></condition>
		<exec condition="&quot;@SqlReturn:OrderNo&quot;!=&quot;null&quot;">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
		</exec>
	</sql>
	<!--==========逻辑操作类===========-->
	<sql type="condition">
		<condition><select>select BuyOrderID,StockCode,TotalTaxAmount,AccountAmount,BuyInID from tblBuyOutStock where id=@ValueofDB:tblBuyOutStock_id</select></condition>		
		<!--如果启用审核流，则过账时更新分仓库存+未审核字段-->
		<exec condition="'@MEM:tblBuyOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyOutStockDet.GoodsCode,@StockCode=tblBuyOutStockDet.StockCode,@BillType=tblBuyOutStock,@InstoreQty=0,@OutstoreQty=tblBuyOutStockDet.Qty,@from=tblBuyOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<exec condition="true"><!--删除出入库明细记录-->
			<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblBuyOutStock_id,tblBuyOutStock,2,retCode,retVal)}</sql>
		</exec>
		<!--出库单在删除，反审核时进行序列号判断，如果是修改操作，要修改后进行判断-->
		<exec condition="'@Sess:BillOper'!='update'">
			<sql type="define">validateSameSeq</sql>
		</exec>
		<exec condition="true"><!--更新入库单及订单的待付款-->
			<sql type="procedure">{call proc_BuyOutPayAmort(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
		<!--删除本单据的多条往来记录（1应付 2应收 3预付 4预收），用循环存储过程是为了查询往来明细的ID,2012.4.1之前往来明细ID不确定-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblBuyOutStock_id',proc_deleteComIni,@IniId@ParamLink:1,retCode,retVal)}</sql>
		</exec>
		<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblBuyOutStock_id,retCode,retVal)}</sql>
		</exec>
		<!--付款金额大于0,删除付款单及明细信息-->
		<exec condition="@SqlReturn:AccountAmount&gt;0">
			<sql>delete from tblPayDet where f_ref='0'+@ValueofDB:tblBuyOutStock_id</sql>
			<sql>delete from tblPayAccountDet where f_ref='0'+@ValueofDB:tblBuyOutStock_id</sql>
			<sql>delete from tblPay where id='0'+@ValueofDB:tblBuyOutStock_id</sql>
			<sql>delete from tblTrackBill where RelationID='0'+@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
		<!--有引用采购入库单-->
		<exec condition="'@SqlReturn:BuyInID'.length&gt;0">
			<!--更新引用的采购入库单开票信息-->
			<sql>update tblBuyInStockDet set tblBuyInStockDet.NoInvoiceAmount=tblBuyInStockDet.NoInvoiceAmount+tblBuyOutStockDet.Amount from tblBuyOutStockDet where tblBuyInStockDet.id=tblBuyOutStockDet.SourceID and tblBuyOutStockDet.f_Ref=@ValueofDB:tblBuyOutStock_id</sql>
		</exec>
	</sql>	
</define>	
<!--===============================================以上代码：采购退货单操作============================================-->


<!--=======================================================采购换货单===============================================================-->
<!--采购换货时的商品是否启用序列号验证-->
<define name="tblBuyReplaceDetail_GoodsSeqSet">
	<sql type="condition">
		<condition><select>select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblBuyReplaceDetail_GoodsCode</select></condition>
		<exec condition="@SqlReturn:isUsed == 0">
			<error>goodsseq.set.res</error>                  
		</exec>
	</sql>
</define>

<define name="tblBuyReplaceDet_GoodsSeqSet">
	<sql type="condition">
		<condition><select>select seqIsUsed as isUsed  from tblGoods where classCode=@ValueofDB:tblBuyReplaceDet_GoodsCode</select></condition>
		<exec condition="@SqlReturn:isUsed == 0">
			<error>goodsseq.set.res</error>                  
		</exec>
	</sql>
</define>
<define name="tblBuyReplace_Add">
	<sql type="condition">
		<!--付款账户不为空，付款金额必须不等于0-->	  
		<exec condition="@ValueofDB:tblBuyReplace_AccountAmount ==0 &amp;&amp;'@ValueofDB:tblBuyReplace_Account'.length!=0"> 
			<error>buyInStock.payamount.error</error>                  
		</exec>
		<!--付款金额不为0，付款账户不能为空-->
		<exec condition="@ValueofDB:tblBuyReplace_AccountAmount != 0 &amp;&amp;'@ValueofDB:tblBuyReplace_Account'.length==0"> 
			  <error>buyorder.payaccount.error</error>                  
		</exec>	
		<!--差异金额大于等于0时，付款金额不能为负数-->
		<exec condition="@ValueofDB:tblBuyReplace_AccountAmount &lt; 0&amp;&amp;@ValueofDB:tblBuyReplace_TotalTaxAmount &gt;= 0 ">
			<error>common.payAmt.negative.error</error>                  
	  </exec>
	  <!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblBuyReplace_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyReplace_Tax!=0)||@ValueofDB:tblBuyReplace_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>           
		</exec>
		<!--如果引用采购入库，做如下控制-->
		<exec condition="'@ValueofDB:tblBuyReplace_RefBillID'.length&gt;0">
			<sql type="define">tblBuyReplace_QuoteBuyIn_validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblBuyReplaceDet a left join tblgoods c on c.classCode=a.GoodsCode where C.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblBuyReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>                  
	    </exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblBuyReplaceDetail a left join tblgoods c on c.classCode=a.GoodsCode where C.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblBuyReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>                  
	    </exec>
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblBuyReplaceDetail a,tblGoods b where len(a.ProDate)&gt;0 and len(a.Availably)&gt;0 and a.ProDate&gt;a.Availably and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货明细，判断所选择的商品的数量必须大于0-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblBuyReplaceDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--入库明细，判断所选择的商品的数量必须大于0-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblBuyReplaceDetail a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货明细，非赠品，样品单价小于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblBuyReplaceDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--出库明细，非赠品，样品单价小于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblBuyReplaceDetail a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货明细，赠品，样品单价不等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblBuyReplaceDet a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and isnull(a.Price,0)!=0 and a.PresentSampleType in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--出库明细，赠品，样品单价不等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblBuyReplaceDetail a,tblGoods b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.classCode=a.GoodsCode and isnull(a.Price,0)!=0 and a.PresentSampleType in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblBuyReplaceDetail_Add_PriceControl_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--入库与退货的差额是否等于主表的差异金额-->
		<condition><select>select 'isReceiptTax' as errorAmt from tblBuyReplace where id=@ValueofDB:tblBuyReplace_id and TotalTaxAmount+DiscountAmount!=(select sum(TaxAmount) from tblBuyReplaceDetail where f_ref=@ValueofDB:tblBuyReplace_id)-(select sum(TaxAmount) from tblBuyReplaceDet where f_ref=@ValueofDB:tblBuyReplace_id)</select></condition>
		<exec condition="'@SqlReturn:errorAmt' != 'null'">				
			<error>tblBuyReplace.TaxAmt.error</error>                   
		</exec>
	</sql>
	<sql type="condition"><!--外币判断--> 
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblBuyReplace_Account and SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID</select></condition>
		<!--币种和税率存在外币币种时税率必须大于0-->
		<exec condition="'@ValueofDB:tblBuyReplace_Currency'.length &gt;0 &amp;&amp; @ValueofDB:tblBuyReplace_CurrencyRate &lt;= 0"> 
			<error>Currency.InputCurrencyRate.error</error>                  
		</exec>
		<!--币种为空，付款帐户不为空时，选择的付款帐户存在核算外币时提示-->
		<exec condition="'@ValueofDB:tblBuyReplace_Currency'.length != 0 &amp;&amp; '@ValueofDB:tblBuyReplace_Account'.length !=0 &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  )">
			<error>tblAccTypeInfo.SelectCurType.error</error>                  
		</exec>	
		<!--币种不为空，付款帐户不为空时，选择的付款帐户核算的币种跟所选的币种不一致时提示-->
		<exec condition="'@ValueofDB:tblBuyReplace_Currency'.length == 0 &amp;&amp; '@ValueofDB:tblBuyReplace_Account'.length !=0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL') ">
			<error>tblAccTypeInfo.SelectCurType.error</error>                  
		</exec>	
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblBuyReplace_Currency'.length == 0 &amp;&amp; @ValueofDB:tblBuyReplace_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblBuyReplace_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error>                  
		</exec>
	</sql>
	<sql type="condition">
		<!--不启用多仓库更新明细表上的仓库值-->		
		<exec condition="'@MEM:ManyStockBuy'=='false'">
			<sql>update tblBuyReplaceDetail set StockCode=@ValueofDB:tblBuyReplace_InStockCode where f_ref=@ValueofDB:tblBuyReplace_id</sql>	
			<sql>update tblBuyReplaceDet set StockCode=@ValueofDB:tblBuyReplace_StockCode where f_ref=@ValueofDB:tblBuyReplace_id</sql>
		</exec>
		<!--出库数量不能大于可用库存-->
		<exec condition="'@MEM:OutBillUseQtyCheck'=='true'">
			<sql type="define">tblBuyReplace_OutBillUseQty_validate</sql>
		</exec>
	</sql>	
	<sql type="condition">	
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			update tblBuyReplaceDetail set tblBuyReplaceDetail.Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblBuyReplace a join tblBuyReplaceDetail b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyReplace_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblBuyReplaceDetail.id=a.id</sql>
			<sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			update tblBuyReplaceDetail set tblBuyReplaceDetail.ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblBuyReplace a join tblBuyReplaceDetail b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyReplace_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblBuyReplaceDetail.id=a.id</sql>
		</exec>
		<!--如果启用了价格跟踪，将单价插入到价格管理表中-->	
		<exec condition="'@MEM:PriceTracking'=='true'">
			<sql type="define">tblBuyReplace_Add_PriceTracking</sql>
		</exec>
		<exec condition="true">
			<sql>update tblBuyReplace set NeedPayAmt=cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8)),AlreadyPayAmt=@ValueofDB:tblBuyReplace_AccountAmount,CurNeedPayAmt=cast(@ValueofDB:tblBuyReplace_CurTotalAmount as numeric(18,8))-cast(@ValueofDB:tblBuyReplace_CurAccountAmount as numeric(18,8)),CurAlreadyPayAmt=@ValueofDB:tblBuyReplace_CurAccountAmount,BackAmount=0,CurBackAmount=0,CertificateNo=''  where id=@ValueofDB:tblBuyReplace_id </sql>
		</exec>		
		<!--更新入库单及订单数量-->
		<exec condition="'@ValueofDB:tblBuyReplace_RefBillID'.length&gt;0">
			<sql type="procedure">{call proc_BuyReplaceUpdateBillQty(@ValueofDB:id,@ValueofDB:tblBuyReplace_RefBillID,add,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDet.GoodsCode,@StockCode=tblBuyReplaceDet.StockCode,@BillType=tblBuyReplace,@InstoreQty=0,@OutstoreQty=tblBuyReplaceDet.Qty,@from=tblBuyReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillType=tblBuyReplace,@InstoreQty=tblBuyReplaceDetail.Qty,@OutstoreQty=0,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		
		<exec condition="'@MEM:tblBuyReplace_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblBuyReplace_Add_One</sql>
		</exec>
	</sql>	
</define>

<!--====出库数量不能大于可用库存======-->
<define name="tblBuyReplace_OutBillUseQty_validate">
	<sql type="condition">
		<condition><select>select tblStock.StockFullName as StockFullName,d.GoodsFullname as GoodsFullName,cast((case d.isCatalog when 0 then c.LastQty+c.inQtyNotAudit+c.SInQtyNotAudit-c.outQtyNotAudit-c.BOutQtyNotAudit else -99999999 end)+isnull(b.Qty,0)-a.Qty as numeric(18,4)) as DiffQty from (select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblBuyReplaceDet where f_ref=@ValueofDB:tblBuyReplace_id group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode)a left join (select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblBuyReplaceDetail where f_ref=@ValueofDB:tblBuyReplace_id group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode) b on (a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Hue=b.Hue and a.yearNO=b.yearNO and a.Inch=b.Inch and a.Availably=b.Availably and a.ProDate=b.ProDate and a.StockCode=b.StockCode) left join tblStocks c on a.GoodsCode=c.GoodsCode and a.StockCode=c.StockCode and a.BatchNo=c.BatchNo and a.Hue=c.Hue and a.yearNO=c.yearNO and a.Inch=c.Inch and a.Availably=c.Availably and a.ProDate=c.ProDate left join tblGoods d on a.GoodsCode=d.classCode left join tblStock on tblStock.classCode=a.StockCode  where a.Qty&gt;isnull(b.Qty,0)+(case d.isCatalog when 0 then c.LastQty+c.inQtyNotAudit+c.SInQtyNotAudit-c.outQtyNotAudit-c.BOutQtyNotAudit else -99999999 end)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName' != 'null'">			
			<error>common.VirtualStock.excess.error,@ValueofDB:tblBuyReplace_BillNo,@SqlReturn:GoodsFullName,@SqlReturn:DiffQty,@SqlReturn:StockFullName</error>       
		</exec>
	</sql>
</define>
<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=====-->
<define name="tblBuyReplaceDetail_Add_PriceControl_Validate">
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblBuyReplaceDetail a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='Buy' and UserID=@ValueofDB:tblBuyReplace_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblBuyReplace_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>                  
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>                  
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>                  
		</exec>
	</sql>
</define>
<!--=======启用了价格跟踪，向价格管理表中插入数据================-->
<define name="tblBuyReplace_Add_PriceTracking">
	<sql type="condition">
		<condition>
			<select>select id as CPID from tblCustomerPrice where CompanyCode=@ValueofDB:tblBuyReplace_CompanyCode</select>
			<select>select lower(substring(replace(newid(),'-',''),1,28)) as CustomerPriceId</select>
		</condition>
		<!--判断如果价格管理表中没有此供应商的记录，插入一条主表记录-->
		<exec condition="'@SqlReturn:CPID'=='null'">
			<sql>insert into tblCustomerPrice(id,classCode,workFlowNodeName,CompanyCode,createBy,lastUpdateBy,createTime,lastUpdateTime,statusId,SCompanyID) values(@SqlReturn:CustomerPriceId,'','finish',@ValueofDB:tblBuyReplace_CompanyCode,'1','1',@ValueofDB:tblBuyReplace_createTime,@ValueofDB:tblBuyReplace_lastUpdateTime,0,@ValueofDB:tblBuyReplace_SCompanyID)</sql>
		</exec>
		<!--查询在价格管理表中存在的商品，并且修改其最近进价，进价折扣-->
		<exec condition="'@SqlReturn:CPID'!='null'">
			<sql>update tblCustomerPriceDet set tblCustomerPriceDet.BuyPrice=a.Price,tblCustomerPriceDet.UnitPrice=a.UnitPrice,tblCustomerPriceDet.InDiscount=a.Discount from(select b.id as CDetID,(case @MEM:InPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,isnull(b.UnitPrice,a.Price) as UnitPrice,(case when @MEM:InDiscountTracke='true' then Discount else 100 end) as Discount from tblBuyReplaceDetail a,tblCustomerPriceDet b where a.f_ref=@ValueofDB:tblBuyReplace_id and b.f_ref=@SqlReturn:CPID and a.goodsCode=b.goodsCode and a.price&gt;0)a where tblCustomerPriceDet.id=a.CDetID</sql>
		</exec>
		<!--查询在价格管理表中不存在的商品，并且插入最近进价，进价折扣-->
		<exec condition="true">
			<sql>insert into tblCustomerPriceDet(id,f_ref,GoodsCode,BuyPrice)select a.sdid,a.CID,a.GoodsCode,a.Price from(select substring(replace(newid(),'-',''),1,30) as sdid,a.GoodsCode as GoodsCode,(case @MEM:InPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,isnull(a.SecUnit,'') as SecUnit,a.UnitPrice as UnitPrice,(case @SqlReturn:CPID when 'null' then @SqlReturn:CustomerPriceId else @SqlReturn:CPID end) as CID,@ValueofDB:tblBuyReplace_SCompanyID as CSID,(case when @MEM:InDiscountTracke='true' then Discount else 100 end) as Discount from tblBuyReplaceDetail a where a.f_ref=@ValueofDB:tblBuyReplace_id and a.price&gt;0 and (select count(0) from tblCustomerPriceDet b where b.f_ref=(case @SqlReturn:CPID when 'null' then @SqlReturn:CustomerPriceId else @SqlReturn:CPID end) and a.goodsCode=b.goodsCode)=0)a  </sql>
		</exec>		
	</sql>
</define>
<!--==============采购换货单引用采购入库单的判断=================-->
<define name="tblBuyReplace_QuoteBuyIn_validate">
	<sql type="condition">
		<condition><select>select billDate as BuyInDate,CompanyCode as BuyInCompanyCode,InVoiceType as InInVoiceType from tblBuyInStock where id=@ValueofDB:tblBuyReplace_RefBillID</select></condition>
		<!--判断采购换货的单据日期在引用采购入库单前，给出错误提示-->
		<exec condition="'@ValueofDB:tblBuyReplace_BillDate'&lt;'@SqlReturn:BuyInDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblBuyReplace_BillDate,@SqlReturn:BuyInDate</error>                  
		</exec>
		<!--供应商不同，给出错误提示-->
		<exec condition="'@ValueofDB:tblBuyReplace_CompanyCode'!='@SqlReturn:BuyInCompanyCode'">			
			<error>common.providerQuote.update.error</error>                  
		</exec>
		<!--发票类型不同，给出错误提示-->
		<exec condition="'@ValueofDB:tblBuyReplace_InVoiceType'!='@SqlReturn:InInVoiceType'">			
			<error>InVoiceType.Quote.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货数量大于实际入库数量，给出错误提示-->
		<condition><select>select l.BillNo,k.GoodsFullName from (select GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,Qty from tblBuyReplaceDet where f_ref=@ValueofDB:tblBuyReplace_id union all select GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,-1*Qty as Qty from tblBuyReplaceDetail where f_ref=@ValueofDB:tblBuyReplace_id) as a,tblGoods k,tblBuyInStock l where a.GoodsCode=k.classCode and l.id=@ValueofDB:tblBuyReplace_RefBillID group by l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,k.GoodsFullName having SUM(Qty)&gt;(select sum(FactInQty) from tblBuyInStockDet b where b.f_ref=@ValueofDB:tblBuyReplace_RefBillID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO and a.ProDate=b.ProDate and a.Availably=b.Availably)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName'!='null'">			
			<error>common.ReturnInQtyQuote.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>
</define>
			
<define name="tblBuyReplace_Add_One">
<!--=============根据退货明细，入库明细更新出入库明细=============-->
<sql type="condition">
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDet.GoodsCode,@StockCode=tblBuyReplaceDet.StockCode,@BillType=tblBuyReplace,@InstoreQty=0,@OutstoreQty=-1*tblBuyReplaceDet.Qty,@from=tblBuyReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillType=tblBuyReplace,@InstoreQty=-1*tblBuyReplaceDetail.Qty,@OutstoreQty=0,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	
	<!--如果启用审核流，删除已审核完毕的序列号出入明细-->
	<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,delete,retCode,retVal)}</sql>
	</exec>
	
	<!--插入入库数据 普通发票，用含税金额影响库存-->
	<exec condition="@ValueofDB:tblBuyReplace_InVoiceType!=2">
		<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyReplace_Period,@PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth,@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillID=@ValueofDB:tblBuyReplace_id,@BillType=tblBuyReplace,@BillDate=@ValueofDB:tblBuyReplace_BillDate,@BillNo=@ValueofDB:tblBuyReplace_BillNo,@InstoreQty=tblBuyReplaceDetail.Qty,@InstorePrice=tblBuyReplaceDetail.TaxPrice,@InstoreAmount=tblBuyReplaceDetail.TaxAmount,@createBy=@ValueofDB:tblBuyReplace_createBy,@lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy,@createTime=@ValueofDB:tblBuyReplace_finishTime,@lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID,@MRemark=@ValueofDB:tblBuyReplace_Remark,@DRemark=tblBuyReplaceDetail.Remark,@SourceID=tblBuyReplaceDetail.id,@CompanyCode=@ValueofDB:tblBuyReplace_CompanyCode,@EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,@SalesPrice=tblBuyReplaceDetail.TaxPrice,@SalesAmount=tblBuyReplaceDetail.TaxAmount,@SalesQty=tblBuyReplaceDetail.Qty,@Amount=tblBuyReplaceDetail.Amount,@Price=tblBuyReplaceDetail.Price,@DiscountAmount=@ValueofDB:tblBuyReplace_DiscountAmount,@TrackNo=@ValueofDB:tblBuyReplace_TrackNo,@PresentSampleType=tblBuyReplaceDetail.PresentSampleType,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>		
	</exec> 
	<!--增值税发票，用折扣金额影响库存-->
    <exec condition="@ValueofDB:tblBuyReplace_InVoiceType==2">
		<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyReplace_Period,@PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth,@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillID=@ValueofDB:tblBuyReplace_id,@BillType=tblBuyReplace,@BillDate=@ValueofDB:tblBuyReplace_BillDate,@BillNo=@ValueofDB:tblBuyReplace_BillNo,@InstoreQty=tblBuyReplaceDetail.Qty,@InstorePrice=tblBuyReplaceDetail.Price,@InstoreAmount=tblBuyReplaceDetail.Amount,@createBy=@ValueofDB:tblBuyReplace_createBy,@lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy,@createTime=@ValueofDB:tblBuyReplace_finishTime,@lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID,@MRemark=@ValueofDB:tblBuyReplace_Remark,@DRemark=tblBuyReplaceDetail.Remark,@SourceID=tblBuyReplaceDetail.id,@CompanyCode=@ValueofDB:tblBuyReplace_CompanyCode,@EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,@SalesPrice=tblBuyReplaceDetail.TaxPrice,@SalesAmount=tblBuyReplaceDetail.TaxAmount,@SalesQty=tblBuyReplaceDetail.Qty,@Amount=tblBuyReplaceDetail.Amount,@Price=tblBuyReplaceDetail.Price,@DiscountAmount=@ValueofDB:tblBuyReplace_DiscountAmount,@TrackNo=@ValueofDB:tblBuyReplace_TrackNo,@PresentSampleType=tblBuyReplaceDetail.PresentSampleType,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<!--插入出库数据-->
	<exec condition="true">
		<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblBuyReplace_Period,@PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear,@PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth,@GoodsCode=tblBuyReplaceDet.GoodsCode,@StockCode=tblBuyReplaceDet.StockCode,@BillID=@ValueofDB:tblBuyReplace_id,@BillType=tblBuyReplace,@BillDate=@ValueofDB:tblBuyReplace_BillDate,@BillNo=@ValueofDB:tblBuyReplace_BillNo,@OutstoreQty=tblBuyReplaceDet.Qty,@OutstorePrice=tblBuyReplaceDet.costPrice,@OutstoreAmount=tblBuyReplaceDet.costAmount,@createBy=@ValueofDB:tblBuyReplace_createBy,@lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy,@createTime=@ValueofDB:tblBuyReplace_finishTime,@lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime,@SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID,@MRemark=@ValueofDB:tblBuyReplace_Remark,@DRemark=tblBuyReplaceDet.Remark,@SourceID=tblBuyReplaceDet.id,@CompanyCode=@ValueofDB:tblBuyReplace_CompanyCode,@EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID,@DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,@SalesPrice=tblBuyReplaceDet.TaxPrice,@SalesAmount=(-1)*tblBuyReplaceDet.TaxAmount,@SalesQty=(-1)*tblBuyReplaceDet.Qty,@Amount=(-1)*tblBuyReplaceDet.Amount,@Price=tblBuyReplaceDet.Price,@DiscountAmount=@ValueofDB:tblBuyReplace_DiscountAmount,@TrackNo=@ValueofDB:tblBuyReplace_TrackNo,@PresentSampleType=tblBuyReplaceDet.PresentSampleType,@from=tblBuyReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="define">validateSameSeq</sql>
		<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
        <sql>update tblBuyReplace set NoInvoiceAmount=TotalTaxAmount, InvoiceAmount=0 where id=@ValueofDB:tblBuyReplace_id </sql>
	</exec>
</sql>
<!--=============根据不同情况影响往来，科目余额==============-->
<sql type="condition">
	<!--差异金额不等于0，应付贷方：差异金额 往来单位明细 （1应付 2应收 3预付 4预收）-->
	<exec condition="@ValueofDB:tblBuyReplace_TotalTaxAmount!=0">
		<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_CompanyCode,1,@ValueofDB:tblBuyReplace_BillDate,Period=@ValueofDB:tblBuyReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=@ValueofDB:tblBuyReplace_TotalTaxAmount@SPFieldLink:RelationDocID=@ValueofDB:tblBuyReplace_id@SPFieldLink:Currency=@ValueofDB:tblBuyReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyReplace_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=@ValueofDB:tblBuyReplace_CurTotalAmount@SPFieldLink:createBy=@ValueofDB:tblBuyReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID@SPFieldLink:BillType=tblBuyReplace@SPFieldLink:BillNo=@ValueofDB:tblBuyReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblBuyReplace_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblBuyReplace_Remark,retCode,retVal)}</sql>
	</exec>	
	<exec condition="@ValueofDB:tblBuyReplace_TotalTaxAmount&gt;=0&amp;&amp;@ValueofDB:tblBuyReplace_AccountAmount&gt;@ValueofDB:tblBuyReplace_TotalTaxAmount">
		<!--差异金额大于0，付款金额大于差异金额，应付借方：差异金额 -->
		<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_CompanyCode,1,@ValueofDB:tblBuyReplace_BillDate,Period=@ValueofDB:tblBuyReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyReplace_TotalTaxAmount@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyReplace_id@SPFieldLink:Currency=@ValueofDB:tblBuyReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyReplace_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblBuyReplace_CurTotalAmount@ParamNum:@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID@SPFieldLink:BillType=tblBuyReplace@SPFieldLink:BillNo=@ValueofDB:tblBuyReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,retCode,retVal)}</sql>
		<!--差异金额大于0，付款金额大于差异金额，预付借方：付款金额-差异金额 -->
		<sql type="procedure">{call proc_insertComIni(3@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_CompanyCode,3,@ValueofDB:tblBuyReplace_BillDate,Period=@ValueofDB:tblBuyReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth@SPFieldLink:PrePayTotalDebit=@ValueofDB:tblBuyReplace_AccountAmount-@ValueofDB:tblBuyReplace_TotalTaxAmount@ParamNum:@SPFieldLink:PrePayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyReplace_id@SPFieldLink:Currency=@ValueofDB:tblBuyReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyReplace_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=@ValueofDB:tblBuyReplace_CurAccountAmount-@ValueofDB:tblBuyReplace_CurTotalAmount@ParamNum:@SPFieldLink:FcPrePayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID@SPFieldLink:BillType=tblBuyReplace@SPFieldLink:BillNo=@ValueofDB:tblBuyReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,retCode,retVal)}</sql>
	</exec>
	<!--付款金额不等于0且不是差异金额大于0，付款金额大于差异金额的情况 应付借方：付款金额-->
	<exec condition="@ValueofDB:tblBuyReplace_AccountAmount!=0&amp;&amp;!(@ValueofDB:tblBuyReplace_TotalTaxAmount&gt;=0&amp;&amp;@ValueofDB:tblBuyReplace_AccountAmount&gt;@ValueofDB:tblBuyReplace_TotalTaxAmount)">
		<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_CompanyCode,1,@ValueofDB:tblBuyReplace_BillDate,Period=@ValueofDB:tblBuyReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblBuyReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblBuyReplace_PeriodMonth@SPFieldLink:PayTotalDebit=@ValueofDB:tblBuyReplace_AccountAmount@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblBuyReplace_id@SPFieldLink:Currency=@ValueofDB:tblBuyReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblBuyReplace_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblBuyReplace_CurAccountAmount@ParamNum:@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:createBy=@ValueofDB:tblBuyReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblBuyReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblBuyReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblBuyReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblBuyReplace_SCompanyID@SPFieldLink:BillType=tblBuyReplace@SPFieldLink:BillNo=@ValueofDB:tblBuyReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblBuyReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblBuyReplace_DepartmentCode,retCode,retVal)}</sql>
	</exec>
	<!--如果收款金额大于0，要产生销售收款单-->
	<exec condition="@ValueofDB:tblBuyReplace_AccountAmount!=0">
		<sql type="define">tblBuyReplace_Add_CreatePayBill</sql>
	</exec>
</sql>
</define>

<define name="tblBuyReplace_Add_CreatePayBill">
<sql type="condition">
	<condition><select>select case when (cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))&lt;=cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))) or (cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))&gt;0 and cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))&gt;=cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))) then 'TotalTaxAmount' when (cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))&gt;cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))) or (cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))&gt;0 and cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))&lt;cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))) then 'AlrAccAmt' else '0' end as ExeBalAmt,
	(case when cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8))&gt;=0 and (cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8))-cast(@ValueofDB:tblBuyReplace_TotalTaxAmount as numeric(18,8)))&gt;0 then 'PrePay' else 'Pay' end) as rePayType</select></condition>
	<exec condition="true">
		<sql>insert into tblPay (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,PayType,PaytypeID,SettleAmt,FactOutcome,AccAmt,Currency,CurrencyRate,CurrencyAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_BillDate,@CODE:[tblPay_BillNo],@ValueofDB:tblBuyReplace_CompanyCode,@ValueofDB:tblBuyReplace_DepartmentCode,@ValueofDB:tblBuyReplace_EmployeeID,1,@SqlReturn:rePayType,@ValueofDB:tblBuyReplace_AccountAmount,@ValueofDB:tblBuyReplace_AccountAmount,@ValueofDB:tblBuyReplace_AccountAmount,@ValueofDB:tblBuyReplace_Currency,@ValueofDB:tblBuyReplace_CurrencyRate,@ValueofDB:tblBuyReplace_CurAccountAmount,@ValueofDB:tblBuyReplace_PeriodYear,@ValueofDB:tblBuyReplace_PeriodMonth,@ValueofDB:tblBuyReplace_Period,@ValueofDB:tblBuyReplace_createBy,@ValueofDB:tblBuyReplace_createTime,@ValueofDB:tblBuyReplace_lastUpdateBy,@ValueofDB:tblBuyReplace_lastUpdateTime,@ValueofDB:tblBuyReplace_SCompanyID,1,'finish','-1','',@ValueofDB:tblBuyReplace_TrackNo)</sql>
		<sql>insert into tblPayDet (id,f_ref,BillAmt,Remark,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,BuyOrderNo,BuyOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,PayBillType) values ('1'+@ValueofDB:tblBuyReplace_id,'0'+@ValueofDB:tblBuyReplace_id,@ValueofDB:tblBuyReplace_TotalTaxAmount,'',@ValueofDB:tblBuyReplace_CurTotalAmount,(case @SqlReturn:ExeBalAmt when 'TotalTaxAmount' then @ValueofDB:tblBuyReplace_TotalTaxAmount when 'AlrAccAmt' then cast(@ValueofDB:tblBuyReplace_AccountAmount as numeric(18,8)) else 0.0 end),(case @SqlReturn:ExeBalAmt when 'TotalTaxAmount' then @ValueofDB:tblBuyReplace_CurTotalAmount when 'AlrAccAmt' then cast(@ValueofDB:tblBuyReplace_CurAccountAmount as numeric(18,8)) else 0.0 end),@ValueofDB:tblBuyReplace_Currency,@ValueofDB:tblBuyReplace_CurrencyRate,0,@ValueofDB:tblBuyReplace_TotalTaxAmount,0,@ValueofDB:tblBuyReplace_CurTotalAmount,@ValueofDB:tblBuyReplace_BillNo,@ValueofDB:tblBuyReplace_BuyOrderNo,@ValueofDB:tblBuyReplace_BuyOrderID,0,@ValueofDB:tblBuyReplace_SCompanyID,0,@ValueofDB:tblBuyReplace_id,'tblBuyReplace')</sql>		
	</exec>
	<!--如果启用了多账户，向多账户明细表中插入数据-->
	<exec condition="true">
		<sql>insert into tblPayAccountDet (id,f_ref,Paytype,Amount,ExeBalFcAmt,Account,SCompanyID) select  '1'+@ValueofDB:tblBuyReplace_id,'0'+@ValueofDB:tblBuyReplace_id,1,@ValueofDB:tblBuyReplace_AccountAmount,@ValueofDB:tblBuyReplace_CurAccountAmount,@ValueofDB:tblBuyReplace_Account,@ValueofDB:tblBuyReplace_SCompanyID</sql>
	</exec>	
</sql>
</define>

<define name="tblBuyReplace_Delete">
<sql type="condition">
	<condition>
      <select>select  BillNo as InvoiceNo from tblBuyInfoDet,tblBuyInvoiceInfo where tblBuyInvoiceInfo.id=tblBuyInfoDet.f_ref and refbillID=@ValueofDB:tblBuyReplace_id and tblBuyInvoiceInfo.workFlowNodeName!='print'</select>
      <select>select RefBillID from tblBuyReplace where id=@ValueofDB:tblBuyReplace_id</select>
    </condition>
	<!--更新入库单及订单数量-->
	<exec condition="'@SqlReturn:RefBillID'.length&gt;0">
		<sql type="procedure">{call proc_BuyReplaceUpdateBillQty(@ValueofDB:id,@SqlReturn:RefBillID,delete,retCode,retVal)}</sql>
	</exec>
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDet.GoodsCode,@StockCode=tblBuyReplaceDet.StockCode,@BillType=tblBuyReplace,@InstoreQty=0,@OutstoreQty=-1*tblBuyReplaceDet.Qty,@from=tblBuyReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillType=tblBuyReplace,@InstoreQty=-1*tblBuyReplaceDetail.Qty,@OutstoreQty=0,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<!--删除和修改操作时，更新序列号出入明细-->
	<exec condition="'@Sess:BillOper' =='delete'||'@Sess:BillOper' =='update'">
		<sql>delete from tblSeqAuditing where BillID=@ValueofDB:id</sql>
	</exec>	
    <!--判断是否存在对应采购开票管理-->
    <exec condition="'@SqlReturn:InvoiceNo'!='null'">   
         <error>BuyInvoice.ReBillNo.error,@SqlReturn:InvoiceNo</error>                  
    </exec>
	<!--不启用审核流也不需要发票操作直接执行过账操作-->
	<exec condition="'@MEM:tblBuyReplace_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
		<sql type="define">tblBuyReplace_Delete_One</sql>
	</exec>
</sql>	
</define>
<define name="tblBuyReplace_Delete_One">
<sql type="condition"><!--判断是否存在不是自动产生的采购付款单-->
	<condition><select>select BillNo as PayNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=@ValueofDB:tblBuyReplace_id and tblPay.AutoBillMarker=0 and tblPay.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:PayNo'!='null'">	 					
		<error>PayBill.BillNo.error,@SqlReturn:PayNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--判断自动产生的付款单是否存在付款退款-->
	<condition><select>select BillNo as PayReNo from tblPayDet left join tblPay on tblPay.id =tblPayDet.f_ref where tblPayDet.RefbillID=(select a.id from tblPay a,tblPayDet b where a.id=b.f_ref and b.RefbillID=@ValueofDB:tblBuyReplace_id and a.AutoBillMarker=1) and tblPay.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:PayReNo'!='null'">	 					
		 <error>PayDel.receiveNo.error,@SqlReturn:PayReNo</error>                  
	</exec>
</sql>
<sql type="condition">
	<condition><select>select AccountAmount from tblBuyReplace where id=@ValueofDB:tblBuyReplace_id</select></condition>
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDet.GoodsCode,@StockCode=tblBuyReplaceDet.StockCode,@BillType=tblBuyReplace,@InstoreQty=0,@OutstoreQty=tblBuyReplaceDet.Qty,@from=tblBuyReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblBuyReplaceDetail.GoodsCode,@StockCode=tblBuyReplaceDetail.StockCode,@BillType=tblBuyReplace,@InstoreQty=tblBuyReplaceDetail.Qty,@OutstoreQty=0,@from=tblBuyReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	
<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblBuyReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
	
	<exec condition="true"><!--删除出入库明细记录-->
		<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblBuyReplace_id,tblBuyReplace,1,retCode,retVal)}</sql>
	</exec>
	<exec condition="'@Sess:BillOper' !='update'">	
		<sql type="define">validateSameSeq</sql>
		<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
	</exec>
	
	<exec condition="true"><!--删除本单据的多条往来记录（1应付 2应收 3预付 4预收-->
		<sql type="procedure">{call proc_iterateExeProc(select id as IniId@SPFieldLink:case when isnull(PayTotalDebit@RepComma:0)!=0 or isnull(PayTotalLend@RepComma:0)!=0 then 1 when isnull(PrePayTotalDebit@RepComma:0)!=0 or isnull(PrePayTotalLend@RepComma:0)!=0 then 3 end as ComType from tblCompanyIni where relationDocID='@ValueofDB:tblBuyReplace_id',proc_deleteComIni,@IniId@ParamLink:@ComType,retCode,retVal)}
		</sql>
	</exec>
	<exec condition="@SqlReturn:AccountAmount!=0"><!--删除自动产生的采购付款单-->
		<sql>delete from tblPay where id in (select f_ref from tblPayDet where RefbillID=@ValueofDB:tblBuyReplace_id)</sql>	  
		<sql>delete from tblPayAccountDet where f_ref in (select f_ref from tblPayDet where RefbillID=@ValueofDB:tblBuyReplace_id)</sql>
		<sql>delete from tblTrackBill where RelationID in (select f_ref from tblPayDet where RefbillID=@ValueofDB:tblBuyReplace_id)</sql>
		<sql>delete from tblPayDet where RefbillID=@ValueofDB:tblBuyReplace_id</sql>
	</exec>
</sql>
</define>
<!--=========================================================以上代码：采购换货单===========================================================-->


<!--====================================================采购开票================================================-->
<define name="tblBuyInvoiceInfo_add">
	<sql type="condition"><!-- 供应商必须与被关联单据的供应商相同--> 	
		<condition><select>select tbid.CompanyCode AS InvalidCompanyCode from tblBuyInfoDet  tbid LEFT JOIN tblBuyInStock tbis ON tbid.RefBillID=tbis.id LEFT JOIN tblBuyOutStock tbos ON tbid.RefBillID=tbos.id left join tblBuyReplace tbr on tbid.RefBillID=tbr.id left join tblBuyOrder tbo on tbid.RefBillID=tbo.id where isnull(tbid.CompanyCode,0)!=isnull(tbis.CompanyCode,0) AND isnull(tbid.CompanyCode,0)!=isnull(tbos.CompanyCode,0) and isnull(tbid.CompanyCode,0)!=isnull(tbr.CompanyCode,0) and isnull(tbid.CompanyCode,0)!=isnull(tbo.CompanyCode,0) and tbid.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</select></condition>
		<exec condition="'@SqlReturn:InvalidCompanyCode' != 'null'">
			<error>tblBuyInvoiceInfo.companycodemustbesame.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--销售开票明细 关联单据号 与关联ID 不对应提示 -->
		<condition><select>select 'errorBillNo' as errorBillNo from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id and RefBillNo NOT IN (SELECT billno FROM ViewBuyInvoiceSelectBillNo WHERE id=tblBuyInfoDet.RefBillID) and len(RefBillNo) &gt;0</select></condition>
		<exec condition="'@SqlReturn:errorBillNo'=='errorBillNo'">
			<error>tblSalesInfoDet.RefBillNo.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!-- 关联单据有更新，请重新选择关联单据 提示 -->
		<condition><select>select 'SalesOutModifiedError' as SalesOutModifiedError,RefBillNo from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id and sourceid NOT IN (SELECT DetId FROM viewBuyInvoiceSelectGoods WHERE viewBuyInvoiceSelectGoods.id=tblBuyInfoDet.RefBillID) and len(SourceID) &gt; 0</select></condition>
		<exec condition="'@SqlReturn:SalesOutModifiedError'=='SalesOutModifiedError'">
			<error>tblSalesInfoDet.SalesOutModified.error,@SqlReturn:RefBillNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!-- 同一张采购入库、采购订单不可以按商品开票又按单开票--> 	
		<condition><select>select a.RefBillNo as RefBillNo,a.SourceID from (select tblBuyInfoDet.RefBillNo as RefBillNo,SourceID,RefBillID from tblBuyInfoDet left join tblBuyInvoiceInfo on tblBuyInvoiceInfo.id = tblBuyInfoDet.f_ref where RefBillID in(select RefBillID from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id) and len(tblBuyInfoDet.SourceID)&gt;0 and tblBuyInvoiceInfo.workFlowNodeName='finish') a join (select SourceID,RefBillID from tblBuyInfoDet left join tblBuyInvoiceInfo on tblBuyInvoiceInfo.id = tblBuyInfoDet.f_ref where RefBillID in(select RefBillID from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id) and len(tblBuyInfoDet.SourceID)=0 and tblBuyInvoiceInfo.workFlowNodeName='finish') b on a.RefBillID=b.RefBillID</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!= 'null'">
			<error>tblBuyInfoDet.SourceID12.error,@SqlReturn:RefBillNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!-- 判断供应商、关联单据号是否匹配-->
		<condition><select>select tblBuyInfoDet.RefBillNo RefBillNo,tblCompany.ComFullName ComFullName,tblBuyInfoDet.CompanyCode as CompanyCode from tblBuyInfoDet left join tblBuyInStock on tblBuyInStock.id = tblBuyInfoDet.RefBillID left join tblBuyOutStock on tblBuyOutStock.id = tblBuyInfoDet.RefBillID left join tblCompany on tblCompany.classCode=tblBuyInfoDet.CompanyCode where tblBuyInStock.CompanyCode &lt;&gt; tblBuyInfoDet.CompanyCode and tblBuyOutStock.CompanyCode &lt;&gt; tblBuyInfoDet.CompanyCode and  tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and len(tblBuyInfoDet.RefBillNo)&gt;0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null' &amp;&amp; '@SqlReturn:CompanyCode' != 'null'">
			<error>SalesInfo.BillNo.error,@SqlReturn:RefBillNo,@SqlReturn:ComFullName</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!-- 关联单据号、商品明细信息是否匹配-->	
		<condition><select>select tblBuyInfoDet.RefBillNo RefBillNo,tblGoods.GoodsFullName GoodsFullName,tblBuyInfoDet.GoodsCode as GoodsCode from tblBuyInfoDet left join tblBuyInStockDet on tblBuyInStockDet.id = tblBuyInfoDet.SourceID join tblBuyInStock on tblBuyInStock.id=tblBuyInStockDet.f_ref  left join tblBuyOutStockDet on tblBuyOutStockDet.id = tblBuyInfoDet.SourceID join tblBuyOutStock on tblBuyOutStock.id=tblBuyOutStockDet.f_ref join tblGoods ON tblBuyInStockDet.GoodsCode=tblGoods.classCode or tblBuyOutStockDet.GoodsCode=tblGoods.classCode where tblBuyInStock.id &lt;&gt;tblBuyInfoDet.RefBillID and tblBuyOutStock.id &lt;&gt;tblBuyInfoDet.RefBillID and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and len(tblBuyInfoDet.RefBillNo)&gt;0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null' &amp;&amp; '@SqlReturn:GoodsCode' != 'null'">
			<error>SalesInfo.GoodsCode.error,@SqlReturn:GoodsFullName,@SqlReturn:RefBillNo</error>                  
		</exec>
	</sql>		 
	<sql type="condition"><!--不启用‘启用商品开票’不能重复添加采购入库单--> 	
		<condition><select>select count(tblBuyInfoDet.RefBillNo) as RefBillNo,SourceID from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by tblBuyInfoDet.RefBillID,SourceID,tblBuyInfoDet.CompanyCode ORDER BY RefBillNo desc</select></condition>
		<exec condition="@SqlReturn:RefBillNo&gt;=2&amp;&amp;'@SqlReturn:SourceID'.length=='0'">
			<error>tblBuyInfoDet.SourceIDcum.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--添加采购开票管理时不能重复添加采购入库单明细-->	
		<condition><select>select b.SourceIDcum as SourceIDcum from (select Count(SourceID) as SourceIDcum from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id and len(SourceID) &gt;0 group by tblBuyInfoDet.SourceID) b where b.SourceIDcum&gt;1</select></condition>
		<exec condition="@SqlReturn:SourceIDcum!=null">
			<error>tblBuyInfoDet.SourceIDcum.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--对于采购退货单, 本次开票金额必须小于0-->
		<condition><select>select ExeBalAmt as InvoiceAmountForBuyOut from tblBuyInfoDet where ExeBalAmt &gt;=0 and f_ref=@ValueofDB:tblBuyInvoiceInfo_id and RefBillID in (select id from tblBuyOutStock) </select></condition>
		<exec condition="'@SqlReturn:InvoiceAmountForBuyOut'!='null'">
			<error>tblBuyInvoiceInfo.tblBuyOutStock.InvoiceAmountMoreThanZero</error>         
		</exec>
	</sql>
	<sql type="condition"><!--对于采购入库单, 本次开票金额必须大于0-->
		<condition><select>select ExeBalAmt as InvoiceAmountForBuyInStock from tblBuyInfoDet where ExeBalAmt &lt;=0 and f_ref=@ValueofDB:tblBuyInvoiceInfo_id and RefBillID in (select id from tblBuyInStock)</select></condition>
		<exec condition="'@SqlReturn:InvoiceAmountForBuyInStock'!='null'">
		   <error>tblBuyInvoiceInfo.tblBuyInStock.InvoiceAmountLessThanZero</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--主表总金额与明细表不相等-->
		<condition><select>select dbo.getDigits('tblBuyInfoDet','ExeBalAmt',sum(tblBuyInfoDet.ExeBalAmt)) as SumDetAmt,dbo.getDigits('tblBuyInfoDet','ExeBalAmt',(cast(@ValueofDB:tblBuyInvoiceInfo_InvoiceAmount as numeric(18,8)))) as sumMainAmt from tblBuyInfoDet where  tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</select></condition>
		<exec condition="'@SqlReturn:SumDetAmt'!='@SqlReturn:sumMainAmt'&amp;&amp;'@SqlReturn:SumDetAmt'!=''">			
			<error>common.InvoiceAmt.NotEqual.error,@SqlReturn:sumMainAmt,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--当单据开票合计金额超过入库单优惠后金额时，提示是否继续-->
		<condition><select>select a.RefBillNo as RefBillNo,dbo.getDigits('tblBuyInfoDet','ExeBalAmt',ViewBuyInvoiceInfoSelectBillNo.AfterChangeAmt) as TotalTaxAmount from (select sum(ExeBalAmt) as sum,RefBillID,RefBillNo from tblBuyInfoDet left join tblBuyInvoiceInfo on tblBuyInvoiceInfo.id = tblBuyInfoDet.f_ref where RefBillID in(select RefBillID from tblBuyInfoDet where f_ref=@ValueofDB:tblBuyInvoiceInfo_id) and tblBuyInvoiceInfo.workFlowNodeName='finish' group by RefBillID,RefBillNo) a left join ViewBuyInvoiceInfoSelectBillNo on ViewBuyInvoiceInfoSelectBillNo.id=a.RefBillID where abs(a.sum) &gt; abs(ViewBuyInvoiceInfoSelectBillNo.AfterChangeAmt) and ISNULL(ViewBuyInvoiceInfoSelectBillNo.AfterChangeAmt,0)!=0 </select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">			
			<confirm yesDefine="tblBuyInvoiceInfo_Add_AccBefore" noDefine="">common.PreferBackAmount.error,@SqlReturn:RefBillNo,@SqlReturn:TotalTaxAmount</confirm>   
		</exec>
	</sql>
	<sql type="condition"><!--本次开票金额必须与单据金额正负一致-->
		<condition><select>select RefBillNo from tblBuyInfoDet where f_ref=@ValueofDB:id and (NeedPayAmt&gt;0 and ExeBalAmt&lt;0)or(NeedPayAmt&lt;0 and ExeBalAmt&gt;0)</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null'">			
			<error>@SqlReturn:RefBillNo 的本次开票金额必须与未开票金额正负一致</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--不启用审核流 -->
		<exec condition="'@MEM:tblBuyInvoiceInfo_IsStatart' == '0'">
			<sql type="define">tblBuyInvoiceInfo_add_One</sql>
		</exec>
	</sql>
</define>

<!--确认开票开大调用define-->
<define name="tblBuyInvoiceInfo_Add_AccBefore">
	<sql type="condition">
		<exec condition="'@MEM:tblBuyInvoiceInfo_IsStatart' == '0'">
			<sql type="define">tblBuyInvoiceInfo_add_One</sql>
		</exec>
	</sql>
</define>

<define name="tblBuyInvoiceInfo_add_One">
	<sql type="condition">
		<!--按采购订单开票，更新采购订单主表的开票金额，未开票金额-->
		<exec condition="'@MEM:BuyInvoice'=='OrderBill'">
			<sql>update tblBuyOrder set tblBuyOrder.NoInvoiceAmount=tblBuyOrder.NoInvoiceAmount-tblBuyInfoDet.ExeBalAmt,tblBuyOrder.InvoiceAmount=tblBuyOrder.InvoiceAmount+tblBuyInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by RefBillNo) as tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyOrder.BillNo</sql>
			<!--回填采购入库单开票状态-->
			<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrder.NoInvoiceAmount&lt;=0 and tblBuyOrder.InvoiceAmount&gt;0</sql>
			<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrder.NoInvoiceAmount&gt;0 and tblBuyOrder.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyOrder.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票,更新采购订单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:BuyInvoice'=='OrderBill'">
			<sql>update tblBuyOrderDet set tblBuyOrderDet.NoInvoiceAmount=tblBuyOrderDet.NoInvoiceAmount-isnull(tblBuyInfoDet.ExeBalAmt,0),tblBuyOrderDet.InvoiceAmount=tblBuyOrderDet.InvoiceAmount+tblBuyInfoDet.ExeBalAmt FROM tblBuyInfoDet WHERE tblBuyInfoDet.SourceID = tblBuyOrderDet.id AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
			<!--回填采购入库单明细开票状态-->
			<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrderDet.NoInvoiceAmount&lt;=0 and tblBuyOrderDet.InvoiceAmount&gt;0</sql>
			<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrderDet.NoInvoiceAmount&gt;0 and tblBuyOrderDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyOrderDet.InvoiceAmount=0</sql>
		</exec>
		<!--按采购入库开票，更新采购入库单的开票金额，未开票金额-->
		<exec condition="'@MEM:BuyInvoice'=='InBill'">
			<sql>update tblBuyInStock set tblBuyInStock.NoInvoiceAmount=tblBuyInStock.NoInvoiceAmount-tblBuyInfoDet.ExeBalAmt,tblBuyInStock.InvoiceAmount=tblBuyInStock.InvoiceAmount+tblBuyInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by RefBillNo) as tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyInStock.BillNo</sql>
			<!--回填采购入库单开票状态-->
			<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStock.NoInvoiceAmount&lt;=0 and tblBuyInStock.InvoiceAmount&gt;0</sql>
			<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStock.NoInvoiceAmount&gt;0 and tblBuyInStock.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyInStock.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票，更新采购入库单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:BuyInvoice'=='InBill'">
			<sql>update tblBuyInStockDet set tblBuyInStockDet.NoInvoiceAmount=tblBuyInStockDet.NoInvoiceAmount-isnull(tblBuyInfoDet.ExeBalAmt,0),tblBuyInStockDet.InvoiceAmount=tblBuyInStockDet.InvoiceAmount+tblBuyInfoDet.ExeBalAmt FROM tblBuyInfoDet WHERE tblBuyInfoDet.SourceID = tblBuyInStockDet.id AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
			<!--回填采购入库单明细开票状态-->
			<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStockDet.NoInvoiceAmount&lt;=0 and tblBuyInStockDet.InvoiceAmount&gt;0</sql>
			<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStockDet.NoInvoiceAmount&gt;0 and tblBuyInStockDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyInStockDet.InvoiceAmount=0</sql>
		</exec>

		<exec condition="true">
			<!-- 修改采购退货单的开票金额，未开票金额-->
			<sql> update tblBuyOutStock set tblBuyOutStock.NoInvoiceAmount=tblBuyOutStock.NoInvoiceAmount-(-a.ExeBalAmt),tblBuyOutStock.InvoiceAmount=tblBuyOutStock.InvoiceAmount+(-a.ExeBalAmt) from (select isnull(sum(tblBuyInfoDet.ExeBalAmt),0) as ExeBalAmt,tblBuyInfoDet.RefBillNo,tblBuyInfoDet.f_ref as f_ref from tblBuyInfoDet left join tblBuyOutStock on tblBuyInfoDet.RefBillNo = tblBuyOutStock.BillNo where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by tblBuyInfoDet.RefBillNo,f_ref) a WHERE a.RefBillNo = tblBuyOutStock.BillNo AND a.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
	    <!-- 修改采购换货单的开票金额，为开票金额-->
	   	<sql>update tblBuyReplace set tblBuyReplace.NoInvoiceAmount=tblBuyReplace.NoInvoiceAmount-tblBuyInfoDet.ExeBalAmt,tblBuyReplace.InvoiceAmount=tblBuyReplace.InvoiceAmount+tblBuyInfoDet.ExeBalAmt from tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyReplace.BillNo AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
		</exec>
	</sql>
</define>
	
	
<!--已开票更新采购入库单开票状态 -->
<define name="tblBuyInvoiceInfo_delete">
	<sql type="condition"><!--不启用审核流操作-->
		<exec condition="'@MEM:tblBuyInvoiceInfo_IsStatart' == '0'">
			<sql type="define">tblBuyInvoiceInfo_delete_One</sql>
		</exec>
	</sql>
</define>

<define name="tblBuyInvoiceInfo_delete_One">
<sql type="condition">
	<!--按采购订单开票，更新采购订单主表的开票金额，未开票金额-->
	<exec condition="'@MEM:BuyInvoice'=='OrderBill'">
		<sql>update tblBuyOrder set tblBuyOrder.NoInvoiceAmount=tblBuyOrder.NoInvoiceAmount+tblBuyInfoDet.ExeBalAmt,tblBuyOrder.InvoiceAmount=tblBuyOrder.InvoiceAmount-tblBuyInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by RefBillNo) as tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyOrder.BillNo</sql>
		<!--回填采购入库单开票状态-->
		<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrder.NoInvoiceAmount&lt;=0 and tblBuyOrder.InvoiceAmount&gt;0</sql>
		<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrder.NoInvoiceAmount&gt;0 and tblBuyOrder.InvoiceAmount&lt;&gt;0</sql>
		<sql>update tblBuyOrder set tblBuyOrder.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyOrder.InvoiceAmount=0</sql>
	</exec>
	<!--启用按商品开票,更新采购订单明细的开票金额，未开票金额-->
	<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:BuyInvoice'=='OrderBill'">
		<sql>update tblBuyOrderDet set tblBuyOrderDet.NoInvoiceAmount=tblBuyOrderDet.NoInvoiceAmount+isnull(tblBuyInfoDet.ExeBalAmt,0),tblBuyOrderDet.InvoiceAmount=tblBuyOrderDet.InvoiceAmount-tblBuyInfoDet.ExeBalAmt FROM tblBuyInfoDet WHERE tblBuyInfoDet.SourceID = tblBuyOrderDet.id AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
		<!--回填采购入库单明细开票状态-->
		<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrderDet.NoInvoiceAmount&lt;=0 and tblBuyOrderDet.InvoiceAmount&gt;0</sql>
		<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyOrderDet.NoInvoiceAmount&gt;0 and tblBuyOrderDet.InvoiceAmount&lt;&gt;0</sql>							
		<sql>update tblBuyOrderDet set tblBuyOrderDet.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyOrderDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyOrderDet.InvoiceAmount=0</sql>
	</exec>
	<!--按采购入库开票，更新采购入库单的开票金额，未开票金额-->
	<exec condition="'@MEM:BuyInvoice'=='InBill'">
		<sql>update tblBuyInStock set tblBuyInStock.NoInvoiceAmount=tblBuyInStock.NoInvoiceAmount+tblBuyInfoDet.ExeBalAmt,tblBuyInStock.InvoiceAmount=tblBuyInStock.InvoiceAmount-tblBuyInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by RefBillNo) as tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyInStock.BillNo</sql>
		<!--回填采购入库单开票状态-->
		<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStock.NoInvoiceAmount&lt;=0 and tblBuyInStock.InvoiceAmount&gt;0</sql>
		<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStock.NoInvoiceAmount&gt;0 and tblBuyInStock.InvoiceAmount&lt;&gt;0</sql>
		<sql>update tblBuyInStock set tblBuyInStock.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyInStock.InvoiceAmount=0</sql>
	</exec>
	<!--启用按商品开票，更新采购入库单明细的开票金额，未开票金额-->
	<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:BuyInvoice'=='InBill'">
		<sql>update tblBuyInStockDet set tblBuyInStockDet.NoInvoiceAmount=tblBuyInStockDet.NoInvoiceAmount+isnull(tblBuyInfoDet.ExeBalAmt,0),tblBuyInStockDet.InvoiceAmount=tblBuyInStockDet.InvoiceAmount-tblBuyInfoDet.ExeBalAmt FROM tblBuyInfoDet WHERE tblBuyInfoDet.SourceID = tblBuyInStockDet.id AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
		<!--回填采购入库单明细开票状态-->
		<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=2 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStockDet.NoInvoiceAmount&lt;=0 and tblBuyInStockDet.InvoiceAmount&gt;0</sql>
		<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=1 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id AND tblBuyInStockDet.NoInvoiceAmount&gt;0 and tblBuyInStockDet.InvoiceAmount&lt;&gt;0</sql>							
		<sql>update tblBuyInStockDet set tblBuyInStockDet.InvoiceStatus=0 from tblBuyInfoDet where tblBuyInfoDet.SourceID = tblBuyInStockDet.id and tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id and tblBuyInStockDet.InvoiceAmount=0</sql>
	</exec>

	<exec condition="true">
		<!-- 修改采购退货单的开票金额，未开票金额-->
		<sql> update tblBuyOutStock set tblBuyOutStock.NoInvoiceAmount=tblBuyOutStock.NoInvoiceAmount+(-a.ExeBalAmt),tblBuyOutStock.InvoiceAmount=tblBuyOutStock.InvoiceAmount-(-a.ExeBalAmt) from (select isnull(sum(tblBuyInfoDet.ExeBalAmt),0) as ExeBalAmt,tblBuyInfoDet.RefBillNo,tblBuyInfoDet.f_ref as f_ref from tblBuyInfoDet left join tblBuyOutStock on tblBuyInfoDet.RefBillNo = tblBuyOutStock.BillNo where tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id group by tblBuyInfoDet.RefBillNo,f_ref) a WHERE a.RefBillNo = tblBuyOutStock.BillNo AND a.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
		<!-- 修改采购换货单的开票金额，未开票金额-->
		<sql>update tblBuyReplace set tblBuyReplace.NoInvoiceAmount=tblBuyReplace.NoInvoiceAmount+tblBuyInfoDet.ExeBalAmt,tblBuyReplace.InvoiceAmount=tblBuyReplace.InvoiceAmount-tblBuyInfoDet.ExeBalAmt from tblBuyInfoDet WHERE tblBuyInfoDet.RefBillNo = tblBuyReplace.BillNo AND tblBuyInfoDet.f_ref=@ValueofDB:tblBuyInvoiceInfo_id</sql>
	</exec>
</sql>
</define>
<!--========================================================采购开票=====================================================-->

<!--========================================================采购开票单=====================================================-->
<define name="BuyInvoice_add">
	<sql type="condition"><!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->		
		<exec condition="('@ValueofDB:tblBuyInvoice_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblBuyInvoice_Tax!=0)||@ValueofDB:tblBuyInvoice_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>              
		</exec>
	</sql>
	<sql type="condition"><!--采购入库时数量小于等于0，给出错误提示-->
		<condition><select>select c.BillNo as BillNoS,b.GoodsFullName as GoodsS,Qty from tblBuyInvoiceDet a,tblGoods b,tblBuyInStock c where a.f_ref=@ValueofDB:tblBuyInvoice_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&lt;=0 and a.BillType='tblBuyInStock' and a.RelationNo=c.id</select></condition>
		<exec condition="'@SqlReturn:GoodsS' != 'null'">						
			<error>BuyInvoice.BQty.error,@SqlReturn:BillNoS,@SqlReturn:GoodsS</error>             
		</exec>	
	</sql>
	<sql type="condition"><!--采购退货数量大于等于0，给出错误提示-->
		<condition><select>select c.BillNo as BillNoR,b.GoodsFullName as GoodsR,Qty from tblBuyInvoiceDet a,tblGoods b,tblBuyOutStock c where a.f_ref=@ValueofDB:tblBuyInvoice_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&gt;=0 and a.BillType='tblBuyOutStock' and a.RelationNo=c.id</select></condition>
		<exec condition="'@SqlReturn:GoodsR' != 'null'">						
			<error>BuyInvoice.OutQty.error,@SqlReturn:BillNoR,@SqlReturn:GoodsR</error>             
		</exec>	
	</sql>	
	<sql type="condition"><!--采购入库开票数量大于单据本身数量，给出错误提示-->
		<condition><select>select b.BillNo as BillNoInvoice,d.GoodsFullName as goodsInvoice,c.NotInvoiceQty as InvoiceQty from tblBuyInvoiceDet a,tblBuyInStock b,tblBuyInStockDet c,tblGoods d where a.f_ref=@ValueofDB:tblBuyInvoice_id and a.BillType='tblBuyInStock' and a.RelationNo=b.id and a.SourceID=c.id and b.id=c.f_ref and c.GoodsCode=d.classCode and c.InvoiceQty+a.Qty&gt;c.Qty</select></condition>
		<exec condition="'@SqlReturn:goodsInvoice' != 'null'">						
			<error>openInvoice.Qty.error,@SqlReturn:BillNoInvoice,@SqlReturn:goodsInvoice,@SqlReturn:InvoiceQty</error>     
		</exec>	
	</sql>
	<sql type="condition"><!--采购退货开票数量大于单据本身数量，给出错误提示-->
		<condition><select>select b.BillNo as BillNoInvoiceR,d.GoodsFullName as goodsInvoiceR,c.NotInvoiceQty as InvoiceQtyR from tblBuyInvoiceDet a,tblBuyOutStock b,tblBuyOutStockDet c,tblGoods d where a.f_ref=@ValueofDB:tblBuyInvoice_id and a.BillType='tblBuyOutStock' and a.RelationNo=b.id and a.SourceID=c.id and b.id=c.f_ref and c.GoodsCode=d.classCode and c.InvoiceQty+ABS(a.Qty)&gt;c.Qty</select></condition>
		<exec condition="'@SqlReturn:goodsInvoiceR' != 'null'">						
			<error>openInvoice.Qty.error,@SqlReturn:BillNoInvoiceR,@SqlReturn:goodsInvoiceR,@SqlReturn:InvoiceQtyR</error>     
		</exec>	
	</sql>
	<sql type="condition"><!--采购入库单折后单价与所引用的单据的折后单价不同，给出错误提示-->
		<condition><select>select c.BillNo as BillNoSP,b.GoodsFullName as GoodsSP from tblBuyInvoiceDet a,tblGoods b,tblBuyInStock c,tblBuyInStockDet d where a.f_ref=@ValueofDB:tblBuyInvoice_id and b.classCode=a.GoodsCode and a.BillType='tblBuyInStock' and a.SourceId=d.id and c.id=d.f_ref and a.DisPrice!=d.DisPrice</select></condition>
		<exec condition="'@SqlReturn:GoodsSP' != 'null'">						
			<error>BuyInvoice.BPrice.error,@SqlReturn:BillNoSP,@SqlReturn:GoodsSP</error>             
		</exec>	
	</sql>
	<sql type="condition"><!--采购退货单折后单价与所引用的单据的折后单价不同，给出错误提示-->
		<condition><select>select c.BillNo as BillNoRP,b.GoodsFullName as GoodsRP from tblBuyInvoiceDet a,tblGoods b,tblBuyOutStock c,tblBuyOutStockDet d where a.f_ref=@ValueofDB:tblBuyInvoice_id and b.classCode=a.GoodsCode and a.BillType='tblBuyOutStock' and a.SourceId=d.id and c.id=d.f_ref and a.DisPrice!=d.DisPrice</select></condition>
		<exec condition="'@SqlReturn:GoodsRP' != 'null'">						
			<error>BuyInvoice.OutPrice.error,@SqlReturn:BillNoRP,@SqlReturn:GoodsRP</error>             
		</exec>	
	</sql>
	<sql type="condition"><!--折扣不是0到1之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblBuyInvoiceDet a where a.f_ref=@ValueofDB:tblBuyInvoice_id and (Discount&lt;=0 or Discount&gt;1)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>              
		</exec>
	</sql>
	<sql type="condition"><!--总金额与明细表合计金额不相等，给出错误提示-->
		<condition><select>select dbo.getDigits('tblBuyOrderDet','TaxAmount',sum(tblBuyInvoiceDet.TaxAmount)) as SumDetAmt from tblBuyInvoiceDet where f_ref=@ValueofDB:tblBuyInvoice_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblBuyInvoiceDet_TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblBuyInvoiceDet_TotalTaxAmount,@SqlReturn:SumDetAmt</error>             
		</exec>	
	</sql>
	<!--引用单据日期不能大于当前单据日期-->
	  <sql type="condition">
			<condition><select>select BillNo,BillDate from ViewBuyInOutDet where id in(select RelationNo from tblBuyInvoiceDet where f_ref=@ValueofDB:tblBuyInvoice_id) and BillDate&gt;@ValueofDB:tblBuyApplicationTotal_BillDate</select></condition>
			<exec condition="'@SqlReturn:BillNo' != 'null'">				
				<error>Billquote.BillDate.error,@SqlReturn:BillNo,@SqlReturn:BillDate</error>  
			</exec>	            
		</sql>
    <sql type="condition"><!--如果不启用审核流，调用过账的define-->
		<exec condition="'@MEM:tblBuyInvoice_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">BuyInvoice_Add_One</sql>
		</exec>
	</sql>
	<sql type="condition"><!--明细中发票类型和主表不符-->
		<condition><select>select count(ViewBuyInOutDet.BillNo) as Bill  from tblBuyInvoice inner join tblBuyInvoiceDet on tblBuyInvoice.id = tblBuyInvoiceDet.f_ref left join ViewBuyInOutDet on ViewBuyInOutDet.Detid=tblBuyInvoiceDet.SourceID where tblBuyInvoice.id=@ValueofDB:tblBuyInvoice_id and ViewBuyInOutDet.inVoiceType!=tblBuyInvoice.inVoiceType </select>
		</condition>
		<exec condition="@SqlReturn:Bill !=0">				
			<error>tblBuyInvoice.VoiceType.error</error>              
		</exec>
	</sql>
	<sql type="condition"><!--明细中供应商和主表不符-->
		<condition><select>select count(ViewBuyInOutDet.BillNo) as Bill from tblBuyInvoice inner join tblBuyInvoiceDet on tblBuyInvoice.id = tblBuyInvoiceDet.f_ref  left join ViewBuyInOutDet on ViewBuyInOutDet.Detid=tblBuyInvoiceDet.SourceID where tblBuyInvoice.id=@ValueofDB:tblBuyInvoice_id  and ViewBuyInOutDet.CompanyCode!=tblBuyInvoice.CompanyCode </select>
		</condition>
		<exec condition="@SqlReturn:Bill !=0">				
			<error>Invoice.company.error</error>             
		</exec>
	</sql>
</define>

<!--=========采购开票过账操作==========-->
<define name="BuyInvoice_Add_One">		
	<!--回填采购出库单的开票数以及未开票数-->		
	<sql>update tblBuyInStockDet set tblBuyInStockDet.NotInvoiceQty=tblBuyInStockDet.NotInvoiceQty-a.Qty,tblBuyInStockDet.InvoiceQty=tblBuyInStockDet.InvoiceQty+a.Qty from tblBuyInvoiceDet as a where a.f_ref=@ValueofDB:tblBuyInvoiceDet_id and a.SourceID=tblBuyInStockDet.id</sql>
	<!--回填采购退货单的开票数以及未开票数-->		
	<sql>update tblBuyOutStockDet set tblBuyOutStockDet.NotInvoiceQty=tblBuyOutStockDet.NotInvoiceQty+a.Qty,tblBuyOutStockDet.InvoiceQty=tblBuyOutStockDet.InvoiceQty-a.Qty from tblBuyInvoiceDet as a where a.f_ref=@ValueofDB:tblBuyInvoiceDet_id and a.SourceID=tblBuyOutStockDet.id</sql>
</define>

<!--不管是否启用审核流，修改或者删除都会调用此define，但启用了审核流能够修改或者删除说明是未审核完成，未审核的单据不需要下面的判断-->
<define name="BuyInvoice_Del">
	<sql type="condition">
		<exec condition="@MEM:tblBuyInvoice_IsStatart==0 &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">BuyInvoice_Delete_One</sql> 
		</exec>
	</sql>
</define>	
<define name="BuyInvoice_Delete_One">		
	<!--回填采购出库单的开票数以及未开票数-->		
	<sql>update tblBuyInStockDet set tblBuyInStockDet.NotInvoiceQty=tblBuyInStockDet.NotInvoiceQty+a.Qty,tblBuyInStockDet.InvoiceQty=tblBuyInStockDet.InvoiceQty-a.Qty from tblBuyInvoiceDet as a where a.f_ref=@ValueofDB:tblBuyInvoiceDet_id and a.SourceID=tblBuyInStockDet.id</sql>
	<!--回填采购退货单的开票数以及未开票数-->		
	<sql>update tblBuyOutStockDet set tblBuyOutStockDet.NotInvoiceQty=tblBuyOutStockDet.NotInvoiceQty-a.Qty,tblBuyOutStockDet.InvoiceQty=tblBuyOutStockDet.InvoiceQty+a.Qty from tblBuyInvoiceDet as a where a.f_ref=@ValueofDB:tblBuyInvoiceDet_id and a.SourceID=tblBuyOutStockDet.id</sql>
</define>
<!--================================================采购申请汇总单=================================================-->

<define name="tblBuyApplicationTotal_add"> 
	<!--引用单据日期不能大于当前单据日期-->
	  <sql type="condition">
			<condition><select>select BillNo,BillDate from tblBuyApplication where id in(select BuyApplyID from tblBuyApplicationTotalDet where f_ref=@ValueofDB:tblBuyApplicationTotal_id) and BillDate&gt;@ValueofDB:tblBuyApplicationTotal_BillDate</select></condition>
			<exec condition="'@SqlReturn:BillNo' != 'null'">				
				<error>Billquote.BillDate.error,@SqlReturn:BillNo,@SqlReturn:BillDate</error>  
			</exec>	            
		</sql>
	
     <!--如果录入的数量小于0，给出提示-->	
	<sql type="condition">
		<condition><select>select tblGoods.GoodsFullName as GoodsQ,Qty,PlanQty,OrderQty,NoOrderQty from tblBuyApplicationTotalDet,tblGoods where tblGoods.classCode=tblBuyApplicationTotalDet.GoodsCode and f_ref=@ValueofDB:tblBuyApplicationTotal_id and isnull(tblBuyApplicationTotalDet.planQty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">				
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>              
		</exec>
		<!--设置申请汇总单的未定数量=预购数量,已订数量0-->
		<exec condition="true">	
            <sql>update tblBuyApplicationTotalDet set tblBuyApplicationTotalDet.NotAllotQty=tblBuyApplicationTotalDet.planQty,tblBuyApplicationTotalDet.NoOrderQty=tblBuyApplicationTotalDet.planQty,tblBuyApplicationTotalDet.OrderQty=0,FinishStatus=0,ReturnQty=0,NotReturnQty=planQty where f_ref=@ValueofDB:tblBuyApplicationTotal_id</sql>
      <sql>update tblBuyApplicationTotal set statusId=0,SendStatus=0 where id=@ValueofDB:tblBuyApplicationTotal_id</sql>
     	</exec>
  </sql>
        <!--回填采购申请单的分配数量同时更改未分配数量-->
  	<sql type="condition">
		  <exec condition="true">
		  <sql type="procedure">{call proc_BuyAppTotalBackFillApp(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
	  </sql>
	  <!--部门和引用单据部门不符报错-->
	  <sql type="condition">
			<condition><select>select COUNT(*) DepartmentCode from tblBuyApplication a left join tblBuyApplicationTotalDet b on a.id=b.BuyApplyID where b.f_ref=@ValueofDB:tblBuyApplicationTotal_id and a.DepartmentCode !=b.DepartmentCode</select></condition>
			<exec condition="@SqlReturn:DepartmentCode&gt;0">				
				<error>tblBuyApplication.DepartmentCode.error</error>  
			</exec>	            
		</sql>
		<!--部门和引用单据部门不符报错-->
	  <sql type="condition">
			<condition><select>select COUNT(*) Pro from tblBuyApplicationDet a left join tblBuyApplicationTotalDet b on a.id=b.SourceID where b.f_ref=@ValueofDB:tblBuyApplicationTotal_id and (a.BatchNo!=b.BatchNo or a.Inch!=b.Inch or a.Hue!=b.Hue or a.yearNO!=B.yearNO or a.ProDate !=b.ProDate or a.Availably !=b.Availably)</select></condition>
			<exec condition="@SqlReturn:Pro&gt;0">				
				<error>ReSelect.QuoteGoods.error</error>  
			</exec>	            
		</sql>
</define>

<!--采购申请汇总单列表删除时调用-->		
<define name="tblBuyApplicationTotal_Delete"> 
	<!--状态不是未完成状态，不允许任何操作-->
	<sql type="condition">
		<condition><select>select statusId from tblBuyApplicationTotal where id=@ValueofDB:tblBuyApplicationTotal_id</select></condition>		
		<exec condition="@SqlReturn:statusId!=0">	 		
			<error>采购状态为已终止或已完成,不允许此操作.</error>              
		</exec>
	</sql>
	<!--采购申请汇总单据如果被引用则不允许被删除-->
	<sql type="condition">
		<condition><select>select a.BillNo as BuyOrderBillNo from tblBuyOrder a,tblBuyOrderDet b where a.id=b.f_ref and b.BuyAppTotalID=@ValueofDB:viewBuyApplyTotal_id and a.workFlowNodeName!='print'</select></condition>		
		<exec condition="'@SqlReturn:BuyOrderBillNo' != 'null'">	 		
			<error>BuyAskDel.BillNo.error,@SqlReturn:BuyOrderBillNo</error>                  
		</exec>
	</sql>
	<!--采购申请汇总单据如果被配送单引用则不允许被删除-->
	<sql type="condition">
		<condition><select>select a.BillNo as SendBillNo from tblSend a,tblSendDet b where a.id=b.f_ref and b.BuyAppTotalID=@ValueofDB:viewBuyApplyTotal_id and a.workFlowNodeName!='print'</select></condition>		
		<exec condition="'@SqlReturn:SendBillNo' != 'null'">	 		
			<error>tblSend.BillNo.error,@SqlReturn:SendBillNo</error>                  
		</exec>
	</sql>
	<!--更改采购申请单明细的分配数量及未分配数量-->
  <sql type="condition">
		  <exec condition="true">
		  <sql type="procedure">{call proc_BuyAppTotalBackFillApp(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
	</sql> 
</define>

<!--采购申请汇总单终止按钮-->
<define name="tblBuyApplicationTotalStatus_stop">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplicationTotal where id=@ValueofDB:tblBuyApplicationTotal_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是终止状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==2">
			<error>common.cannotStop.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表的完成状态-->
		<exec condition="true">
			<sql>update tblBuyApplicationTotal set statusId=2 where id=@ValueofDB:tblBuyApplicationTotal_id</sql>
			<sql>update tblBuyApplicationTotalDet set NoOrderQty=0,FinishStatus=2 where f_ref=@ValueofDB:tblBuyApplicationTotal_id</sql>
		</exec>
   </sql>
</define>

<!--采购申请汇总单完成按钮-->
<define name="tblBuyApplicationTotalStatus_Finish">
   <sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplicationTotal where id=@ValueofDB:tblBuyApplicationTotal_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态不是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.cannotFinish.error</error>                  
		</exec>
		<!--修改主表的状态，明细表的完成状态-->
		<exec condition="true">
			<sql>update tblBuyApplicationTotal set statusId=1 where id=@ValueofDB:tblBuyApplicationTotal_id</sql>
			<sql>update tblBuyApplicationTotalDet set NoOrderQty=0,FinishStatus=1 where f_ref=@ValueofDB:tblBuyApplicationTotal_id</sql>
		</exec>
   </sql>
</define>

<!--采购申请汇总单激活按钮-->
<define name="tblBuyApplicationTotalStatus_Reverse">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName from tblBuyApplicationTotal where id=@ValueofDB:tblBuyApplicationTotal_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>                  
		</exec>
		<!--单据状态是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==0">
			<error>common.cannotActive.error</error>                  
		</exec>
		<!--修改主表的状态，和明细表完成状态-->
		<exec condition="true">
			<sql>update tblBuyApplicationTotal set statusId=0 where id=@ValueofDB:tblBuyApplicationTotal_id</sql>
			<sql>update tblBuyApplicationTotalDet set NoOrderQty=isnull(planQty,0)-isnull(OrderQty,0),FinishStatus=0 where f_ref=@ValueofDB:tblBuyApplicationTotal_id</sql>
		</exec>
	</sql>
</define>	



<!--=========================================查询条件期间设置=================================================--> 

<!--查询条件期间设置明细表当前记录的起始值和上一条记录的结束值不相等时给出错误提示-->
<define name="tblQueryPeriodSet_add"> 
	<sql type="condition">
		<condition><select>SELECT COUNT(*) AS result FROM tblQueryPeriodSetDet x,tblQueryPeriodSet WHERE x.f_ref=tblQueryPeriodSet.id AND tblQueryPeriodSet.id=@ValueofDB:tblQueryPeriodSet_id AND x.startVal!=(SELECT endVal FROM tblQueryPeriodSetDet y WHERE y.detOrderNo=x.detOrderNo-1   ) AND x.detOrderNo!=(select MIN(detOrderNo) FROM tblQueryPeriodSetDet z, tblQueryPeriodSet s WHERE z.f_ref=s.id AND s.id=@ValueofDB:tblQueryPeriodSet_id)</select></condition>
		<exec condition=" @SqlReturn:result !=0">				
			<error>tblQueryPeriodSetDet.val.error</error>                  
		</exec>	
	</sql>
	<sql type="condition">
		<condition><select>SELECT id as AsId,startVal as StartVal,endVal as EndVal FROM tblQueryPeriodSetDet WHERE (startVal &gt; endVal) and f_ref=@ValueofDB:tblQueryPeriodSet_id</select></condition>
		<exec condition=" '@SqlReturn:AsId' != 'null'">				
			<error>tblQueryPeriodSetDet.StartVal.error</error>                  
		</exec>	
	</sql>
</define>	






 	<!--==========================================杂项================================================-->

<define name="tblApplyGoodsBill_NoAuditing_One">
	<sql type="condition">
		<condition>
			<select>select b.BillNo as BillIsQuoted,a.BillNo as BillQuoting from tblDeliveryBill a left join tblApplyGoodsBill b on b.id=a.SourceID where a.SourceID=@ValueofDB:tblApplyGoodsBill_id</select>
		</condition>
  	<!--请购单被配送单引用 ，不能删除-->
		<exec condition="'@SqlReturn:BillIsQuoted'!='null'">
			<error>tblApplyGoodsBill.delete.quoted.error,@SqlReturn:BillIsQuoted,@SqlReturn:BillQuoting</error>                  
		</exec>
	</sql>
</define>

<!--采购入库时的商品是否启用序列号验证-->
<define name="tblBuyInStockDet_GoodsSeqSet">
	<sql type="condition">
	 <condition>
	   <select>select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblBuyInStockDet_GoodsCode</select>
   </condition>
   <exec condition="@SqlReturn:isUsed == 0">
     <error>goodsseq.set.res</error>                  
   </exec>
  </sql>
</define>
<!--序列号盘点单的商品是否启用序列号验证-->
<define name="tblseqCheckDet_GoodsSeqSet">
	<sql type="condition">
		<condition>
			<select>select seqIsUsed as isUsed from tblGoods  where classCode=@ValueofDB:tblseqCheckDet_GoodsCode</select>
		</condition>
		<exec condition="@SqlReturn:isUsed == 0">
				<error>goodsseq.set.res</error>                  
		</exec>
	</sql>
</define>

</defineSqls>