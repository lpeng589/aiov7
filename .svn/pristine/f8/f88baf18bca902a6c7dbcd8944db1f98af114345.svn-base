<?xml version="1.0" encoding="gb2312"?>
<defineSqls>
<!--===========================================================打开记录===================================================-->
<define name="tblBrushCardAnnal_Add">
	<sql type="condition">
		<condition>
		 <select>select EmpNumber from tblEmployee where id = @Sess:UserId</select>
		</condition>
		<exec condition="true">
		<sql> update tblBrushCardAnnal set employeeNo=@SqlReturn:EmpNumber where id=@ValueofDB:tblBrushCardAnnal_id </sql>
		</exec>
	</sql>
</define>
<!--======================================================以上代码：打开记录================================================-->

<!--===========================================================预收转应收===================================================-->
<define name="tblTransferSale1_Add">
	<sql type="condition"><!--转账金额必须大于0-->
		<exec condition="@ValueofDB:tblTransferSale1_ExeTransferAmt&lt;=0">					
			<error>ChangeAmount.Bill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表关联单据编号的往来单位与转入单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difCom from tblTransferSaleDet1 a,tblSalesOutStock b where a.f_ref=@ValueofDB:tblTransferSale1_id and a.RefSalesOutID=b.id and b.CompanyCode!=@ValueofDB:tblTransferSale1_InCompanyCode</select></condition>
		<exec condition="'@SqlReturn:difCom'!='null'">
			<error>common.TransferDifCom.error,@SqlReturn:difCom</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblTransferSaleDet1 where f_ref=@ValueofDB:tblTransferSale1_id group by RefSalesOutID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次结算金额小于等于0或者是大于待结算金额，给出错误提示-->
		<condition><select>select RefbillID from tblTransferSaleDet1 where f_ref=@ValueofDB:tblTransferSale1_id and (ExeBalAmt&gt;WexeBalAmt or ExeBalAmt&lt;=0)</select></condition>
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<error>tblTransferSale.add.Amt,@SqlReturn:RefbillID</error> 
		</exec>
	</sql>
	<sql type="condition"><!--转账金额必须大于等于明细表本次结算金额合计，否则给出错误提示-->
		<condition><select>select dbo.getDigits('tblTransferSaleDet1','ExeBalAmt',isnull(sum(tblTransferSaleDet1.ExeBalAmt),0)) as SumDetAmt from tblTransferSaleDet1 where f_ref=@ValueofDB:tblTransferSale1_id</select></condition>
		<exec condition="@ValueofDB:tblTransferSale1_ExeTransferAmt&lt;@SqlReturn:SumDetAmt">
			<error>TransferSale.add.TransferAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购入库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblSalesOutStock a JOIN tblTransferSaleDet1 b ON a.id=b.RefSalesOutID WHERE b.f_ref=@ValueofDB:tblTransferSale1_id</select></condition>
		<exec condition="@SqlReturn:QuoteDateLen &gt; 0  &amp;&amp;'@ValueofDB:tblTransferSale1_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblTransferSale1_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">	
		<exec condition="true">
			<sql>update tblTransferSale1 set CertificateNo='' where id=@ValueofDB:tblTransferSale1_id</sql>
		</exec>
		<exec condition="'@MEM:tblTransferSale1_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale1_Add_One</sql>
		</exec>
	</sql>
</define>
<define name="tblTransferSale1_Add_One">
	<sql type="condition">
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
    <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblTransferSale1</sql></exec>
    <exec condition="true"> 
			<!--预收借方增加 影响往来（1应付 2应收 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblTransferSale1_id,@ValueofDB:tblTransferSale1_CompanyCode,4,@ValueofDB:tblTransferSale1_BillDate,PreReceiveTotalDebit=@ValueofDB:tblTransferSale1_ExeTransferAmt@SPFieldLink:PreReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale1_id@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale1_PeriodYear@SPFieldLink:BillType=tblTransferSale1@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale1_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale1_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale1_createBy@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale1_lastUpdateBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale1_createTime@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale1_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale1_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale1_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale1_CurrencyRate@SPFieldLink:FcPreRecTotalDebit=@ValueofDB:tblTransferSale1_FcExeTransferAmt@SPFieldLink:FcPreRecTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblTransferSale1_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale1_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale1_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale1_Remark,retCode,retVal)}</sql>
			<!--应收借方减少-->
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblTransferSale1_id,@ValueofDB:tblTransferSale1_InCompanyCode,2,@ValueofDB:tblTransferSale1_BillDate,ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblTransferSale1_ExeTransferAmt@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale1_id@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale1_PeriodYear@SPFieldLink:BillType=tblTransferSale1@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale1_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale1_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale1_createBy@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale1_lastUpdateBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale1_createTime@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale1_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale1_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale1_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale1_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblTransferSale1_FcExeTransferAmt@SPFieldLink:BillNo=@ValueofDB:tblTransferSale1_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale1_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale1_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale1_Remark,retCode,retVal)}</sql>
			<!--更新销售出库累计收款金额-->
			<sql type="procedure">{call proc_iterateExeProc(select RefSalesOutID as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet1 k where k.f_ref='@ValueofDB:tblTransferSale1_id',proc_SalesReceiveAboutRec,@RefbillID@ParamLink:'tblSalesOutStock'@ParamLink:@ExeBalAmt@ParamLink:'add'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>
	</sql>
</define> 
<define name="tblTransferSale1_Del"> 
	<sql type="condition"> 
		<exec condition="'@MEM:tblTransferSale1_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale1_Del_One</sql>
		</exec>
	</sql>	  		  
</define>
<define name="tblTransferSale1_Del_One">
	<sql type="condition"><!--凭证启用了审核流，关联次单据的审核流已经审核完毕，不能修改此单 -->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblTransferSale1_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
	</sql>
	<sql type="condition">
		<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblTransferSale1_id,retCode,retVal)}</sql>
		</exec>
	</sql>
	<!--删除预收账款往来明细-->
	<sql type="procedure">{call proc_deleteComIni(@ValueofDB:tblTransferSale1_id,4,retCode,retVal)}</sql>	
	<!--删除应收账款往来明细-->
	<sql type="procedure">{call proc_deleteComIni(1@ValueofDB:tblTransferSale1_id,2,retCode,retVal)}</sql>
	<!--更新销售出库累计收款金额-->
	<sql type="procedure">{call proc_iterateExeProc(select RefSalesOutID as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet1 k where k.f_ref='@ValueofDB:tblTransferSale1_id',proc_SalesReceiveAboutRec,@RefbillID@ParamLink:'tblSalesOutStock'@ParamLink:@ExeBalAmt@ParamLink:'delete'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
</define>	 
<!--=====================================================以上代码：预收转应收=============================================================-->	
 
<!--========================================================应付转应收=================================================================-->	 	
<define name="tblTransferSale2_Add">
	<sql type="condition"><!--转账金额必须大于0-->
		<exec condition="@ValueofDB:tblTransferSale2_ExeTransferAmt&lt;=0">					
			<error>ChangeAmount.Bill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--关联单据编号的往来单位与转出单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difComO from tblTransferSale2 a,tblBuyInStock b where a.id=@ValueofDB:tblTransferSale2_id and a.RefBillNo=b.BillNo and b.CompanyCode!=a.CompanyCode</select></condition>
		<exec condition="'@SqlReturn:difComO'!='null'">
			<error>common.TransferDifComO.error,@SqlReturn:difComO</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表关联单据编号的往来单位与转入单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difCom from tblTransferSaleDet2 a,tblSalesOutStock b where a.f_ref=@ValueofDB:tblTransferSale2_id and a.RefbillID=b.BillNo and b.CompanyCode!=@ValueofDB:tblTransferSale1_InCompanyCode</select></condition>
		<exec condition="'@SqlReturn:difCom'!='null'">
			<error>common.TransferDifCom.error,@SqlReturn:difCom</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblTransferSaleDet2 where f_ref=@ValueofDB:tblTransferSale2_id group by RefbillID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次结算金额小于等于0或者是大于待结算金额，给出错误提示-->
		<condition><select>select RefbillID from tblTransferSaleDet2 where f_ref=@ValueofDB:tblTransferSale2_id and (ExeBalAmt&gt;WexeBalAmt or ExeBalAmt&lt;=0)</select></condition>
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<error>tblTransferSale.add.Amt,@SqlReturn:RefbillID</error> 
		</exec>
	</sql>
	<sql type="condition"><!--转账金额必须大于等于明细表本次结算金额合计，否则给出错误提示-->
		<condition><select>select dbo.getDigits('tblTransferSaleDet2','ExeBalAmt',isnull(sum(tblTransferSaleDet2.ExeBalAmt),0)) as SumDetAmt from tblTransferSaleDet2 where f_ref=@ValueofDB:tblTransferSale2_id</select></condition>
		<exec condition="@ValueofDB:tblTransferSale2_ExeTransferAmt&lt;@SqlReturn:SumDetAmt">
			<error>TransferSale.add.TransferAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购入库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblSalesOutStock a JOIN tblTransferSaleDet2 b ON a.BillNo=b.RefbillID WHERE b.f_ref=@ValueofDB:tblTransferSale2_id</select></condition>
		<exec condition=" @SqlReturn:QuoteDateLen &gt; 0 &amp;&amp; '@ValueofDB:tblTransferSale2_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblTransferSale2_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<exec condition="true">
			<sql>update tblTransferSale2 set CertificateNo='' where id=@ValueofDB:tblTransferSale2_id</sql>
		</exec>
		<exec condition="'@MEM:tblTransferSale2_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale2_Add_One</sql>
		</exec>
	</sql>
</define>	
<define name="tblTransferSale2_Add_One">
	<sql type="condition">
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
    <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblTransferSale2</sql></exec>
    <exec condition="true">
			<!--转出单位的应付减少 影响往来（1应付 2应收 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblTransferSale2_id,@ValueofDB:tblTransferSale2_CompanyCode,1,@ValueofDB:tblTransferSale2_BillDate,PayTotalDebit=@ValueofDB:tblTransferSale2_ExeTransferAmt@SPFieldLink:PayTotalLend=0@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale2_id@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale2_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale2_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale2_Period@SPFieldLink:BillType=tblTransferSale2@SPFieldLink:createBy=@ValueofDB:tblTransferSale2_createBy@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale2_lastUpdateBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale2_createTime@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale2_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale2_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale2_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale2_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblTransferSale2_FcExeTransferAmt@SPFieldLink:FcPayTotalCredit=0@ParamNum:@SPFieldLink:BillNo=@ValueofDB:tblTransferSale2_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale2_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale2_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale2_Remark,retCode,retVal)}</sql>
			<!--转入单位的应收减少-->
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblTransferSale2_id,@ValueofDB:tblTransferSale2_InCompanyCode,2,@ValueofDB:tblTransferSale2_BillDate,ReceiveTotalDebit=0@ParamNum:@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblTransferSale2_ExeTransferAmt@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale2_id@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale2_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale2_PeriodMonth@SPFieldLink:BillType=tblTransferSale2@SPFieldLink:Period=@ValueofDB:tblTransferSale2_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale2_createBy@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale2_lastUpdateBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale2_createTime@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale2_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale2_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale2_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale2_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblTransferSale2_FcExeTransferAmt@SPFieldLink:BillNo=@ValueofDB:tblTransferSale2_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale2_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale2_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale2_Remark,retCode,retVal)}</sql>
		</exec>
	</sql>
	<sql type="condition">
		<condition><select>select id as RefbillID from tblBuyInStock where BillNo=@ValueofDB:tblTransferSale2_RefBillNo</select></condition>	
		<!--更新采购入库单累计付款金额-->
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<sql type="procedure">{call proc_BuyPayAboutPay(@SqlReturn:RefbillID,tblBuyInStock,@ValueofDB:tblTransferSale2_ExeTransferAmt,add,@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>
		<!--更新销售出库累计收款金额-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select l.id as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet2 k join tblSalesOutStock l on k.RefbillID=l.BillNo where k.f_ref='@ValueofDB:tblTransferSale2_id',proc_SalesReceiveAboutRec,@RefbillID@ParamLink:'tblSalesOutStock'@ParamLink:@ExeBalAmt@ParamLink:'add'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>	 
	</sql>				 		    
</define>

<define name="tblTransferSale2_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblTransferSale2_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale2_Del_One</sql>
		</exec>
	</sql>	
</define>
<define name="tblTransferSale2_Del_One">
	<sql type="condition">
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblTransferSale2_id and workFlowNodeName='finish'</select></condition>
		<!--凭证启用了审核流，关联次单据的审核流已经审核完毕，不能修改此单 -->
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
		<!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<exec condition=" '@MEM:autoGenerateAcc'=='true'">
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblTransferSale2_id,retCode,retVal)}</sql>
		</exec>
	</sql>
  
	<!--删除转出单位的应付记录-->
	<sql type="procedure">{call proc_deleteComIni(@ValueofDB:tblTransferSale2_id,1,retCode,retVal)}</sql>	 
	<!--删除转入单位的应收记录-->
	<sql type="procedure">{call proc_deleteComIni(1@ValueofDB:tblTransferSale2_id,2,retCode,retVal)}</sql>
	<sql type="condition">
		<condition><select>select a.id as RefbillID,b.ExeTransferAmt from tblBuyInStock a,tblTransferSale2 b where b.id=@ValueofDB:tblTransferSale2_id and a.BillNo=b.RefBillNo</select></condition>	
		<!--更新采购入库单累计付款金额-->
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<sql type="procedure">{call proc_BuyPayAboutPay(@SqlReturn:RefbillID,tblBuyInStock,@SqlReturn:ExeTransferAmt,delete,@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>
		<!--更新销售出库累计收款金额-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select l.id as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet2 k join tblSalesOutStock l on k.RefbillID=l.BillNo where k.f_ref='@ValueofDB:tblTransferSale2_id',proc_SalesReceiveAboutRec,@RefbillID@ParamLink:'tblSalesOutStock'@ParamLink:@ExeBalAmt@ParamLink:'delete'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>	 
	</sql>	
</define>		
<!--========================================================以上代码：应付转应收=============================================================-->		

<!--============================================================预付转应付=============================================================-->		
<define name="tblTransferSale3_Add">
	<sql type="condition"><!--转账金额必须大于0-->
		<exec condition="@ValueofDB:tblTransferSale3_ExeTransferAmt&lt;=0">					
			<error>ChangeAmount.Bill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表关联单据编号的往来单位与转入单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difCom from tblTransferSaleDet3 a,tblBuyInStock b where a.f_ref=@ValueofDB:tblTransferSale3_id and a.RefbillID=b.id and b.CompanyCode!=@ValueofDB:tblTransferSale1_InCompanyCode</select></condition>
		<exec condition="'@SqlReturn:difCom'!='null'">
			<error>common.TransferDifCom.error,@SqlReturn:difCom</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblTransferSaleDet3 where f_ref=@ValueofDB:tblTransferSale3_id group by RefbillID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次结算金额小于等于0或者是大于待结算金额，给出错误提示-->
		<condition><select>select RefbillNo from tblTransferSaleDet3 where f_ref=@ValueofDB:tblTransferSale3_id and (ExeBalAmt&gt;WexeBalAmt or ExeBalAmt&lt;=0)</select></condition>
		<exec condition="'@SqlReturn:RefbillNo'!='null'">
			<error>tblTransferSale.add.Amt,@SqlReturn:RefbillNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--转账金额必须大于等于明细表本次结算金额合计，否则给出错误提示-->
		<condition><select>select dbo.getDigits('tblTransferSaleDet3','ExeBalAmt',isnull(sum(tblTransferSaleDet3.ExeBalAmt),0)) as SumDetAmt from tblTransferSaleDet3 where f_ref=@ValueofDB:tblTransferSale3_id</select></condition>
		<exec condition="@ValueofDB:tblTransferSale3_ExeTransferAmt&lt;@SqlReturn:SumDetAmt">
			<error>TransferSale.add.TransferAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购入库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblBuyInStock a JOIN tblTransferSaleDet3 b ON a.id=b.RefBillID WHERE b.f_ref=@ValueofDB:tblTransferSale3_id</select></condition>
		<exec condition="@SqlReturn:QuoteDateLen &gt; 0 &amp;&amp;'@ValueofDB:tblTransferSale3_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblTransferSale3_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<exec condition="true">
			<sql>update tblTransferSale3 set CertificateNo='' where id=@ValueofDB:tblTransferSale3_id</sql>
		</exec>
		<exec condition="'@MEM:tblTransferSale3_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale3_Add_One</sql>
		</exec>
	</sql>	
</define>	
<define name="tblTransferSale3_Add_One">	
	<sql type="condition">
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
    <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblTransferSale3</sql></exec> 
    <exec condition="true">		
			<!--转出单位的预付减少 影响往来（1应付 2应收 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblTransferSale3_id,@ValueofDB:tblTransferSale3_CompanyCode,3,@ValueofDB:tblTransferSale3_BillDate,PrePayTotalDebit=0@SPFieldLink:PrePayTotalLend=@ValueofDB:tblTransferSale3_ExeTransferAmt@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale3_id@SPFieldLink:BillType=tblTransferSale3@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale3_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale3_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale3_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale3_createBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale3_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale3_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale3_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale3_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale3_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale3_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=0@SPFieldLink:FcPrePayTotalCredit=@ValueofDB:tblTransferSale3_FcExeTransferAmt@SPFieldLink:BillNo=@ValueofDB:tblTransferSale3_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale3_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale3_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale3_Remark,retCode,retVal)}</sql>
			<!--转入单位的应付减少-->
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblTransferSale3_id,@ValueofDB:tblTransferSale3_InCompanyCode,1,@ValueofDB:tblTransferSale3_BillDate,PayTotalDebit=@ValueofDB:tblTransferSale3_ExeTransferAmt@SPFieldLink:PayTotalLend=0@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale3_id@SPFieldLink:BillType=tblTransferSale3@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale3_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale3_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale3_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale3_createBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale3_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale3_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale3_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale3_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale3_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale3_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblTransferSale3_FcExeTransferAmt@SPFieldLink:FcPayTotalCredit=0@ParamNum:@SPFieldLink:BillNo=@ValueofDB:tblTransferSale3_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale3_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale3_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale3_Remark,retCode,retVal)}
			</sql>
			<!--相关采购入库单的累计付款增加-->
			<sql type="procedure">{call proc_iterateExeProc(select RefbillID as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet3 where f_ref='@ValueofDB:tblTransferSale3_id',proc_BuyPayAboutPay,@RefbillID@ParamLink:'tblBuyInStock'@ParamLink:@ExeBalAmt@ParamLink:'add'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec> 
	</sql>			
</define>

<define name="tblTransferSale3_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblTransferSale3_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale3_Del_One</sql>
		</exec>
	</sql>	 
</define>
<define name="tblTransferSale3_Del_One">
	<sql type="condition"><!--凭证启用了审核流，关联此单据的审核流已经审核完毕，不能修改此单 -->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblTransferSale3_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
	</sql>
	<sql type="condition">
  <exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblTransferSale3_id,retCode,retVal)}</sql>
	</exec>
	</sql>
	<!--删除转出单位的预付记录-->
	<sql type="procedure">{call proc_deleteComIni(@ValueofDB:tblTransferSale3_id,3,retCode,retVal)}</sql>
	<!--删除转入单位的应付记录-->
	<sql type="procedure">{call proc_deleteComIni(1@ValueofDB:tblTransferSale3_id,1,retCode,retVal)}</sql>	
	<!--相关采购入库单的累计付款增加-->
	<sql type="procedure">{call proc_iterateExeProc(select RefbillID as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet3 where f_ref='@ValueofDB:tblTransferSale3_id',proc_BuyPayAboutPay,@RefbillID@ParamLink:'tblBuyInStock'@ParamLink:@ExeBalAmt@ParamLink:'delete'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
</define>
<!--===============================================以上代码：预付转应付===============================================-->

<!--=================================================应收转应付======================================================-->		 	
<define name="tblTransferSale4_Add">
	<sql type="condition"><!--转账金额必须大于0-->
		<exec condition="@ValueofDB:tblTransferSale4_ExeTransferAmt&lt;=0">					
			<error>ChangeAmount.Bill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--关联单据编号的往来单位与转出单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difComO from tblTransferSale4 a,tblSalesOutStock b where a.id=@ValueofDB:tblTransferSale4_id and a.RefBillNo=b.BillNo and b.CompanyCode!=a.CompanyCode</select></condition>
		<exec condition="'@SqlReturn:difComO'!='null'">
			<error>common.TransferDifComO.error,@SqlReturn:difComO</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表关联单据编号的往来单位与转入单位不同，给出错误提示-->
		<condition><select>select b.BillNo as difCom from tblTransferSaleDet4 a,tblBuyInStock b where a.f_ref=@ValueofDB:tblTransferSale4_id and a.RefbillID=b.BillNo and b.CompanyCode!=@ValueofDB:tblTransferSale1_InCompanyCode</select></condition>
		<exec condition="'@SqlReturn:difCom'!='null'">
			<error>common.TransferDifCom.error,@SqlReturn:difCom</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblTransferSaleDet4 where f_ref=@ValueofDB:tblTransferSale4_id group by RefbillID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次结算金额小于等于0或者是大于待结算金额，给出错误提示-->
		<condition><select>select RefbillID from tblTransferSaleDet4 where f_ref=@ValueofDB:tblTransferSale4_id and (ExeBalAmt&gt;WexeBalAmt or ExeBalAmt&lt;=0)</select></condition>
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<error>tblTransferSale.add.Amt,@SqlReturn:RefbillID</error> 
		</exec>
	</sql>
	<sql type="condition"><!--转账金额必须大于等于明细表本次结算金额合计，否则给出错误提示-->
		<condition><select>select dbo.getDigits('tblTransferSaleDet4','ExeBalAmt',isnull(sum(tblTransferSaleDet4.ExeBalAmt),0)) as SumDetAmt from tblTransferSaleDet4 where f_ref=@ValueofDB:tblTransferSale4_id</select></condition>
		<exec condition="@ValueofDB:tblTransferSale4_ExeTransferAmt&lt;@SqlReturn:SumDetAmt">
			<error>TransferSale.add.TransferAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购入库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblBuyInStock a JOIN tblTransferSaleDet4 b ON a.BillNo=b.RefBillID WHERE b.f_ref=@ValueofDB:tblTransferSale4_id</select></condition>
		<exec condition="@SqlReturn:QuoteDateLen &gt; 0 &amp;&amp;'@ValueofDB:tblTransferSale4_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblTransferSale4_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<exec condition="true">
			<sql>update tblTransferSale4 set CertificateNo='' where id=@ValueofDB:tblTransferSale4_id</sql>
		</exec>
		<exec condition="'@MEM:tblTransferSale4_IsStatart'=='0'&amp;&amp;@MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale4_Add_One</sql>
		</exec>
	</sql>
</define>
<define name="tblTransferSale4_Add_One">
	<sql type="condition">
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
    <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblTransferSale4</sql></exec> 
    <exec condition="true">
			<!--转出单位的应收减少 影响往来（1应付 2应收 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblTransferSale4_id,@ValueofDB:tblTransferSale4_CompanyCode,2,@ValueofDB:tblTransferSale4_BillDate,ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblTransferSale4_ExeTransferAmt@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale4_id@SPFieldLink:BillType=tblTransferSale4@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale4_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale4_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale4_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale4_createBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale4_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale4_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale4_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale4_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale4_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale4_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblTransferSale4_FcExeTransferAmt@SPFieldLink:BillNo=@ValueofDB:tblTransferSale4_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale4_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale4_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale4_Remark,retCode,retVal)}</sql>
			<!--转入单位的应付减少-->
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblTransferSale4_id,@ValueofDB:tblTransferSale4_InCompanyCode,1,@ValueofDB:tblTransferSale4_BillDate,PayTotalDebit=@ValueofDB:tblTransferSale4_ExeTransferAmt@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblTransferSale4_id@SPFieldLink:BillType=tblTransferSale4@SPFieldLink:PeriodYear=@ValueofDB:tblTransferSale4_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblTransferSale4_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblTransferSale4_Period@SPFieldLink:createBy=@ValueofDB:tblTransferSale4_createBy@SPFieldLink:createTime=@ValueofDB:tblTransferSale4_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblTransferSale4_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblTransferSale4_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblTransferSale4_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblTransferSale4_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblTransferSale4_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblTransferSale4_FcExeTransferAmt@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblTransferSale4_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblTransferSale4_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblTransferSale4_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblTransferSale4_Remark,retCode,retVal)}</sql>
		</exec>	
	</sql>
	<sql type="condition">
		<condition><select>select id as RefbillID from tblSalesOutStock where BillNo=@ValueofDB:tblTransferSale4_RefBillNo</select></condition>	
		<!--更新销售出库单累计收款金额-->
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<sql type="procedure">{call proc_SalesReceiveAboutRec(@SqlReturn:RefbillID,tblSalesOutStock,@ValueofDB:tblTransferSale4_ExeTransferAmt,add,@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>
		<!--更新采购入库单累计付款金额-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select l.id as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet4 k join tblBuyInStock l on k.RefbillID=l.BillNo where k.f_ref='@ValueofDB:tblTransferSale4_id',proc_BuyPayAboutPay,@RefbillID@ParamLink:'tblBuyInStock'@ParamLink:@ExeBalAmt@ParamLink:'add'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>	 
	</sql>
</define>

<define name="tblTransferSale4_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblTransferSale4_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblTransferSale4_Del_One</sql>
		</exec>
	</sql>	
</define>
<define name="tblTransferSale4_Del_One">
	<sql type="condition"><!--凭证启用了审核流，关联此单据的审核流已经审核完毕，不能修改此单 -->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblTransferSale4_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
	</sql>
    <sql type="condition">
	    <exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		    <sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblTransferSale4_id,retCode,retVal)}</sql>
	    </exec>
    </sql>
	<!--删除转出单位的应收-->
	<sql type="procedure">{call proc_deleteComIni(@ValueofDB:tblTransferSale4_id,2,retCode,retVal)}</sql>
	<!--删除转入单位的应付-->
	<sql type="procedure">{call proc_deleteComIni(1@ValueofDB:tblTransferSale4_id,1,retCode,retVal)}</sql>
	
	<sql type="condition">
		<condition><select>select a.id as RefbillID,ExeTransferAmt from tblSalesOutStock a,tblTransferSale4 b where b.id=@ValueofDB:tblTransferSale4_id and a.BillNo=b.RefBillNo</select></condition>	
		<!--更新销售出库单累计收款金额-->
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<sql type="procedure">{call proc_SalesReceiveAboutRec(@SqlReturn:RefbillID,tblSalesOutStock,@SqlReturn:ExeTransferAmt,delete,@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>
		<!--更新采购入库单累计付款金额-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select l.id as RefbillID@SPFieldLink:ExeBalAmt as ExeBalAmt from tblTransferSaleDet4 k join tblBuyInStock l on k.RefbillID=l.BillNo where k.f_ref='@ValueofDB:tblTransferSale4_id',proc_BuyPayAboutPay,@RefbillID@ParamLink:'tblBuyInStock'@ParamLink:@ExeBalAmt@ParamLink:'delete'@ParamLink:@MEM:DigitsAmount,retCode,retVal)}</sql>
		</exec>	 
	</sql>
</define>
<!--===========================================================以上代码：应收转应付==========================================================-->		

<!--===================================================采购付款单====================================================-->
<define name="tblPay_Add">
	<!--付款退款时不能选择本单-->
	<sql type="condition">
		<condition>
			<select>select RefbillID from tblPayDet where f_REf=@ValueofDB:tblPay_id and RefbillID=@ValueofDB:tblPay_id</select>
		</condition>
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<error>tblPayDet.NoSelectBill.error</error> 
		</exec>
		<exec condition=" @ValueofDB:CurrencyRate==0 ">
			<error>汇率不能为0</error> 
		</exec>
	</sql>	
	<sql type="condition">
		<!--往来结算合计小于等于0时给出提示-->
		<exec condition="@ValueofDB:tblPay_SettleAmt&lt;=0">
			<error>tblPay.settleAmt.lessZero.error</error> 
		</exec>
	</sql>
	<!--关联单据重复给出提示-->
	<sql type="condition">
		<condition>
			<select>select RefBillNo from tblpayDet where f_REf=@ValueofDB:tblPay_id group by RefBillNo,RefbillID  having COUNT(RefbillID)&gt;1</select>
		</condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>关联了重复的单据 @SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition">
		<condition>
			<select>select count(0) as detCount from tblPayDet where f_ref=@ValueofDB:tblPay_id</select>
			<select>select tblPayDet.RefBillNo cRefBillNo from tblPayDet join tblPay on tblPayDet.f_ref=tblPay.id where f_ref=@ValueofDB:tblPay_id and tblPayDet.Currency &lt;&gt; tblPay.Currency </select>
		</condition>
		
		<!--当付款类型为 “其他付款”， 但没有选择关联单据给出错误提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='OtherPay'&amp;&amp;@SqlReturn:detCount==0">
			<error>tblPay.NoSelectBill.error</error> 
		</exec>
		<exec condition=" '@SqlReturn:cRefBillNo' != 'null' ">
			<error> 付款单明细 @SqlReturn:cRefBillNo 币种与付款单不一致  </error>
		</exec>
		<!--当明细表录入数据时，判断付款类型，与付款单据是否匹配-->
		<exec condition="@SqlReturn:detCount&gt;0">
			<sql type="define">tblPay_Add_BillTypeAmt_validate</sql>
		</exec>
		<!--如果是多账户付款，判断选择了账户，没有录入金额的给出提示-->
		<exec condition="true">
			<sql type="define">tblPay_Add_ManyAccount_validate</sql>
		</exec>
	</sql>
<!--外币控制暂不做处理-->
<sql type="condition">
    <condition>
		  <select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblPay_PayBankID and SCompanyID=@ValueofDB:tblPay_SCompanyID</select>
				<!--多账户付款查询所选的付款帐户对应的科目代码、科目名、是否核算外币、核算的币种信息-->
			<select>select Account as AnyAccount from tblPayAccountDet left join tblAccTypeinfo on tblAccTypeinfo.Accnumber=tblPayAccountDet.Account where f_ref=@ValueofDB:tblPay_id and ((len(@ValueofDB:tblPay_Currency) &gt; 0 and tblAccTypeInfo.Currency!=@ValueofDB:tblPay_Currency) or (len(@ValueofDB:tblPay_Currency)=0 and len(tblAccTypeInfo.Currency)!=0))</select>
    </condition>
		<!--币种为空，付款帐户不为空时，选择的付款多帐户存在核算外币时提示-->
		<exec condition="'@SqlReturn:AnyAccount' != 'null' ">
		<!--选择的帐号不是该外币对应的帐号-->
		<error>tblAccTypeInfo.SelectCurType.error</error> 
		</exec>
		<!--如果是本位币帐户，不用录入汇率-->	
	 <exec condition=" ('@ValueofDB:tblPay_Currency'.length == 0 &amp;&amp; @ValueofDB:tblPay_CurrencyRate &gt; 0 &amp;&amp; @ValueofDB:tblPay_CurrencyRate!=1)">		
     <error>CurrencyRate.putErrors.error</error> 
	 </exec>
</sql>

	<!--=======不启用审核流时直接过账执行下列操作，启用审核流时，点击审核按钮执行下述操作=====-->
	<sql type="condition">
		<exec condition="'@MEM:tblPay_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblPay_Add_One</sql>
		</exec>
	</sql>
</define>	
<!--========判断选择了付款账户，是否输入付款金额==================-->
<define name="tblPay_Add_ManyAccount_validate">
	<!--没有选择付款账户，给出错误提示-->
	<sql type="condition">
		<condition><select>select count(0) as detCount from tblPayAccountDet where f_ref=@ValueofDB:tblPay_id</select></condition>
		<exec condition="@SqlReturn:detCount==0">
			<error>tblPay.payAccount.NoSelect.error</error> 
		</exec>
	</sql>
	<!--选择了付款账户，没有输入付款金额，给出提示-->
	<sql type="condition">
		<condition><select>select count(0) as detCount from tblPayAccountDet where f_ref=@ValueofDB:tblPay_id and Amount=0</select></condition>
		<exec condition="@SqlReturn:detCount&gt;0">
			<error>tblPay.NoInputAccAmt.error</error> 
		</exec>
	</sql>
	<!--付款账户不能有重复-->
	<sql type="condition">
		<condition><select>select 'sameAcc' as sameAcc from tblPayAccountDet where f_ref=@ValueofDB:tblPay_id group by Account having count(Account)&gt;1</select></condition>
		<exec condition="'@SqlReturn:sameAcc'=='sameAcc'">
			<error>tblPay.payAccount.same.error</error> 
		</exec>
	</sql>
</define>
<!--==============判断付款类型，与付款单据是否匹配=============-->
<define name="tblPay_Add_BillTypeAmt_validate">
	<sql type="condition">
		<condition><select>select count(0) as detCount from tblPayDet where f_ref=@ValueofDB:tblPay_id and
		((@ValueofDB:tblPay_PaytypeID='pay' and PayBillType not in ('tblBuyInStock','tblBuyReplace')) or 
		(@ValueofDB:tblPay_PaytypeID='PrePay' and PayBillType!='tblBuyOrder') or
		(@ValueofDB:tblPay_PaytypeID='RetrunPay' and PayBillType!='tblPay') or
		(@ValueofDB:tblPay_PaytypeID='ReturnReceive' and PayBillType!='tblBuyOutStock') or
		(@ValueofDB:tblPay_PaytypeID='OtherPay' and PayBillType!='tblExpensed'))</select>
		</condition>
		
		<!--选择“应付款”，关联单据可不选，如果选择后不是采购入库单给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='Pay'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblPay.Pay.selectBill.error</error> 
		</exec>
		<!--选择“预付款”，关联单据可不选，如果选择后不是采购订单给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='PrePay'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblPay.PrePay.selectBill.error</error> 
		</exec>
		<!--选择“付款退款”，如果不是选择付款单给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='RetrunPay'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblPay.RetrunPay.selectBill.error</error> 
		</exec>
		<!--选择“退货收款”，关联单据如果不是选择退货单给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='ReturnReceive'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblPay.ReturnReceive.selectBill.error</error> 
		</exec>
		<!--选择“其他付款”，关联单据如果不是选择其他付款单给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='OtherPay'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblPay.OtherPay.selectBillGM.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择的单据的单据日期是否有大于付款日期的，给出提示-->
		<condition><select>select RefBillNo from tblPayDet where f_ref=@ValueofDB:tblPay_id and RefBillDate&gt;@ValueofDB:tblPay_BillDate</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>Pay.Date.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--主表的供应商与明细表中关联单据的供应商不同时给出提示-->
		<condition><select>select RefBillNo from tblPayDet where f_ref=@ValueofDB:tblPay_id and CompanyCode!=@ValueofDB:tblPay_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>tblPay.difCom.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--启用品牌时，明细表中选择多个相同的关联单据时给出提示-->
<condition>
	  <select>select SourceID from tblPayDet where f_ref=@ValueofDB:tblPay_id group by SourceID having count(SourceID)&gt;1 and len(SourceID)&gt;0</select>
		<select>select RefbillNo from tblPayDet where f_ref=@ValueofDB:tblPay_id and len(SourceID)=0 group by RefbillNo having count(RefbillNo)&gt;1 </select>
		<select>select b.RefbillNo as RefbillNoS from tblPay a join tblPayDet b on a.id=b.f_ref where a.id=@ValueofDB:tblPay_id and a.PaytypeID in('Pay','PrePay','ReturnReceive')</select>
		</condition>
		<exec condition="'@SqlReturn:SourceID'!='null'&amp;&amp;'@MEM:productbankcontrol'=='true'">
			<error>Overlap.RefBillNo.SourceID.error</error> 
		</exec>
		<exec condition="'@SqlReturn:RefbillNo'!='null'&amp;&amp;'@MEM:productbankcontrol'=='true'">
			<error>Overlap.RefBillNo.error</error> 
		</exec>
		<exec condition="'@SqlReturn:RefbillNoS'!='null'&amp;&amp;'@MEM:productbankcontrol'=='true'">
			<error>Overlap.RefBillNo.Goods.error,@SqlReturn:RefbillNoS</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表中选择多个相同的关联单据明细时给出提示-->
		<condition>
		    <select>select SourceID from tblPayDet where f_ref=@ValueofDB:tblPay_id group by SourceID having count(SourceID)&gt;1</select>
		</condition>
		<exec condition="'@SqlReturn:SourceID'!='null'&amp;&amp;'@MEM:productbankcontrol'=='true'">
			<error>Overlap.SourceID.error</error> 
		</exec>
	</sql>	
	<!--==============判断明细表输入的本次结算金额是否合理=============-->
	<sql type="condition"><!--明细表没有输入结算金额或者小于0时给出提示-->
		<condition><select>select RefBillNo from tblPayDet where f_ref=@ValueofDB:tblPay_id and isnull(tblPayDet.ExeBalAmt,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>tblPay.settleAmt.no.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>

	<sql type="condition"><!--本次结算大于待结算时给出提示-->
		<condition><select>select RefBillNo,ExeBalAmt,WexeBalAmt from tblPayDet where f_ref=@ValueofDB:tblPay_id and isnull(ExeBalAmt,0)&gt;isnull(WexeBalAmt,0)</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			 <error>tblPayDet.PaymentMore.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition">
		<condition><select>select 'exist' as existsBill,dbo.throwZero(sum(ExeBalAmt)) as sumExeAmt,dbo.throwZero(sum(WexeBalAmt)) as sumWexeAmt,dbo.throwZero((case when @ValueofDB:tblPay_SettleAmt&gt;=sum(WexeBalAmt) then sum(WexeBalAmt)-sum(ExeBalAmt) else @ValueofDB:tblPay_SettleAmt-sum(ExeBalAmt) end)) as keepAmt from tblPayDet where f_ref=@ValueofDB:tblPay_id</select></condition>
		<!--当付款类型为其他付款，但本次结算金额与往来结算合计不相等时给出提示-->
		<exec condition="'@ValueofDB:tblPay_PaytypeID'=='OtherPay'&amp;&amp;@SqlReturn:sumExeAmt!=@ValueofDB:tblPay_SettleAmt">
			<error>tblPay.add.AccAmt.ExistError12</error> 
		</exec>
		<!--往来结算合计小于本次结算时给出提示-->
		<exec condition="@ValueofDB:tblPay_SettleAmt&lt;@SqlReturn:sumExeAmt">
			<error>PayBalance.PaymentLess.error,@SqlReturn:sumExeAmt</error> 
		</exec>
		<!--往来结算合计大于本次结算，本次结算金额小于待结算金额时给出提示-->
		<exec condition="@ValueofDB:tblPay_SettleAmt&gt;@SqlReturn:sumExeAmt&amp;&amp;@SqlReturn:sumExeAmt&lt;@SqlReturn:sumWexeAmt">
			<error>PayBalance.PaymentMid.error,@SqlReturn:keepAmt</error> 
		</exec>
	</sql>
</define>

<define name="tblPay_Add_One">
	<sql type="condition">
		<condition><select>select b.ComFullName as AccCom from tblPay a left join tblCompany b on a.CompanyCode=b.classCode where a.id=@ValueofDB:tblPay_id</select></condition>

		<!--================插入往来明细=======================-->
		<!--未启用预收预付记应收应付,为预付款时，插入往来明细，预付款借方金额=往来结算金额-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false' &amp;&amp; '@ValueofDB:tblPay_PaytypeID'== 'PrePay' &amp;&amp; @ValueofDB:tblPay_SettleAmt&gt;0">
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblPay_id,@ValueofDB:tblPay_CompanyCode,3,@ValueofDB:tblPay_BillDate,PrePayTotalDebit=@ValueofDB:tblPay_SettleAmt@ParamNum:@SPFieldLink:PrePayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblPay_id@SPFieldLink:PeriodYear=@ValueofDB:tblPay_PeriodYear@SPFieldLink:BillType=tblPay@SPFieldLink:PeriodMonth=@ValueofDB:tblPay_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblPay_Period@SPFieldLink:createBy=@ValueofDB:tblPay_createBy@SPFieldLink:createTime=@ValueofDB:tblPay_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblPay_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblPay_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblPay_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblPay_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblPay_CurrencyRate@SPFieldLink:FcPrePayTotalDebit=@ValueofDB:tblPay_CurrencyAmt@ParamNum:@SPFieldLink:FcPrePayTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblPay_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblPay_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblPay_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblPay_Remark,retCode,retVal)}</sql>
		</exec>
		<!--已启用预收预付记应收应付,为预付款时，插入往来明细，预付款借方金额=往来结算金额-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='true' &amp;&amp; '@ValueofDB:tblPay_PaytypeID'== 'PrePay'&amp;&amp;@ValueofDB:tblPay_SettleAmt&gt;0">
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblPay_id,@ValueofDB:tblPay_CompanyCode,1,@ValueofDB:tblPay_BillDate,PayTotalDebit=@ValueofDB:tblPay_SettleAmt@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblPay_id@SPFieldLink:PeriodYear=@ValueofDB:tblPay_PeriodYear@SPFieldLink:BillType=tblPay@SPFieldLink:PeriodMonth=@ValueofDB:tblPay_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblPay_Period@SPFieldLink:createBy=@ValueofDB:tblPay_createBy@SPFieldLink:createTime=@ValueofDB:tblPay_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblPay_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblPay_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblPay_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblPay_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblPay_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblPay_CurrencyAmt@ParamNum:@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblPay_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblPay_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblPay_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblPay_Remark,retCode,retVal)}</sql>
		</exec>		
		<!--为“应付款”，“其他付款”时，插入往来明细，应付款借方金额=往来结算金额-->
		<exec condition="('@ValueofDB:tblPay_PaytypeID'=='Pay'||'@ValueofDB:tblPay_PaytypeID'=='OtherPay')&amp;&amp;@ValueofDB:tblPay_SettleAmt&gt;0">
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblPay_id,@ValueofDB:tblPay_CompanyCode,1,@ValueofDB:tblPay_BillDate,PayTotalDebit=@ValueofDB:tblPay_SettleAmt@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblPay_id@SPFieldLink:PeriodYear=@ValueofDB:tblPay_PeriodYear@SPFieldLink:BillType=tblPay@SPFieldLink:PeriodMonth=@ValueofDB:tblPay_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblPay_Period@SPFieldLink:createBy=@ValueofDB:tblPay_createBy@SPFieldLink:createTime=@ValueofDB:tblPay_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblPay_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblPay_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblPay_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblPay_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblPay_CurrencyRate@SPFieldLink:FcPayTotalDebit=@ValueofDB:tblPay_CurrencyAmt@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblPay_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblPay_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblPay_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblPay_Remark,retCode,retVal)}</sql>
		</exec>
		<!--为“付款退款”，“退货收款”时，插入往来明细，应付款借方金额=-往来结算金额-->
		<exec condition="('@ValueofDB:tblPay_PaytypeID'=='RetrunPay'||'@ValueofDB:tblPay_PaytypeID'=='ReturnReceive')&amp;&amp;@ValueofDB:tblPay_SettleAmt&gt;0">
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblPay_id,@ValueofDB:tblPay_CompanyCode,1,@ValueofDB:tblPay_BillDate,PayTotalDebit=(-1)*@ValueofDB:tblPay_SettleAmt@ParamNum:@SPFieldLink:PayTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblPay_id@SPFieldLink:PeriodYear=@ValueofDB:tblPay_PeriodYear@SPFieldLink:BillType=tblPay@SPFieldLink:PeriodMonth=@ValueofDB:tblPay_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblPay_Period@SPFieldLink:createBy=@ValueofDB:tblPay_createBy@SPFieldLink:createTime=@ValueofDB:tblPay_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblPay_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblPay_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblPay_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblPay_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblPay_CurrencyRate@SPFieldLink:FcPayTotalDebit=(-1)*@ValueofDB:tblPay_CurrencyAmt@ParamNum:@SPFieldLink:FcPayTotalCredit=0@SPFieldLink:BillNo=@ValueofDB:tblPay_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblPay_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblPay_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblPay_Remark,retCode,retVal)}</sql>
		</exec>
		<!--===============回填相关单据的累积付款，待付款====================-->
		<!--不启用品牌管理时，回填订单，入库单，退货单的累积付款，收款金额-->
		<exec condition="'@MEM:productbankcontrol'!='true'">
			<sql type="procedure">{call proc_BuyPayAmort(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'">
		 	<sql type="certificate">tblPay_Acc</sql>
		</exec>
	</sql>
</define>

<!--================点击删除，修改时调用==========-->
<define name="tblPay_Del">
<!--启用审核后能修改或者删除的说明此单没有审核，不必调用此define. 不启用审核流，执行所有控制及过账操作，启用审核，点击反审核时执行此操作-->
<sql type="condition">
	<exec condition="'@MEM:tblPay_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
		<sql type="define">tblPay_Del_One</sql>
	</exec>
</sql>
</define>

<define name="tblPay_Del_One">
	<!--===========控制类判断===============-->
	<sql type="condition"><!--自动生成的单据不允许修改-->
		<condition>
			<!--拿付款单主表数据-->
			<select>select AutoBillMarker from tblPay where id=@ValueofDB:tblPay_id</select>
			<!--拿付款单明细表数据，只用于自动生成过来的明细，只有一条记录-->
			<select>select RefbillNo from tblPayDet where f_ref=@ValueofDB:tblPay_id</select>
		</condition>		
		<exec condition="@SqlReturn:AutoBillMarker==1">
			<error>DeleteBill.DelFalse.Error,@SqlReturn:RefbillNo</error> 
		</exec>
	</sql>	
	<sql type="condition"><!--存在对应的付款退款时，给出提示-->
		<condition><select>select a.BillNo as ReturnPayNo from tblPay a,tblPayDet b where a.id=b.f_ref and b.RefbillID=@ValueofDB:tblPay_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:ReturnPayNo'!='null'">
			<error>PayDel.receiveNo.error,@SqlReturn:ReturnPayNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblPay_id and  workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!='null'">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error> 
		</exec>
	</sql>
	
	<!--================逻辑操作============================-->
	<sql type="condition">
		<condition><select>select PaytypeID from tblPay where id=@ValueofDB:tblPay_id</select></condition>
		<!--不启用品牌时，回填订单，入库单，退货单的累积付款，收款金额-->
		<exec condition="'@MEM:productbankcontrol'!='true'">
			<sql type="procedure">{call proc_BuyPayAmort(@ValueofDB:tblPay_id,delete,retCode,retVal)}</sql>
		</exec>
		<!--根据是否启用预收预付记应收应付,决定删除往来明细的类型-->
		<exec condition="'@SqlReturn:PaytypeID'=='PrePay'">
			<sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblPay_id',proc_deleteComIni,@IniId@ParamLink:(case when '@MEM:prerecvpaymarktoneedrecvpay'='true' then 1 else 3 end),retCode,retVal)}</sql>
		</exec>
		<exec condition="'@SqlReturn:PaytypeID'!='PrePay'">
			<sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblPay_id',proc_deleteComIni,@IniId@ParamLink:1,retCode,retVal)}</sql>
		</exec>
    <exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblPay_id,retCode,retVal)}</sql>
		</exec>
	</sql>
</define> 
<!--===================================================以上代码：采购付款单====================================================-->



<!--==========================================================销售收款单=============================================================-->
<define name="tblSaleReceive_Add">
	<sql type="condition">
		<!--往来结算合计小于等于0，给出错误提示--> 	
		<exec condition="@ValueofDB:tblSaleReceive_ExeBalAmt&lt;=0">
			<error>tblPay.settleAmt.lessZero.error</error> 
		</exec>
		<exec condition=" @ValueofDB:CurrencyRate==0 ">
			<error>汇率不能为0</error> 
		</exec>
		<!--多账户的判断提示--> 	
		<exec condition="true">
			<sql type="define">tblReceiveManyAccount_Add_Validate</sql>
		</exec>		
	</sql>	
	<sql type="condition"><!--如果选择了代收款没有选择物流公司，或者选择了物流公司没有选择代收款，给出错误提示-->
		<condition><select>select count(0) as freCount from tblFreightCom where id=@ValueofDB:tblSaleReceive_CompanyCode</select></condition>
		<exec condition="('@ValueofDB:tblSaleReceive_AcceptTypeID'=='DeputyRec'&amp;&amp;@SqlReturn:freCount==0)||('@ValueofDB:tblSaleReceive_AcceptTypeID'!='DeputyRec'&amp;&amp;@SqlReturn:freCount&gt;0)">
			<error>tblSaleReceive.selectDeputy.error</error> 
		</exec>
	</sql>
	<!--关联单据重复给出提示-->
	<sql type="condition">
		<condition>
			<select>select RefBillNo from tblSaleReceiveDet where f_REf=@ValueofDB:tblSaleReceive_id group by RefBillNo,RefbillID having COUNT(RefbillID)&gt;1</select>
		</condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>关联了重复的单据 @SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition">
		<condition>
			<select>select count(0) as detCount from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id</select>
			<select>select tblSaleReceiveDet.RefBillNo cRefBillNo from tblSaleReceiveDet join tblSaleReceive on tblSaleReceiveDet.f_ref=tblSaleReceive.id where f_ref=@ValueofDB:tblSaleReceive_id and tblSaleReceiveDet.Currency &lt;&gt; tblSaleReceive.Currency </select>
		</condition>
		<!--当收款类型为 “其他收款”， 但没有选择关联单据给出错误提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='OtherReceive'&amp;&amp;@SqlReturn:detCount==0">
			<error>tblPay.NoSelectBill.error</error> 
		</exec>	
		<exec condition=" '@SqlReturn:cRefBillNo' != 'null' ">
			<error> 收款单明细 @SqlReturn:cRefBillNo 币种与付款单不一致  </error>
		</exec>	
		<exec condition="@SqlReturn:detCount&gt;0">
			<!--当明细表录入数据时，判断收款类型，与收款单据是否匹配-->
			<sql type="define">tblReceive_Add_BillType_validate</sql>
			<!--关于结算金额的验证-->
			<sql type="define">tblReceive_Add_ExeBalAmt_validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--当收款类型为 “代收款”时，必须关联单据编号-->
		<condition><select> select count(0) as detCount from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id</select></condition>
		<exec condition="'@SqlReturn:detCount'=='0'&amp;&amp;'@ValueofDB:tblSaleReceive_AcceptTypeID'=='DeputyRec'">
			<error>tblPay.NoSelectBill.error</error> 
		</exec>		
	</sql>	
	<!--外币控制暂不做处理-->
	<sql type="condition">
		<condition>
			<select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblSaleReceive_AcceptBankID and  SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID</select>
			<select> select zh_CN as AnyAccount2 from tblReceiveAccountDet left join tblAccTypeinfo on tblAccTypeinfo.Accnumber=tblReceiveAccountDet.Account left join tbllanguage on tblAccTypeinfo.AccFullName=tbllanguage.id  where f_ref=@ValueofDB:id and len(@ValueofDB:Currency) &gt; 0 and     tblAccTypeInfo.Currency!=@ValueofDB:Currency and tblAccTypeinfo.IsForCur !=1   </select>
			<!--多账户付款查询所选的付款帐户对应的科目代码、科目名、是否核算外币、核算的币种信息-->
			<select>select Account as AnyAccount from tblReceiveAccountDet left join tblAccTypeinfo on tblAccTypeinfo.Accnumber=tblReceiveAccountDet.Account where f_ref=@ValueofDB:id and ((len(@ValueofDB:Currency) &gt; 0 and  (len(isnull(tblAccTypeInfo.Currency,'')) !=0 and   tblAccTypeInfo.Currency!=@ValueofDB:Currency ) ) or (len(@ValueofDB:Currency)=0 and len(tblAccTypeInfo.Currency)!=0))</select>
		</condition>
		<!--币种为空，付款帐户不为空时，选择的付款多帐户存在核算外币时提示-->
		<exec condition="'@SqlReturn:AnyAccount2' != 'null' ">
			<!--选择的帐号不是该外币对应的帐号-->
			<error> @SqlReturn:AnyAccount2 不是外币核算科目  </error> 
		</exec>
		<!--币种为空，付款帐户不为空时，选择的付款多帐户存在核算外币时提示-->
		<exec condition="'@SqlReturn:AnyAccount' != 'null' ">
			<!--选择的帐号不是该外币对应的帐号-->
			<error>tblAccTypeInfo.SelectCurType.error</error> 
		</exec>
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblSaleReceive_Currency'.length == 0 &amp;&amp; @ValueofDB:tblSaleReceive_CurrencyRate &gt; 0 &amp;&amp; @ValueofDB:tblSaleReceive_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error> 
		</exec>
		<exec condition="true">
			<sql>update tblTransferSale1 set CertificateNo='' where id=@ValueofDB:tblBuyOrder_id</sql>
		</exec>
		<!--不启用审核流时直接执行过账操作-->
		<exec condition="'@MEM:tblSaleReceive_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSaleReceive_Add_One</sql>
		</exec>
	</sql>
</define>
<!--====多账户收款判断=====-->
<define name="tblReceiveManyAccount_Add_Validate">	
	<sql type="condition"><!--没有选择收款账户，给出错误提示-->
		<condition><select>select count(0) AccountC from tblReceiveAccountDet where f_ref=@ValueofDB:tblSaleReceive_id</select></condition>
		<exec condition="@SqlReturn:AccountC==0">
			<error>sales.ReceiveAccCode.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--选择收款账户，没有输入收款金额，给出错误提示-->
		<condition><select>select count(0) zeroAmt from tblReceiveAccountDet where f_ref=@ValueofDB:tblSaleReceive_id and len(Account)&gt;0 and Amount=0</select></condition>
		<exec condition="@SqlReturn:zeroAmt&gt;0">
			<error>common.AccountAmt.input.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--收款账户不能有重复-->
		<condition><select>select 'sameAcc' as sameAcc from tblReceiveAccountDet where f_ref=@ValueofDB:tblSaleReceive_id group by Account having count(Account)&gt;1</select></condition>
		<exec condition="'@SqlReturn:sameAcc'=='sameAcc'">
			<error>sales.ReceiveAccCode.same.error</error> 
		</exec>
	</sql>
</define>
<!--==============判断收款类型，与收款单据是否匹配=============-->
<define name="tblReceive_Add_BillType_validate">
	<sql type="condition">
		<condition><select>select count(0) as detCount from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id and
		((@ValueofDB:tblSaleReceive_AcceptTypeID='Receive' and ReceiveBillType not in ('tblSalesOutStock','tblSalesReplace')) or 
		(@ValueofDB:tblSaleReceive_AcceptTypeID='PreReceive' and ReceiveBillType!='tblSalesOrder') or
		(@ValueofDB:tblSaleReceive_AcceptTypeID='RetrunReceive' and ReceiveBillType!='tblSaleReceive') or
		(@ValueofDB:tblSaleReceive_AcceptTypeID='ReturnPay' and ReceiveBillType!='tblSalesReturnStock') or
		(@ValueofDB:tblSaleReceive_AcceptTypeID='OtherReceive' and ReceiveBillType!='tblIncome'))</select>
		</condition>
		<!--选择“应收款”，关联单据可不选，如果选择后不是销售出库单给出提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='Receive'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblReceive.Receive.selectBill.error</error> 
		</exec>
		<!--选择“预收款”，关联单据可不选，如果选择后不是销售订单给出提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='PreReceive'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblReceive.PreReceive.selectBill.error</error> 
		</exec>
		<!--选择“收款退款”，如果不是选择收款单给出提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='RetrunReceive'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblReceive.RetrunReceive.selectBill.error</error> 
		</exec>
		<!--选择“退货付款”，关联单据如果不是选择退货单给出提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='ReturnPay'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblReceive.ReturnPay.selectBill.error</error> 
		</exec>
		<!--选择“其他收款”，关联单据如果不是选择其他收款单给出提示-->
		<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='OtherReceive'&amp;&amp;@SqlReturn:detCount&gt;0">
			<error>tblReceive.OtherReceive.selectBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--收款退款时不能选择本单-->
		<condition><select>select RefbillID from tblSaleReceiveDet where f_REf=@ValueofDB:tblSaleReceive_id and RefbillID=@ValueofDB:tblSaleReceive_id</select></condition>
		<exec condition="'@SqlReturn:RefbillID'!='null'">
			<error>tblSaleReceiveDet.NoSelectBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择单据的单据日期是否有大于收款日期的，给出提示-->
		<condition><select>select RefBillNo,RefBillDate from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id and RefBillDate&gt;@ValueofDB:tblSaleReceive_BillDate</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>tblSaleReceive.Date.error,@SqlReturn:RefBillNo,@SqlReturn:RefBillDate</error> 
		</exec>
	</sql>
	<sql type="condition"><!--主表的供应商与明细表中关联单据的供应商不同时给出提示-->
		<condition><select>select RefBillNo from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id and CompanyCode!=@ValueofDB:tblSaleReceive_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>tblSaleReceive.difCom.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
</define>
	
<!--==============判断明细表输入的本次结算金额是否合理=============-->
<define name="tblReceive_Add_ExeBalAmt_validate">
	<sql type="condition"><!--明细表没有输入结算金额或者小于0时给出提示-->
		<condition><select>select RefBillNo from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id and isnull(tblSaleReceiveDet.ExeBalAmt,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			<error>tblPay.settleAmt.no.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--本次结算大于待结算时给出提示-->
		<condition><select>select RefBillNo,ExeBalAmt,WexeBalAmt from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id and isnull(ExeBalAmt,0)&gt;isnull(WexeBalAmt,0)</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">
			 <error>tblPayDet.PaymentMore.error,@SqlReturn:RefBillNo</error> 
		</exec>
	</sql>
	<sql type="condition">
		<condition><select>select 'exist' as existsBill,dbo.throwZero(sum(ExeBalAmt)) as sumExeAmt,sum(WexeBalAmt) as sumWexeAmt,(case when @ValueofDB:tblSaleReceive_ExeBalAmt&gt;=sum(WexeBalAmt) then dbo.getDigits('tblSaleReceive','ExeBalAmt',sum(WexeBalAmt)-sum(ExeBalAmt)) else dbo.getDigits('tblSaleReceive','ExeBalAmt',@ValueofDB:tblSaleReceive_ExeBalAmt-sum(ExeBalAmt)) end) as keepAmt from tblSaleReceiveDet where f_ref=@ValueofDB:tblSaleReceive_id</select></condition>
		<!--当收款类型为其他收款，但本次结算金额与往来结算合计不相等时给出提示-->
		<exec condition="('@ValueofDB:tblSaleReceive_AcceptTypeID'=='OtherReceive'||'@ValueofDB:tblSaleReceive_AcceptTypeID'=='DeputyRec')&amp;&amp;@SqlReturn:sumExeAmt!=@ValueofDB:tblSaleReceive_ExeBalAmt">
			<error>tblSaleReceive.add.AccAmt.ExistError12</error> 
		</exec>
		<!--往来结算合计小于本次结算时给出提示-->
		<exec condition="@ValueofDB:tblSaleReceive_ExeBalAmt&lt;@SqlReturn:sumExeAmt">
			<error>PayBalance.PaymentLess.error,@SqlReturn:sumExeAmt</error> 
		</exec>
		<!--往来结算合计大于本次结算，本次结算金额小于待结算金额时给出提示-->
		<exec condition="@ValueofDB:tblSaleReceive_ExeBalAmt&gt;@SqlReturn:sumExeAmt&amp;&amp;@SqlReturn:sumExeAmt&lt;@SqlReturn:sumWexeAmt">
			<error>PayBalance.PaymentMid.error,@SqlReturn:keepAmt</error> 
		</exec>
	</sql>
</define>

<define name="tblSaleReceive_Add_One">
<sql type="condition">
	<condition>
		<!--查询往来单位的名称，便于在后续使用-->
		<select>select b.ComFullName as AccCom from tblSaleReceive a left join tblCompany b on a.CompanyCode=b.classCode where a.id=@ValueofDB:tblPay_id</select>
	</condition>
	<!--插入往来明细 贷：应收款-->
	<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='Receive'||'@ValueofDB:tblSaleReceive_AcceptTypeID'=='OtherReceive'">
		<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSaleReceive_id,@ValueofDB:tblSaleReceive_CompanyCode,2,@ValueofDB:tblSaleReceive_BillDate,ReceiveTotalLend=@ValueofDB:tblSaleReceive_ExeBalAmt@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:RelationDocID=@ValueofDB:tblSaleReceive_id@SPFieldLink:PeriodYear=@ValueofDB:tblSaleReceive_PeriodYear@SPFieldLink:BillType=tblSaleReceive@SPFieldLink:PeriodMonth=@ValueofDB:tblSaleReceive_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblSaleReceive_Period@SPFieldLink:createBy=@ValueofDB:tblSaleReceive_createBy@SPFieldLink:createTime=@ValueofDB:tblSaleReceive_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSaleReceive_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSaleReceive_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSaleReceive_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSaleReceive_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSaleReceive_BillFcAmt@SPFieldLink:BillNo=@ValueofDB:tblSaleReceive_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSaleReceive_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSaleReceive_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblSaleReceive_Remark,retCode,retVal)}</sql>
	</exec>
	<!--收款类型为代收款，根据单据明细插入往来明细 贷：应收款-->
	<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='DeputyRec'">
		<sql type="procedure">{call proc_iterateExeProc(select substring(replace(newid()@RepComma:'-'@RepComma:'')@RepComma:1@RepComma:30) as id@SPFieldLink:b.CompanyCode as CompanyCode@SPFieldLink:sum(a.ExeBalAmt) as ExeBalAmt@SPFieldLink:sum(a.ExeBalFcAmt) as ExeBalFcAmt from tblSaleReceiveDet a@SPFieldLink:tblSalesOutStock b where a.f_ref='@ValueofDB:tblSaleReceive_id' and a.RefbillID=b.id group by b.CompanyCode,proc_insertComIni,@id@ParamLink:@CompanyCode@ParamLink:2@ParamLink:'@ValueofDB:tblSaleReceive_BillDate'@ParamLink:'ReceiveTotalLend='+@ExeBalAmt+'@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:RelationDocID=@ValueofDB:tblSaleReceive_id@SPFieldLink:PeriodYear=@ValueofDB:tblSaleReceive_PeriodYear@SPFieldLink:BillType=tblSaleReceive@SPFieldLink:PeriodMonth=@ValueofDB:tblSaleReceive_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblSaleReceive_Period@SPFieldLink:createBy=@ValueofDB:tblSaleReceive_createBy@SPFieldLink:createTime=@ValueofDB:tblSaleReceive_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSaleReceive_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSaleReceive_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSaleReceive_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSaleReceive_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit='+@ExeBalFcAmt+'@SPFieldLink:BillNo=@ValueofDB:tblSaleReceive_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSaleReceive_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSaleReceive_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblSaleReceive_Remark',retCode,retVal)}
		</sql>
	</exec>
	<!--插入往来明细 贷：应收款(负)-->
	<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='ReturnPay'||'@ValueofDB:tblSaleReceive_AcceptTypeID'=='RetrunReceive'">
		<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSaleReceive_id,@ValueofDB:tblSaleReceive_CompanyCode,2,@ValueofDB:tblSaleReceive_BillDate,ReceiveTotalLend=-1*@ValueofDB:tblSaleReceive_ExeBalAmt@ParamNum:@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:RelationDocID=@ValueofDB:tblSaleReceive_id@SPFieldLink:PeriodYear=@ValueofDB:tblSaleReceive_PeriodYear@SPFieldLink:BillType=tblSaleReceive@SPFieldLink:PeriodMonth=@ValueofDB:tblSaleReceive_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblSaleReceive_Period@SPFieldLink:createBy=@ValueofDB:tblSaleReceive_createBy@SPFieldLink:createTime=@ValueofDB:tblSaleReceive_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSaleReceive_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSaleReceive_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSaleReceive_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSaleReceive_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=-1*@ValueofDB:tblSaleReceive_BillFcAmt@ParamNum:@SPFieldLink:BillNo=@ValueofDB:tblSaleReceive_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSaleReceive_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSaleReceive_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblSaleReceive_Remark,retCode,retVal)}</sql>
	</exec>
	<!--未启用预收预付记应收应付,插入往来明细 贷：预收款-->
	<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false' &amp;&amp; '@ValueofDB:tblSaleReceive_AcceptTypeID'=='PreReceive'">	
		<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSaleReceive_id,@ValueofDB:tblSaleReceive_CompanyCode,4,@ValueofDB:tblSaleReceive_BillDate,PreReceiveTotalLend=@ValueofDB:tblSaleReceive_ExeBalAmt@ParamNum:@SPFieldLink:PreReceiveTotalDebit=0@SPFieldLink:RelationDocID=@ValueofDB:tblSaleReceive_id@SPFieldLink:PeriodYear=@ValueofDB:tblSaleReceive_PeriodYear@SPFieldLink:BillType=tblSaleReceive@SPFieldLink:PeriodMonth=@ValueofDB:tblSaleReceive_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblSaleReceive_Period@SPFieldLink:createBy=@ValueofDB:tblSaleReceive_createBy@SPFieldLink:createTime=@ValueofDB:tblSaleReceive_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSaleReceive_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSaleReceive_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSaleReceive_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSaleReceive_CurrencyRate@SPFieldLink:FcPreRecTotalDebit=0@SPFieldLink:FcPreRecTotalCredit=@ValueofDB:tblSaleReceive_BillFcAmt@ParamNum:@SPFieldLink:BillNo=@ValueofDB:tblSaleReceive_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSaleReceive_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSaleReceive_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblSaleReceive_Remark,retCode,retVal)}</sql>
	</exec>
	<!--已启用预收预付记应收应付,插入往来明细 贷：应收款-->
	<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='true' &amp;&amp; '@ValueofDB:tblSaleReceive_AcceptTypeID'=='PreReceive'">	
		<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSaleReceive_id,@ValueofDB:tblSaleReceive_CompanyCode,2,@ValueofDB:tblSaleReceive_BillDate,ReceiveTotalLend=@ValueofDB:tblSaleReceive_ExeBalAmt@ParamNum:@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:RelationDocID=@ValueofDB:tblSaleReceive_id@SPFieldLink:PeriodYear=@ValueofDB:tblSaleReceive_PeriodYear@SPFieldLink:BillType=tblSaleReceive@SPFieldLink:PeriodMonth=@ValueofDB:tblSaleReceive_PeriodMonth@SPFieldLink:Period=@ValueofDB:tblSaleReceive_Period@SPFieldLink:createBy=@ValueofDB:tblSaleReceive_createBy@SPFieldLink:createTime=@ValueofDB:tblSaleReceive_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSaleReceive_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSaleReceive_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSaleReceive_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSaleReceive_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSaleReceive_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSaleReceive_BillFcAmt@ParamNum:@SPFieldLink:BillNo=@ValueofDB:tblSaleReceive_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSaleReceive_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSaleReceive_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblSaleReceive_Remark,retCode,retVal)}</sql>
	</exec>
	<!--不启用品牌管理时，回填单据的累积付款，累积收款-->
	<exec condition="'@MEM:productbankcontrol'!='true'">
		<sql type="procedure">{call proc_SalesReceiveAmort(@ValueofDB:tblSaleReceive_id,add,retCode,retVal)}</sql>
	</exec>
	<!--收款类型：代收款，明细表选择的销售出库的已代收金额+本次代收金额-->
	<exec condition="'@ValueofDB:tblSaleReceive_AcceptTypeID'=='DeputyRec'">
		<sql>update tblSalesOutStock set hashDeputyReceAmt=hashDeputyReceAmt+a.ExeBalAmt,curhashDeputyReceAmt=curhashDeputyReceAmt+a.ExeBalFcAmt from tblSaleReceiveDet a where a.f_ref=@ValueofDB:tblSaleReceive_id and tblSalesOutStock.id=a.RefbillID</sql>
	</exec>
	<!--如果启用“自动产生凭证”，则自动插入凭证-->
	<exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblSaleReceive</sql></exec>	
</sql>
</define>

<!--==========删除销售收款单==========-->  
<define name="tblSaleReceive_Del">
	<sql type="condition"><!--不启用审核流,直接过账-->
		<exec condition="'@MEM:tblSaleReceive_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSaleReceive_Del_One</sql>
		</exec>
	</sql>	
</define>
<define name="tblSaleReceive_Del_One">
	<sql type="condition"><!--自动生成的单据不允许修改-->
		<condition>
		    <select>select AutoBillMarker,RefbillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=@ValueofDB:tblSaleReceive_id and a.id=b.f_ref</select>
	    </condition>		
		<exec condition="@SqlReturn:AutoBillMarker==1">
			<error>DeleteBill.DelFalse.Error,@SqlReturn:RefbillNo</error> 
		</exec>
	</sql>	
	<sql type="condition"><!--存在对应的收款退款时，给出提示-->
		<condition><select>select a.BillNo as ReturnPayNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and b.RefbillID=@ValueofDB:tblSaleReceive_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:ReturnPayNo'!='null'">
			<error>ReceiveDel.receiveNo.error,@SqlReturn:ReturnPayNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblSaleReceive_id and  workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!='null'">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error> 
		</exec>
	</sql>
	<!--删除本单据的多条往来记录（1应付 2应收 3预付 4预收-->
	<sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblSaleReceive_id',proc_deleteComIni,@IniId@ParamLink:2,retCode,retVal)}</sql>
	<sql type="condition"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<exec condition=" '@MEM:autoGenerateAcc'=='true'">
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblSaleReceive_id,retCode,retVal)}</sql>
		</exec>
	</sql>
	<sql type="condition">
		<condition><select>select AcceptTypeID from tblSaleReceive WHERE id=@ValueofDB:tblSaleReceive_id</select></condition>
		<!--不启用品牌管理时，回填单据的累积付款，累积收款-->
		<exec condition="'@MEM:productbankcontrol'!='true'">
			<sql type="procedure">{call proc_SalesReceiveAmort(@ValueofDB:tblSaleReceive_id,delete,retCode,retVal)}</sql>  
		</exec>
		<!--收款类型：代收款，明细表选择的销售出库的已代收金额+本次代收金额-->
		<exec condition="'@SqlReturn:AcceptTypeID'=='DeputyRec'">
			<sql>update tblSalesOutStock set hashDeputyReceAmt=hashDeputyReceAmt-a.ExeBalAmt,CurhashDeputyReceAmt=CurhashDeputyReceAmt-a.ExeBalFcAmt from tblSaleReceiveDet a where a.f_ref=@ValueofDB:tblSaleReceive_id and tblSalesOutStock.id=a.RefbillID</sql>
		</exec>
	</sql>
	
</define>
<!--===================================================以上代码：销售收款单==========================================================-->

<!--============================================================应收调账单========================================================-->	
<define name="tblAccAdjust_Add">
	<sql type="condition"><!--调账金额必须大于0-->
		<exec condition="@ValueofDB:tblAccAdjust_TotalAmount&lt;=0">					
			<error>common.AdjustAmount.error</error> 
		</exec>
		<exec condition="@ValueofDB:CurrencyRate == 0">					
			<error>汇率不能等于0</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblAccAdjustDet where f_ref=@ValueofDB:tblAccAdjust_id group by RefBillID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次调账金额小于等于0，给出错误提示-->
		<condition><select>select RefbillNo from tblAccAdjustDet where f_ref=@ValueofDB:tblAccAdjust_id and Amount&lt;=0</select></condition>
		<exec condition="'@SqlReturn:RefbillNo'!='null'">
			<error>common.AdjustDetAmount.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--调账金额必须大于等于明细表本次调账金额合计，否则给出错误提示-->
		<condition><select>select isnull(dbo.getDigits('tblPayAdjustDet','Amount',sum(Amount)),0) as SumDetAmt from tblAccAdjustDet where f_ref=@ValueofDB:tblAccAdjust_id</select></condition>
		<exec condition="@ValueofDB:tblAccAdjust_TotalAmount&lt;@SqlReturn:SumDetAmt">
			<error>common.AdjustLettDetAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--关联单据币种必须与主表一致-->
		<condition><select>select count(0) notSameCurrency from tblAccAdjustDet join tblSalesOutStock on tblAccAdjustDet.RefBillID=tblSalesOutStock.id   where f_ref=@ValueofDB:tblAccAdjust_id and tblSalesOutStock.Currency &lt;&gt; @ValueofDB:Currency  </select></condition>
		<exec condition="  @SqlReturn:notSameCurrency &gt;0  ">
			<error>明细单据币种必须与所选币种一致</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(销售出库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblSalesOutStock a JOIN tblAccAdjustDet b ON a.id=b.RefBillID WHERE b.f_ref=@ValueofDB:tblAccAdjust_id</select></condition>
		<exec condition="@SqlReturn:QuoteDateLen &gt; 0 &amp;&amp;'@ValueofDB:tblAccAdjust_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblAccAdjust_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<condition>
           <select>select 'Exists' as ExistsErrorType0 from tblBillAccSetup a where a.MainType='tblAccAdjustLess' and a.SubCode=@ValueofDB:tblAccAdjust_SubCode</select>
           <select>select 'Exists' as ExistsErrorType1 from tblBillAccSetup a where a.MainType='tblAccAdjustMore' and a.SubCode=@ValueofDB:tblAccAdjust_SubCode</select>
        </condition>
		<!--未选择调账类型则后台更新应付调减默认为采购优惠应付调增的默认为应付增加-->
		<exec condition="('@ValueofDB:tblAccAdjust_AdjustType'=='0'&amp;&amp;('@ValueofDB:tblAccAdjust_SubCode'==''||'@SqlReturn:ExistsErrorType0'!='Exists'))">
			<sql>update tblAccAdjust set SubCode='671106' where id=@ValueofDB:tblAccAdjust_id</sql>
		</exec>
		<exec condition="('@ValueofDB:tblAccAdjust_AdjustType'=='1' &amp;&amp;('@ValueofDB:tblAccAdjust_SubCode'==''||'@SqlReturn:ExistsErrorType1'!='Exists'))">
			<sql>update tblAccAdjust set SubCode='630107' where id=@ValueofDB:tblAccAdjust_id</sql>
		</exec>	
		<exec condition="true">
			<sql>update tblAccAdjust set CertificateNo='' where id=@ValueofDB:tblAccAdjust_id</sql>
		</exec>
		<exec condition="'@MEM:tblAccAdjust_IsStatart' == '0'">
			<sql type="define">tblAccAdjust_Add_One</sql>
		</exec>
	</sql>
</define>
		
<define name="tblAccAdjust_Add_One">
	<sql type="condition">
    <!--如果启用“自动产生凭证”，则自动插入凭证-->
    <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblAccAdjust</sql></exec>
		<exec condition="true">
			<!-- 往来单位明细 （1应付 2应付 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblAccAdjust_id,@ValueofDB:tblAccAdjust_CompanyCode,2,@ValueofDB:tblAccAdjust_BillDate,Period=@ValueofDB:tblAccAdjust_Period@SPFieldLink:PeriodYear=@ValueofDB:tblAccAdjust_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblAccAdjust_PeriodMonth@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:ReceiveTotalDebit=(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*@ValueofDB:tblAccAdjust_TotalAmount@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblAccAdjust_id@SPFieldLink:Currency=@ValueofDB:tblAccAdjust_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblAccAdjust_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblAccAdjust_createBy@SPFieldLink:createTime=@ValueofDB:tblAccAdjust_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblAccAdjust_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblAccAdjust_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblAccAdjust_SCompanyID@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:FcRecTotalDebit=(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*@ValueofDB:tblAccAdjust_CurTotalAmount@ParamNum:@SPFieldLink:BillType=tblAccAdjust@SPFieldLink:BillNo=@ValueofDB:tblAccAdjust_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblAccAdjust_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblAccAdjust_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblAccAdjust_Remark,retCode,retVal)}</sql>
			<!--更新明细表中销售出库单的待收款金额,调价后金额-->
			<sql>update tblSalesOutStock set NeedReturnAmt=NeedReturnAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,AfterChangeAmt=AfterChangeAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,ChangeAmt=ChangeAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,CurNeedReturnAmt=CurNeedReturnAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount,CurAfterChangeAmt=CurAfterChangeAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount,CurChangeAmt=CurChangeAmt+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount,NoInvoiceAmount=NoInvoiceAmount+(case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.Amount from tblAccAdjustDet k where k.f_ref=@ValueofDB:tblAccAdjust_id and k.RefBillID=tblSalesOutStock.id</sql>
			<!--更新明细表中销售出库单的明细表调价后金额-->
			<sql>update tblSalesOutStockDet set AfterChangeAmt=AfterChangeAmt+case when (select sum(TaxAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)=0 then 0 else dbo.getDigits('tblSalesOutStockDet','AfterChangeAmt',((case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.Amount)*TaxAmount/(select sum(TaxAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)) end ,CurAfterChangeAmt=CurAfterChangeAmt+case when (select sum(t.CurAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)=0 then 0 else dbo.getDigits('tblSalesOutStockDet','AfterChangeAmt',((case when @ValueofDB:tblAccAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount)*tblSalesOutStockDet.CurAmount/(select sum(CurAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)) end from tblAccAdjustDet k where k.f_ref=@ValueofDB:tblAccAdjust_id and k.RefBillID=tblSalesOutStockDet.f_ref</sql>
		 </exec>
	</sql>				 		    
</define>
<define name="tblAccAdjust_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblAccAdjust_IsStatart' == '0'">
			<sql type="define">tblAccAdjust_Del_One</sql>
		</exec>
	</sql>	
</define>

<define name="tblAccAdjust_Del_One">
	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblAccAdjust_id and  workFlowNodeName='finish'</select></condition>
		<exec condition="&quot;@SqlReturn:OrderNo&quot;!=&quot;null&quot;">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!-- 删除往来明细:修改类型（1应付 2应收 3预付 4预收） -->
		<condition><select>select id as IniId from tblCompanyIni where relationDocID=@ValueofDB:tblAccAdjust_id</select></condition>
		<exec condition="true">
			<sql type="procedure">{call proc_deleteComIni(@SqlReturn:IniId,2,retCode,retVal)}</sql>
		</exec>
	</sql>
	<sql type="condition"><!--更新明细表中采购入库单的待付款金额,调价后金额-->
		<condition><select>select AdjustType from tblAccAdjust where id=@ValueofDB:tblAccAdjust_id</select></condition>
		<exec condition="true">
			<sql>update tblSalesOutStock set NeedReturnAmt=NeedReturnAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,AfterChangeAmt=AfterChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,ChangeAmt=ChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,CurNeedReturnAmt=CurNeedReturnAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount,CurAfterChangeAmt=CurAfterChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount,CurChangeAmt=CurChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount,NoInvoiceAmount=NoInvoiceAmount-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount from tblAccAdjustDet k where k.f_ref=@ValueofDB:tblAccAdjust_id and k.RefBillID=tblSalesOutStock.id</sql> 
			<!--更新明细表中销售出库单的明细表调价后金额-->
			<sql>update tblSalesOutStockDet set AfterChangeAmt=AfterChangeAmt-case when (select sum(TaxAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)=0 then 0 else dbo.getDigits('tblSalesOutStockDet','AfterChangeAmt',((case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount)*TaxAmount/(select sum(TaxAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)) end ,CurAfterChangeAmt=CurAfterChangeAmt-case when (select sum(CurAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)=0 then 0 else dbo.getDigits('tblSalesOutStockDet','AfterChangeAmt',((case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount)*tblSalesOutStockDet.CurAmount/(select sum(CurAmount) from tblSalesOutStockDet t where t.f_ref=tblSalesOutStockDet.f_ref)) end from tblAccAdjustDet k where k.f_ref=@ValueofDB:tblAccAdjust_id and k.RefBillID=tblSalesOutStockDet.f_ref</sql>
		</exec>
	</sql>
	<sql type="condition">
		<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblAccAdjust_id,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>	
<!--======================================================应付调帐单==========================================================-->	
<define name="tblPayAdjust_Add">
	<sql type="condition"><!--调账金额必须大于0-->
		<exec condition="@ValueofDB:tblPayAdjust_TotalAmount&lt;=0">					
			<error>common.AdjustAmount.error</error> 
		</exec>
		<exec condition="@ValueofDB:CurrencyRate == 0">					
			<error>汇率不能等于0</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表如果出现重复的关联单据，给出错误提示-->
		<condition><select>select COUNT(0) as billC from tblPayAdjustDet where f_ref=@ValueofDB:tblPayAdjust_id group by RefBillID having COUNT(0)&gt;1</select></condition>
		<exec condition="@SqlReturn:billC&gt;0">
			<error>common.sameBill.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的本次调账金额小于等于0，给出错误提示-->
		<condition><select>select RefbillNo from tblPayAdjustDet where f_ref=@ValueofDB:tblPayAdjust_id and Amount&lt;=0</select></condition>
		<exec condition="'@SqlReturn:RefbillNo'!='null'">
			<error>common.AdjustDetAmount.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--调账金额必须大于等于明细表本次调账金额合计，否则给出错误提示-->
		<condition><select>select dbo.getDigits('tblPayAdjustDet','Amount',isnull(sum(Amount),0)) as SumDetAmt from tblPayAdjustDet where f_ref=@ValueofDB:tblPayAdjust_id</select></condition>
		<exec condition="@ValueofDB:tblPayAdjust_TotalAmount&lt;@SqlReturn:SumDetAmt">
			<error>common.AdjustLettDetAmt.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--关联单据币种必须与主表一致-->
		<condition><select>select count(0) notSameCurrency from tblPayAdjustDet join tblBuyInStock on tblPayAdjustDet.RefBillID=tblBuyInStock.id   where f_ref=@ValueofDB:tblPayAdjust_id and tblBuyInStock.Currency &lt;&gt; @ValueofDB:Currency  </select></condition>
		<exec condition="  @SqlReturn:notSameCurrency &gt;0  ">
			<error>明细单据币种必须与所选币种一致</error> 
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(采购入库)-->
		<condition><select>SELECT a.BillDate AS QuoteDate, len(isnull(a.BillDate,'')) as QuoteDateLen FROM tblBuyInStock a JOIN tblPayAdjustDet b ON a.id=b.RefBillID WHERE b.f_ref=@ValueofDB:tblPayAdjust_id</select></condition>
		<exec condition="@SqlReturn:QuoteDateLen &gt; 0 &amp;&amp;'@ValueofDB:tblPayAdjust_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblPayAdjust_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<condition>
          <select>select 'Exists' as ExistsErrorType0 from tblBillAccSetup a where a.MainType='tblPayAdjustLess' and a.SubCode=@ValueofDB:tblPayAdjust_SubCode</select>
          <select>select 'Exists' as ExistsErrorType1 from tblBillAccSetup a where a.MainType='tblPayAdjustMore' and a.SubCode=@ValueofDB:tblPayAdjust_SubCode</select>
        </condition>
		<!--未选择调账类型则后台更新应付调减默认为采购优惠应付调增的默认为应付增加-->
		<exec condition="('@ValueofDB:tblPayAdjust_AdjustType'=='0'&amp;&amp;('@ValueofDB:tblPayAdjust_SubCode'==''||'@SqlReturn:ExistsErrorType0'!='Exists'))">
			<sql>update tblPayAdjust set SubCode='630108' where id=@ValueofDB:tblPayAdjust_id</sql>
		</exec>
		<exec condition="('@ValueofDB:tblPayAdjust_AdjustType'=='1' &amp;&amp;('@ValueofDB:tblPayAdjust_SubCode'==''||'@SqlReturn:ExistsErrorType1'!='Exists'))">
			<sql>update tblPayAdjust set SubCode='671105' where id=@ValueofDB:tblPayAdjust_id</sql>
		</exec>
		<exec condition="true">
			<sql>update tblPayAdjust set CertificateNo='' where id=@ValueofDB:tblPayAdjust_id</sql>
		</exec>
		<exec condition="'@MEM:tblPayAdjust_IsStatart' == '0'">
			<sql type="define">tblPayAdjust_Add_One</sql>
		</exec>
	</sql>
</define>
<define name="tblPayAdjust_Add_One">
	<sql type="condition">
		<!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblPayAdjust</sql></exec>
		<exec condition="true">
			<!-- 往来单位明细 （1应付 2应付 3预付 4预收）-->
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblPayAdjust_id,@ValueofDB:tblPayAdjust_CompanyCode,1,@ValueofDB:tblPayAdjust_BillDate,Period=@ValueofDB:tblPayAdjust_Period@SPFieldLink:PeriodYear=@ValueofDB:tblPayAdjust_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblPayAdjust_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*@ValueofDB:tblPayAdjust_TotalAmount@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblPayAdjust_id@SPFieldLink:Currency=@ValueofDB:tblPayAdjust_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblPayAdjust_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblPayAdjust_createBy@SPFieldLink:createTime=@ValueofDB:tblPayAdjust_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblPayAdjust_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblPayAdjust_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblPayAdjust_SCompanyID@SPFieldLink:FcPayTotalCredit=(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*@ValueofDB:tblPayAdjust_CurTotalAmount@ParamNum:@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:BillType=tblPayAdjust@SPFieldLink:BillNo=@ValueofDB:tblPayAdjust_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblPayAdjust_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblPayAdjust_DepartmentCode@SPFieldLink:Remark=@ValueofDB:tblPayAdjust_Remark,retCode,retVal)}</sql>
			<!--更新明细表中采购入库单的待付款金额-->
			<sql>update tblBuyInStock set NeedPayAmt=NeedPayAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,AfterChangeAmt=AfterChangeAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,ChangeAmt=ChangeAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.Amount,CurNeedPayAmt=CurNeedPayAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount,CurAfterChangeAmt=CurAfterChangeAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount,CurChangeAmt=CurChangeAmt+(case when @ValueofDB:tblPayAdjust_AdjustType='0' then -1 else 1 end)*k.CurAmount from tblPayAdjustDet k where k.f_ref=@ValueofDB:tblPayAdjust_id and k.RefBillID=tblBuyInStock.id</sql>
		</exec>
	</sql>				 		    
</define>
<define name="tblPayAdjust_Del">
	<sql type="condition"> 
		<exec condition="'@MEM:tblPayAdjust_IsStatart' == '0'">
			<sql type="define">tblPayAdjust_Del_One</sql>
		</exec>
	</sql>
</define>

<define name="tblPayAdjust_Del_One">
	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblPayAdjust_id and  workFlowNodeName='finish'</select></condition>
		<exec condition="&quot;@SqlReturn:OrderNo&quot;!=&quot;null&quot;">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!-- 删除往来明细:修改类型（1应付 2应收 3预付 4预收） -->
		<condition><select>select id as IniId from tblCompanyIni where relationDocID=@ValueofDB:tblPayAdjust_id</select></condition>
		<exec condition="true">
			<sql type="procedure">{call proc_deleteComIni(@SqlReturn:IniId,1,retCode,retVal)}</sql>
		</exec>
	</sql>
	<sql type="condition"><!--更新明细表中采购入库单的待付款金额-->
		<condition><select>select AdjustType from tblPayAdjust where id=@ValueofDB:tblPayAdjust_id</select></condition>
		<exec condition="true">
			<sql>update tblBuyInStock set NeedPayAmt=NeedPayAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,AfterChangeAmt=AfterChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,ChangeAmt=ChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.Amount,CurNeedPayAmt=CurNeedPayAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount,CurAfterChangeAmt=CurAfterChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount,CurChangeAmt=CurChangeAmt-(case when @SqlReturn:AdjustType='0' then -1 else 1 end)*k.CurAmount from tblPayAdjustDet k where k.f_ref=@ValueofDB:tblPayAdjust_id and k.RefBillID=tblBuyInStock.id</sql>
			
		</exec>
	</sql>
	<sql type="condition">
		<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		  <sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblPayAdjust_id,retCode,retVal)}</sql>	
		</exec>
	</sql>
</define>		
<!--====================================================以上代码：应付调帐单=================================================-->	

<!--========================================================反开账，年结操作=================================================-->	

<!--=======反开账页面不管是否勾选任何选项，先执行此define======= -->
<define name="DeOpenAcc">
	<!--暂时无内容，程序提供此接口，后续使用-->
</define> 
	
<!--===== 反开账操作 删除基本信息====== -->
<define name="DeOpenAccBase">
	<sql type="procedure">{call proc_DeOpenAccBase(retCode,retVal)}</sql>
</define>
	
<!--======= 反开账操作 删除期初数据=====  -->
<define name="DeOpenAccIni">
	<sql type="procedure">{call proc_DeOpenAccIni(retCode,retVal)}</sql>
</define>
		
<!--======= 反开账，年结操作 删除单据草稿数据====== -->
<define name="DeOpenAccDraft">
	<sql type="procedure">{call DeOpenAccDraft(retCode,retVal)}</sql>
</define>
<!--===== 反开账操作 删除单据非草稿数据======  -->
<define name="DeOpenAccBill">
	<sql type="procedure">{call DeOpenAccBill(retCode,retVal)}</sql>
</define>

<!--===== 删除单据功能:删除数据前的操作======  -->
<define name="DelBillBefore">
	<sql type="condition"><!--完整输入备份数据库的地址后，执行备份删除数据的动作-->
		<exec condition="'@ValueofDB:SERVER'.length&gt;0&amp;&amp;'@ValueofDB:UID'.length&gt;0&amp;&amp;'@ValueofDB:PWD'.length&gt;0&amp;&amp;'@ValueofDB:DataBase'.length&gt;0">
			<sql type="procedure">{call CopyBillToOtherDataBase(@ValueofDB:SERVER,@ValueofDB:UID,@ValueofDB:PWD,@ValueofDB:DataBase,@ValueofDB:period,@ValueofDB:periodYear,@ValueofDB:SCompanyID,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>

<!--=================================================以上代码：反开账，年结操作===============================================-->


<!--费用类型不能重复增加 -->
<define name="tblFeeType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblFeeType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblFeeType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>


	<!--分支机构开帐，总公司开帐显示-->
	<define name="OpenAcc">
	</define> 
	
	
	<!--分支机构月结，总公司月结显示-->
	<define name="CloseAcc">
		
	</define>
		<!--分支机构全反月结，总公司反月结显示-->
	<define name="DeCloseAcc">
		
	</define>
	
	<!--判断收入类型不能删除修改-->
<define name="tblInComeType_del">
	<sql type="condition"> 	
		<condition>
			<select>select IncomeCode as Code  from tblIncomeDetl left join tblInComeType on tblIncomeDetl.IncomeCode=tblInComeType.SubCode  where tblInComeType.id=@ValueofDB:tblInComeType_id</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblInComeType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
	</sql>
</define>

<!--收入类型不能重复增加 -->
<define name="tblInComeType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblInComeType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblInComeType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>

<!--判断调价类型不能删除修改-->
<define name="tblPriceType_del">
	<sql type="condition"> 	
		<condition>
			<select>select ChangeType as Code  from tblBuychange left join tblPriceType on tblPriceType.AccCode=tblBuychange.ChangeType where tblPriceType.id=@ValueofDB:tblPriceType_id</select>		
			<select>select ChangeType as CodeSales  from tblsaleschange left join tblPriceType on tblPriceType.AccCode=tblsaleschange.ChangeType where tblPriceType.id=@ValueofDB:tblPriceType_id</select>
			<select>select tblPriceType.SubType,tblPriceType.AccCode as CodeStore from tblAdjustPrice join tblPriceType 
on tblAdjustPrice.AdjustPriceType=tblPriceType.id where tblPriceType.id=@ValueofDB:tblPriceType_id and tblPriceType.SCompanyID=@Sess:SCompanyID</select>
	 <select>select tblPriceType.AccCode as BuyCode from  tblPriceType where tblPriceType.id=@ValueofDB:tblPriceType_id and tblPriceType.AccCode='630106'</select>
	 	 <select>select tblPriceType.AccCode as SalesCode from  tblPriceType where tblPriceType.id=@ValueofDB:tblPriceType_id and tblPriceType.AccCode='671108'</select>
	 	 <select>select id as StoreId,tblPriceType.AccCode as StorePriceCode from  tblPriceType where tblPriceType.id=@ValueofDB:tblPriceType_id</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:CodeStore'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:CodeStore'!='null'&amp;&amp;'@SqlReturn:CodeStore'!='@ValueofDB:tblPriceType_AccCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblPriceType_AccCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:CodeSales'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:CodeSales'!='null'&amp;&amp;'@SqlReturn:CodeSales'!='@ValueofDB:tblPriceType_AccCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
		<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:BuyCode'=='630106'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:BuyCode'=='630106'&amp;&amp;'@ValueofDB:tblPriceType_AccCode'!='630106'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
		<!-- 不允许删除系统默认类型-->
			<exec condition="('@SqlReturn:SalesCode'=='671108'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SalesCode'=='671108'&amp;&amp;'@ValueofDB:tblPriceType_AccCode'!='671108'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
			<!-- 不允许删除系统默认类型-->
			<exec condition="('@SqlReturn:StoreId'=='bed5588782d945b58e38a3191d2e'&amp;&amp;'@Sess:BillOper'=='delete')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>

<!--调价类型不能重复增加 -->
<define name="tblPriceType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(AccCode) as coutcode from tblPriceType where scompanyid=@Sess:SCompanyID and AccCode=@ValueofDB:tblPriceType_AccCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>
	
<!--判断入库类型不能删除修改-->
<define name="tblInType_del">
	<sql type="condition"> 	
		<condition>
			<select>select OtherInType as Code  from tblOtherIn left join tblInType on tblInType.SubCode=tblOtherIn.OtherInType where tblInType.id=@ValueofDB:tblInType_id</select>
			<select>select tblInType.SubCode  from  tblInType where tblInType.id=@ValueofDB:tblInType_id and tblInType.SubCode='190101'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblInType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
			<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='190101'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='190101'&amp;&amp;'@ValueofDB:tblInType_SubCode'!='190101'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>

<!--入库类型不能重复增加 -->
<define name="tblInType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblInType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblInType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>
	
<!--判断出库类型不能删除修改-->
<define name="tblOutType_del">
	<sql type="condition"> 	
		<condition>
	<select>select OutType as Code  from tblOtherOut left join tblOutType on tblOutType.SubCode=tblOtherOut.OutType where tblOutType.id=@ValueofDB:tblOutType_id</select>
	<select>select tblOutType.SubCode  from  tblOutType where tblOutType.id=@ValueofDB:tblOutType_id and tblOutType.SubCode='190101'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblOutType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
		<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='190101'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='190101'&amp;&amp;'@ValueofDB:tblOutType_SubCode'!='190101'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>

<!--出库类型不能重复增加 -->
<define name="tblOutType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblOutType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblOutType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>

<!--判断报损类型不能删除修改-->
<define name="tblCheckLessType_del">
	<sql type="condition"> 	
		<condition>
			<select>select tblCheck.SubCode as Code from tblCheck left join tblCheckLessType on tblCheckLessType.SubCode=tblCheck.SubCode where tblCheckLessType.id=@ValueofDB:tblCheckLessType_id</select>
			<select>select tblCheckLessType.SubCode  from  tblCheckLessType where tblCheckLessType.id=@ValueofDB:tblCheckLessType_id and tblCheckLessType.SubCode='190101'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblCheckLessType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
			<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='190101'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='190101'&amp;&amp;'@ValueofDB:tblCheckLessType_SubCode'!='190101'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>
<!--报损类型不能重复增加 -->
<define name="tblCheckLessType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblCheckLessType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblCheckLessType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>
	<!--判断报溢类型不能删除修改-->
<define name="tblCheckMoreType_del">
	<sql type="condition"> 	
		<condition>
			<select>select tblCheckMore.SubCode as Code from tblCheckMore left join tblCheckMoreType on tblCheckMoreType.SubCode=tblCheckMore.SubCode where tblCheckMoreType.id=@ValueofDB:tblCheckMoreType_id</select>
			<select>select SubCode  from  tblCheckMoreType where tblCheckMoreType.id=@ValueofDB:tblCheckMoreType_id and tblCheckMoreType.SubCode='190101'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblCheckMoreType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
				<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='190101'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='190101'&amp;&amp;'@ValueofDB:tblCheckMoreType_SubCode'!='190101'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>
<!--报溢类型不能重复增加 -->
<define name="tblCheckMoreType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblCheckMoreType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblCheckMoreType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>
	<!--判断组装类型不能删除修改-->
<define name="tblGoodsAssemblyType_del">
	<sql type="condition"> 	
		<condition>
			<select>select groupType as Code  from tblGoodsAssembly left join tblGoodsAssemblyType on tblGoodsAssemblyType.SubCode=tblGoodsAssembly.groupType where tblGoodsAssemblyType.id=@ValueofDB:tblGoodsAssemblyType_id</select>
			
			<select>select groupType as SplitCode  from tblGoodsAssemblySplit left join tblGoodsAssemblyType on tblGoodsAssemblyType.SubCode=tblGoodsAssemblySplit.groupType where tblGoodsAssemblyType.id=@ValueofDB:tblGoodsAssemblyType_id</select>
			<select>select tblGoodsAssemblyType.SubCode  from  tblGoodsAssemblyType where tblGoodsAssemblyType.id=@ValueofDB:tblGoodsAssemblyType_id and tblGoodsAssemblyType.SubCode='2211'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblGoodsAssemblyType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:SplitCode'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SplitCode'!='null'&amp;&amp;'@SqlReturn:SplitCode'!='@ValueofDB:tblGoodsAssemblyType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
			<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='2211'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='2211'&amp;&amp;'@ValueofDB:tblGoodsAssemblyType_SubCode'!='2211'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>
<!--组装类型不能重复增加 -->
<define name="tblGoodsAssemblyType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblGoodsAssemblyType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblGoodsAssemblyType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>
<!--判断拆装类型不能删除修改-->
<define name="tblSplitFormType_del">
	<sql type="condition"> 	
		<condition>
			<select>select groupType as Code  from tblGoodsSplitForm left join tblSplitFormType on tblSplitFormType.SubCode=tblGoodsSplitForm.groupType where tblSplitFormType.id=@ValueofDB:tblSplitFormType_id</select>
			<select>select tblSplitFormType.SubCode  from  tblSplitFormType where tblSplitFormType.id=@ValueofDB:tblSplitFormType_id and tblSplitFormType.SubCode='2211'</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblSplitFormType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
			<!-- 不允许删除系统默认类型-->
		<exec condition="('@SqlReturn:SubCode'=='2211'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:SubCode'=='2211'&amp;&amp;'@ValueofDB:tblSplitFormType_SubCode'!='2211'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.defaulttype.error</error> 
		</exec>
	</sql>
</define>
<!--拆装类型不能重复增加 -->
<define name="tblSplitFormType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblSplitFormType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblSplitFormType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>

<!--判断费用类型不能删除修改-->
<define name="tblFeeType_del">
	<sql type="condition"> 	
		<condition>
			<select>select ExpenseCode as Code from tblExpenseDet left join tblFeeType on tblFeeType.SubCode=tblExpenseDet.ExpenseCode where tblFeeType.id=@ValueofDB:tblFeeType_id</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblFeeType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
	</sql>
</define>

<!--判断分摊类型不能删除修改-->
<define name="tblPrecessCostType_del">
	<sql type="condition"> 	
		<condition>
			<select>select tblPrecessCostType.SubCode as Code from tblPrecessCostType  where (tblPrecessCostType.SubCode in (select CostType from tblOutPrecessCost) or tblPrecessCostType.SubCode in (select CostType from tblProduceCost)) and tblPrecessCostType.id=@ValueofDB:tblPrecessCostType_id</select>
		</condition>
		<!-- 已经使用的财务类型不能删除，已经使用的财务类型不能修改科目代码 -->
		<exec condition="('@SqlReturn:Code'!='null'&amp;&amp;'@Sess:BillOper'=='delete')||('@SqlReturn:Code'!='null'&amp;&amp;'@SqlReturn:Code'!='@ValueofDB:tblPrecessCostType_SubCode'&amp;&amp;'@Sess:BillOper'=='update')">
			<error>modifyType.type.error</error> 
		</exec>
	</sql>
</define>

<!--分摊类型不能重复增加 -->
<define name="tblPrecessCostType_Add">
<sql type="condition">
		<!--本币汇兑单的删除-->
	 <condition>
		<select>select count(SubCode) as coutcode from tblPrecessCostType where scompanyid=@Sess:SCompanyID and subCode=@ValueofDB:tblPrecessCostType_SubCode</select>
        </condition>
	  <exec condition="@SqlReturn:coutcode &gt;=2">
	  <error>tblFeeType.repeat.error</error> 
	  </exec>
	  </sql>
</define>

<!--存货核算方式删除前-->
<define name="tblGoodsAccProp_delete_before">
	<sql type="condition">
		<condition>
			<select>select 'true' as Result from tblGoods where CostMethod=@ValueofDB:tblGoodsAccProp_id</select>
			<select>select AccCode oldAccCode,IncomeAccCode oldIncomeAccCode,ExpendAccCode oldExpendAccCode from tblGoodsAccProp where id=@ValueofDB:tblGoodsAccProp_id  </select>
		</condition>
		<exec condition="'@SqlReturn:Result'=='true' &amp;&amp;( '@ValueofDB:AccCode' != '@SqlReturn:oldAccCode' || '@ValueofDB:IncomeAccCode' != '@SqlReturn:oldIncomeAccCode' || '@ValueofDB:ExpendAccCode' != '@SqlReturn:oldExpendAccCode')">
			<error>此类型已关联商品，不能修改科目字段</error> 
		</exec>
	</sql>
</define>


<!--收款单状态激活-->
<define name="ReceiveStatusStop_reverse">
<sql type="condition">
<condition>
</condition>
<exec condition="true">
<sql>update tblSaleReceive set Statusid=0 where id=@ValueofDB:tblSaleReceive_id</sql>
</exec>
</sql>
</define>
	<!--收款单状态完成-->
<define name="ReceiveStatus_finish">
<sql type="condition">
<condition>
</condition>
<exec condition="true">
<sql>update tblSaleReceive set Statusid=1 where id=@ValueofDB:tblSaleReceive_id</sql>
</exec>
</sql>
</define>

<!--付款单状态激活-->
<define name="PayStatusStop_reverse">
<sql type="condition">
<condition>
</condition>
<exec condition="true">
<sql>update tblPay set Statusid=0 where id=@ValueofDB:tblPay_id</sql>
</exec>
</sql>
</define>
	<!--付款单状态完成-->
<define name="PayStatus_finish">
<sql type="condition">
<condition>
</condition>
<exec condition="true">
<sql>update tblPay set Statusid=1 where id=@ValueofDB:tblPay_id</sql>
</exec>
</sql>
</define>

<!--=================================================其它付款单======================================================-->
<define name="tblExpense_Add">
	<sql type="condition">
		<!--选择的结算账户为往来科目，则必须选择往来单位及勾选启用往来核算-->
		<exec condition="('@ValueofDB:tblExpensed_SubCode'=='2202')&amp;&amp;('@ValueofDB:tblExpensed_CheckCompany'!='1,'||'@ValueofDB:tblExpensed_CompanyCode'=='')">
			<error>tblExpensed.CheckCompany.error</error> 
		</exec>
		<!--勾选了启用往来核算，则结算账户不能为现金银行科目-->
		<exec condition="'@ValueofDB:tblExpensed_CheckCompany'=='1,'&amp;&amp;('@ValueofDB:tblExpensed_SubCode'.indexOf('1001')==0||'@ValueofDB:tblExpensed_SubCode'.indexOf('1002')==0)">
			<error>tblCashBank.SelectCompany.error</error> 
		</exec>
		<!--勾选了启用往来核算，则必须选择往来单位-->
		<exec condition="'@ValueofDB:tblExpensed_CheckCompany'=='1,'&amp;&amp;'@ValueofDB:tblExpensed_CompanyCode'==''">
			<error>tblExpensed.CCSelectCompany.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--如果启用了部门核算，则明细表部门和主表制单人的部门的一级部门必须是相同的-->
		<condition>
			<select>select DepartmentCode as CreateDeptCode from tblEmployee where id=@ValueofDB:tblExpensed_createBy</select>
			<select>select count(0) as deptError from tblExpenseDet where @MEM:openDeptAcc='true' and f_ref=@ValueofDB:tblExpensed_id and substring(DepartmentCode,1,5)!=substring(@SqlReturn:CreateDeptCode,1,5)</select>
		</condition>
		<exec condition="@SqlReturn:deptError&gt;0">
			<error>common.deptDif.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--选择的结算账户为往来科目，则必须选择相应的往来单位-->
		<condition><select>select ClientFlag from tblCompany where classCode=@ValueofDB:tblExpensed_CompanyCode</select></condition>
		<exec condition="@SqlReturn:ClientFlag==2&amp;&amp;'@ValueofDB:tblExpensed_SubCode'=='2202'">
			<error>tblExpense.selectCompany2.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的金额小于0给出错误提示-->
		<condition><select>select count(0) as AmtNeC from tblExpenseDet where f_ref=@ValueofDB:tblExpensed_id and Amt&lt;=0</select></condition>
		<exec condition="@SqlReturn:AmtNeC&gt;0">
			<error>tblExpense.add.DetLessZero</error> 
		</exec>
	</sql>
	
	<sql type="condition"><!--存在支出类型未填写的明细记录给出错误提示-->
		<condition><select>select count(0) as AmtNeC from tblExpenseDet where f_ref=@ValueofDB:tblExpensed_id and isnull(SubCode,'')=''</select></condition>
		<exec condition="@SqlReturn:AmtNeC&gt;0">
			<error>存在支出类型未填写的明细记录</error> 
		</exec>
	</sql>
	
	<sql type="condition"><!--明细表的金额合计必须与主表相等-->
		<condition><select>select dbo.getDigits('tblExpenseDet','Amt',sum(Amt)) as SumDetAmt from tblExpenseDet where f_ref=@ValueofDB:tblExpensed_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblExpensed_BillAmt">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblExpensed_BillAmt,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--检查账户是否出现负数:@Sess:NoAccNegative为系统配置是否启用账户余额负数控制  单账户-->
		<condition>
			<select>SELECT e.zh_CN AS AccountName FROM tblAccBalance b JOIN (SELECT a.SubCode,a.Nyear,MAX(a.Period) Period FROM tblAccBalance a JOIN (SELECT MAX(Nyear) Nyear FROM tblAccBalance WHERE SubCode = @ValueofDB:SubCode AND Nyear&gt;=@ValueofDB:PeriodYear) b ON a.Nyear = b.Nyear WHERE a.SubCode = @ValueofDB:SubCode GROUP BY a.SubCode,a.Nyear) c ON b.Period = c.Period AND b.Nyear = c.Nyear JOIN tblAccTypeInfo d ON d.AccNumber=@ValueofDB:SubCode JOIN tblLanguage e ON d.AccName = e.id WHERE b.SubCode=@ValueofDB:SubCode AND (b.PeriodBalaBase - @ValueofDB:BillAmt)&lt;0 AND (b.SubCode like '1001%' or b.SubCode like '1002%')</select>
		</condition>
		<exec condition="&quot;@SqlReturn:AccountName&quot;.length != 0 &amp;&amp; &quot;@SqlReturn:AccountName&quot; != &quot;null&quot; &amp;&amp; &quot;@MEM:NoAccNegative&quot; == &quot;true&quot;">
			<error>AccNegative.Account.error,@SqlReturn:AccountName</error>                     
		</exec>	
	</sql>
	<sql type="condition"><!--外币判断，暂不处理-->
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblExpensed_SubCode and SCompanyID=@Sess:SCompanyID</select></condition>
		<exec condition="'@ValueofDB:tblExpensed_Currency'.length != 0 &amp;&amp; !( '@ValueofDB:tblExpensed_Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  )">
		<!--选择的付款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.SelectCurType.error</error> 
		</exec>	
		<exec condition="'@ValueofDB:tblExpensed_Currency'.length == 0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL') ">
		<!--选择的付款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.SelectCurType.error</error> 
		</exec>	 
		 <!--如果是本位币帐户，不用录入汇率-->	
	 <exec condition=" ('@ValueofDB:tblExpensed_Currency'.length == 0 &amp;&amp; @ValueofDB:tblExpensed_CurrencyRate &gt; 0 &amp;&amp; @ValueofDB:tblExpensed_CurrencyRate!=1)">		
     <error>CurrencyRate.putErrors.error</error> 
	 </exec>
	</sql>	  
	<sql type="condition">
		<exec condition="true">
			<!-- 导入时如果外币为空则设置默认值 -->
			<sql>update tblExpensed set CertificateNo='' where id=@ValueofDB:tblExpensed_id</sql>
			<sql>update tblExpensed set CurrencyRate=0 where CurrencyRate is null and id=@ValueofDB:tblExpensed_id</sql>
			<sql>update tblExpensed set Currency='' where Currency is null and id=@ValueofDB:tblExpensed_id</sql>
			<sql>update tblExpensed set AlreadyPayAmt=0,NeedPayAmt=(case when @ValueofDB:tblExpensed_CheckCompany='1,' then BillAmt else 0 end),CurNeedPayAmt=(case when @ValueofDB:tblExpensed_CheckCompany='1,' then FcBillAmt else 0 end) where id=@ValueofDB:tblExpensed_id</sql>
		</exec>
		<exec condition="'@MEM:tblExpensed_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblExpensed_Add_One</sql>
		</exec>
	</sql>	
</define>
<define name="tblExpensed_Add_One">
	<sql type="condition">
    <exec condition="'@MEM:autoGenerateAcc'=='true'">
		<sql type="certificate">tblExpensed</sql>
		<sql>update tblAccDetail set RecordComment=a.remark from tblExpenseDet a join tblAccDetail b on a.SubCode=b.AccCode and a.f_ref=b.RefBillID
and b.RefBillID=@ValueofDB:id</sql>
	</exec>
    <exec condition="true">
			<!--将开票金额与未开票金额更新为初始值-->
			<sql>update tblExpensed set tblExpensed.NotInvoiceAmount=tblExpensed.BillAmt,tblExpensed.InvoiceAmount=0,tblExpensed.InvoiceStatus='False' where tblExpensed.id =@ValueofDB:tblExpensed_id</sql>
		</exec>
		<!--如果启用了往来核算,则影响往来明细-->
		<exec condition="'@ValueofDB:tblExpensed_CheckCompany'=='1,'">
			<sql type="define">tblExpensed_Add_Company</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果追踪单号不为空，则向追踪单号表中插入数据-->
	 	<exec condition="&quot;@ValueofDB:TrackNo&quot;!=&quot;&quot;&amp;&amp;&quot;@ValueofDB:TrackNo&quot;!=&quot;null&quot;">			  
			<sql>insert into tblTrackBill (id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID)(select subString(cast(newid() as varchar(36)),1,30) as id ,id AS RelationID,BillNo,'tblExpensed',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblExpensed where id =@ValueofDB:tblExpensed_id)</sql>	
     	</exec>
	</sql>
</define>
<!--===========如果启用了往来核算,则影响往来明细===========-->
<define name="tblExpensed_Add_Company">
	<sql type="condition">
		<condition>
			<select>select ClientFlag from tblCompany where classCode=@ValueofDB:tblExpensed_CompanyCode</select>
			<select>select DepartmentCode as CreateDeptCode from tblEmployee where id=@ValueofDB:tblExpensed_createBy</select>
		</condition>
		<!--如果是客户，则往来单位的应收减少 （1应付 2应收 3预付 4预收）-->
		<exec condition="@SqlReturn:ClientFlag==2">
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblExpensed_id,@ValueofDB:tblExpensed_CompanyCode,2,@ValueofDB:tblExpensed_BillDate,Period=@ValueofDB:tblExpensed_Period@SPFieldLink:PeriodYear=@ValueofDB:tblExpensed_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblExpensed_PeriodMonth@SPFieldLink:ReceiveTotalDebit=-@ValueofDB:tblExpensed_BillAmt@ParamNum:@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblExpensed_id@SPFieldLink:createBy=@ValueofDB:tblExpensed_createBy@SPFieldLink:createTime=@ValueofDB:tblExpensed_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblExpensed_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblExpensed_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblExpensed_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblExpensed_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblExpensed_CurrencyRate@SPFieldLink:FcRecTotalDebit=-@ValueofDB:tblExpensed_FcBillAmt@ParamNum:@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:BillType=tblExpensed@SPFieldLink:BillNo=@ValueofDB:tblExpensed_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblExpensed_createBy@SPFieldLink:DepartmentCode=@SqlReturn:CreateDeptCode@SPFieldLink:DiscountAmount=0@SPFieldLink:Remark=@ValueofDB:tblExpensed_Remark,retCode,retVal)}</sql>
		</exec>
		<!--如果是非客户，则往来单位的应付增加 （1应付 2应收 3预付 4预收）-->
		<exec condition="@SqlReturn:ClientFlag!=2">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblExpensed_id,@ValueofDB:tblExpensed_CompanyCode,1,@ValueofDB:tblExpensed_BillDate,Period=@ValueofDB:tblExpensed_Period@SPFieldLink:PeriodYear=@ValueofDB:tblExpensed_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblExpensed_PeriodMonth@SPFieldLink:PayTotalDebit=0@ParamNum:@SPFieldLink:PayTotalLend=@ValueofDB:tblExpensed_BillAmt@SPFieldLink:RelationDocID=@ValueofDB:tblExpensed_id@SPFieldLink:createBy=@ValueofDB:tblExpensed_createBy@SPFieldLink:createTime=@ValueofDB:tblExpensed_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblExpensed_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblExpensed_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblExpensed_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblExpensed_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblExpensed_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=@ValueofDB:tblExpensed_FcBillAmt@ParamNum:@SPFieldLink:BillType=tblExpensed@SPFieldLink:BillNo=@ValueofDB:tblExpensed_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblExpensed_createBy@SPFieldLink:DepartmentCode=@SqlReturn:CreateDeptCode@SPFieldLink:DiscountAmount=0@SPFieldLink:Remark=@ValueofDB:tblExpensed_Remark,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>
<!--========删除费用分摊单=========-->
<define name="tblExpense_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblExpensed_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblExpense_Del_One</sql>
		</exec> 
	</sql>		  
</define>
<define name="tblExpense_Del_One">
<!--=============查询是否存在关联表，如果有提出错误提示===========-->
<sql type="condition"><!--由职员工资设定表生成的费用单不允许进行操作-->
	<condition><select>select RefBillID as RefHREmployeeWage from tblExpensed where id=@ValueofDB:tblExpensed_id</select></condition>
	<exec condition="'@SqlReturn:RefHREmployeeWage'.length &gt; 0">	
		<error>tblExpensed.del.error.HREmployeeWage</error>                  
	</exec>
</sql>
<sql type="condition"><!--存在关联付款单不允许进行操作 -->
	<condition><select>select a.BillNo as RefPayNo from tblPay a,tblPayDet b where a.id=b.f_ref and b.RefBillID=@ValueofDB:tblExpensed_id and a.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:RefPayNo'!='null'">
		<error>PayBill.BillNo.error,@SqlReturn:RefPayNo</error> 
	</exec>
</sql>
<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
	<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblExpensed_id and workFlowNodeName='finish'</select></condition>
	<exec condition="'@SqlReturn:OrderNo'!='null'">	
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
	</exec>
</sql>
<sql type="condition"><!--存在对应的采购开票单-->
	<condition>
		<select>SELECT a.BillNo AS InfoBillNo FROM tblBuyInvoiceInfo a JOIN tblBuyInfoDet b ON a.id = b.f_ref WHERE b.RefBillID = @ValueofDB:id and a.workFlowNodeName!='print'</select>
	</condition>
	<exec condition="'@SqlReturn:InfoBillNo'!='null'">
		<error>InfoBill.BillNo.error,@SqlReturn:InfoBillNo</error>
	</exec>
</sql>
<!--删除凭证-->
<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblExpensed_id,retCode,retVal)}</sql>
<sql type="condition"><!--判断如果启用往来核算，则删除往来明细-->
	<condition><select>select CheckCompany from tblExpensed where id=@ValueofDB:tblExpensed_id</select></condition>
	<exec condition="'@SqlReturn:CheckCompany'=='1,'">
		<sql type="define">tblExpense_Del_Company</sql>
	</exec>
</sql>	
<sql type="condition">
	<exec condition="true">
		<sql>delete from tblTrackBill where RelationID = @ValueofDB:tblExpensed_id</sql>
	</exec>
</sql>		
</define>
<define name="tblExpense_Del_Company">
<sql type="condition">
	<condition><select>select id as IniId,case when ReceiveTotalDebit!=0 then 2 else 1 end ComType from tblCompanyIni where relationDocID=@ValueofDB:tblSalesOutStock_id</select></condition>
	<exec condition="true"><!-- 删除往来明细:修改类型（1应付 2应收 3预付 4预收） -->
		<sql type="procedure">{call proc_deleteComIni(@SqlReturn:IniId,@SqlReturn:ComType,retCode,retVal)}</sql>
	</exec>
</sql>
</define>
<!--===================================================以上代码：其它付款单======================================================-->

<!--=======================================================其他收款单========================================================-->
<define name="tblIncome_Add">
	<sql type="condition">
		<!--选择的结算账户为往来科目，则必须勾选启用往来核算-->
		<exec condition="('@ValueofDB:tblIncome_SubCode'=='1122')&amp;&amp;('@ValueofDB:tblExpensed_CheckCompany'!='1,'||'@ValueofDB:tblIncome_CompanyCode'=='')">
			<error>tblExpensed.CheckCompany.error</error> 
		</exec>
		<!--勾选了启用往来核算，则结算账户不能为现金银行科目-->
		<exec condition="'@ValueofDB:tblIncome_CheckCompany'=='1,'&amp;&amp;('@ValueofDB:tblIncome_SubCode'.indexOf('1001')==0||'@ValueofDB:tblIncome_SubCode'.indexOf('1002')==0)">
			<error>tblCashBank.SelectCompany.error</error> 
		</exec>
		<!--勾选了启用往来核算，则必须选择往来单位-->
		<exec condition="'@ValueofDB:tblIncome_CheckCompany'=='1,'&amp;&amp;'@ValueofDB:tblIncome_CompanyCode'==''">
			<error>tblExpensed.CCSelectCompany.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--如果启用了部门核算，则明细表部门和主表制单人的部门的一级部门必须是相同的-->
		<condition>
			<select>select DepartmentCode as CreateDeptCode from tblEmployee where id=@ValueofDB:tblIncome_createBy</select>
			<select>select count(0) as deptError from tblIncomeDetl where @MEM:openDeptAcc='true' and f_ref=@ValueofDB:tblIncome_id and substring(DepartmentCode,1,5)!=substring(@SqlReturn:CreateDeptCode,1,5)</select>
		</condition>
		<exec condition="@SqlReturn:deptError&gt;0">
			<error>common.deptDif.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--选择的结算账户为往来科目，则必须选择相应的往来单位-->
		<condition><select>select ClientFlag from tblCompany where classCode=@ValueofDB:tblIncome_CompanyCode</select></condition>
		<exec condition="@SqlReturn:ClientFlag==1&amp;&amp;'@ValueofDB:tblIncome_SubCode'.indexOf('1122')==0">
			<error>tblExpense.selectCompany1.error</error> 
		</exec>
	</sql>
	<sql type="condition"><!--明细表的金额小于0给出错误提示-->
		<condition><select>select count(0) as AmtNeC from tblIncomeDetl where f_ref=@ValueofDB:tblIncome_id and Amt&lt;=0</select></condition>
		<exec condition="@SqlReturn:AmtNeC&gt;0">
			<error>tblIncome.add.DetLessZero</error> 
		</exec>
	</sql>
	
	<sql type="condition"><!--存在收入类型未填的明细给出错误提示-->
		<condition><select>select count(0) as AmtNeC from tblIncomeDetl where f_ref=@ValueofDB:tblIncome_id and isnull(SubCode,'')=''</select></condition>
		<exec condition="@SqlReturn:AmtNeC&gt;0">
			<error>存在收入类型未填写的明细</error> 
		</exec>
	</sql>
	
	<sql type="condition"><!--明细表的金额合计必须与主表相等-->
		<condition><select>select dbo.getDigits('tblIncomeDetl','Amt',sum(Amt)) as SumDetAmt from tblIncomeDetl where f_ref=@ValueofDB:tblIncome_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblIncome_BillAmt">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblIncome_BillAmt,@SqlReturn:SumDetAmt</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--外币代码，暂不处理-->
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblIncome_SubCode and SCompanyID=@ValueofDB:tblIncome_SCompanyID</select></condition>
		<exec condition="'@ValueofDB:tblIncome_Currency'.length !=0 &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  )">
		  <!--选择的收款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.ReceSelectCurType.error</error> 
		</exec>	
		<exec condition="'@ValueofDB:tblIncome_Currency'.length == 0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL') ">
		<!--选择的收款帐户不是该币种对应的帐户-->
			<error>tblAccTypeInfo.ReceSelectCurType.error</error> 
		</exec>	 
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblIncome_Currency'.length == 0 &amp;&amp; @ValueofDB:tblIncome_CurrencyRate &gt; 0 &amp;&amp; @ValueofDB:tblIncome_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error> 
		</exec>
	</sql>	  
	<sql type="condition">
		<exec condition="true">
			<!--导入时如果外币为空则设置默认值-->
			<sql>update tblIncome set CertificateNo='' where id=@ValueofDB:tblIncome_id</sql>
			<sql>update tblIncome set CurrencyRate=0 where CurrencyRate is null and id=@ValueofDB:tblIncome_id</sql>
			<sql>update tblIncome set Currency='' where Currency is null and id=@ValueofDB:tblIncome_id</sql>
			<sql>update tblIncome set TotalAlrAccAmt=0,NeedReturnAmt=(case when @ValueofDB:tblIncome_CheckCompany='1,' then BillAmt else 0 end),CurTotalAlrAccAmt=0,CurNeedReturnAmt=(case when @ValueofDB:tblIncome_CheckCompany='1,' then FcBillAmt else 0 end) where id=@ValueofDB:tblIncome_id</sql>
		</exec>
		<exec condition="'@MEM:tblIncome_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblIncome_Add_One</sql>
		</exec>
	</sql>
</define>

<define name="tblIncome_Add_One">	  
	<sql type="condition">
		<exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblIncome</sql></exec>
		<exec condition="true">
			<!--将开票金额与未开票金额更新为初始值-->
			<sql>update tblIncome set tblIncome.NotInvoiceAmount=tblIncome.BillAmt,tblIncome.InvoiceAmount=0,tblIncome.InvoiceStatus='False' where tblIncome.id =@ValueofDB:tblIncome_id</sql>
		</exec>
		<!-- 如果启用往来核算，则插入往来明细 -->  
		<exec condition="'@ValueofDB:tblIncome_CheckCompany'=='1,'">
			<sql type="define">tblIncome_Add_Company</sql>
		</exec>
	</sql>
</define>

<define name="tblIncome_Add_Company">
	<sql type="condition">
		<condition>
			<select>select ClientFlag from tblCompany where ClassCode=@ValueofDB:tblIncome_CompanyCode</select>
			<select>select DepartmentCode as CreateDeptCode from tblEmployee where id=@ValueofDB:tblIncome_createBy</select>
		</condition>
		<!--如果选择的是供应商，则往来单位的应付减少 往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="@SqlReturn:ClientFlag==1">
 			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblIncome_id,@ValueofDB:tblIncome_CompanyCode,1,@ValueofDB:tblIncome_BillDate,Period=@ValueofDB:tblIncome_Period@SPFieldLink:PeriodYear=@ValueofDB:tblIncome_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblIncome_PeriodMonth@SPFieldLink:PayTotalDebit=0@SPFieldLink:PayTotalLend=-@ValueofDB:tblIncome_BillAmt@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblIncome_id@SPFieldLink:Currency=@ValueofDB:tblIncome_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblIncome_CurrencyRate@SPFieldLink:FcPayTotalDebit=0@SPFieldLink:FcPayTotalCredit=-@ValueofDB:tblIncome_FcBillAmt@ParamNum:@SPFieldLink:createBy=@ValueofDB:tblIncome_createBy@SPFieldLink:createTime=@ValueofDB:tblIncome_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblIncome_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblIncome_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblIncome_SCompanyID@SPFieldLink:BillType=tblIncome@SPFieldLink:BillNo=@ValueofDB:tblIncome_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblIncome_createBy@SPFieldLink:DepartmentCode=@SqlReturn:CreateDeptCode@SPFieldLink:DiscountAmount=0@SPFieldLink:Remark=@ValueofDB:tblIncome_Remark,retCode,retVal)}</sql>
 		</exec>
		<!--如果选择非供应商，则往来单位的应收增加 往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="@SqlReturn:ClientFlag!=1">
 			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblIncome_id,@ValueofDB:tblIncome_CompanyCode,2,@ValueofDB:tblIncome_BillDate,Period=@ValueofDB:tblIncome_Period@SPFieldLink:PeriodYear=@ValueofDB:tblIncome_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblIncome_PeriodMonth@SPFieldLink:ReceiveTotalDebit=@ValueofDB:tblIncome_BillAmt@SPFieldLink:ReceiveTotalLend=0@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblIncome_id@SPFieldLink:Currency=@ValueofDB:tblIncome_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblIncome_CurrencyRate@SPFieldLink:FcRecTotalDebit=@ValueofDB:tblIncome_FcBillAmt@SPFieldLink:FcRecTotalCredit=0@ParamNum:@SPFieldLink:createBy=@ValueofDB:tblIncome_createBy@SPFieldLink:createTime=@ValueofDB:tblIncome_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblIncome_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblIncome_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblIncome_SCompanyID@SPFieldLink:BillType=tblIncome@SPFieldLink:BillNo=@ValueofDB:tblIncome_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblIncome_createBy@SPFieldLink:DepartmentCode=@SqlReturn:CreateDeptCode@SPFieldLink:DiscountAmount=0@SPFieldLink:Remark=@ValueofDB:tblIncome_Remark,retCode,retVal)}</sql>
 		</exec>
	</sql>
</define>

<!--==========其他收款单 删除=============-->
<define name="tblIncome_Del">
	<sql type="condition">
		<exec condition="'@MEM:tblIncome_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblIncome_Del_One</sql>
		</exec>
	</sql>	 
</define>		  
<define name="tblIncome_Del_One">
	<sql type="condition"><!--存在关联收款单不允许进行操作 -->
		<condition><select>select a.BillNo as ReBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and b.RefBillID=@ValueofDB:tblIncome_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:ReBillNo'!='null'">
			<error>DelBill.ReBillNo.error,@SqlReturn:ReBillNo</error> 
		</exec>
	</sql>
	<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblIncome_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!='null'">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--存在对应的销售开票单-->
	<condition>
		<select>SELECT a.BillNo AS InfoBillNo FROM tblSalesInvoiceInfo a JOIN tblSalesInfoDet b ON a.id = b.f_ref WHERE b.RefBillID = @ValueofDB:id and a.workFlowNodeName!='print'</select>
	</condition>
	<exec condition="'@SqlReturn:InfoBillNo'!='null'">
		<error>SaleInvoBill.BillNo.error,@SqlReturn:InfoBillNo</error>
	</exec>
</sql>
	<sql type="condition"> 
		<condition><select>select CheckCompany from tblIncome where id=@ValueofDB:tblIncome_id</select></condition>
		<!--删除凭证审核流或者减少科目余额，删除凭证信息-->	
		<exec condition="true">		
			<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblIncome_id,retCode,retVal)}</sql>
		</exec>
		<!--启用往来核算-->
		<exec condition="'@SqlReturn:CheckCompany'=='1,'">
			<sql type="define">tblIncome_Del_Company</sql>
		</exec>
	</sql>	
</define>

<define name="tblIncome_Del_Company">
	<sql type="condition">
		<condition><select>select id as IniId,case when ReceiveTotalDebit!=0 then 2 else 1 end ComType from tblCompanyIni where relationDocID=@ValueofDB:tblIncome_id</select></condition>
		<exec condition="true"><!-- 删除往来明细:修改类型（1应付 2应收 3预付 4预收） -->
			<sql type="procedure">{call proc_deleteComIni(@SqlReturn:IniId,@SqlReturn:ComType,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>
<!--======================================================以上代码：其他收款单========================================================-->

<!--=========================================================现金银行转账单=======================================================-->
<define name="tblUserTransAcc_Add">
    <sql type="condition"><!-- 转入账户和转出账户不可以是同一个现金银行帐户 -->
        <condition><select>select count(0) as AccC from tblUserTransAccDet where f_ref=@ValueofDB:tblUserTransAcc_id and ReceiveBankNo=@ValueofDB:PayBankID</select></condition>
        <exec condition="@SqlReturn:AccC&gt;0">
            <error>tblUserTransAcc.add.repeatPayAccount</error> 
        </exec>
    </sql>
    <sql type="condition"><!-- 转入金额小于等于0，给出错误提示 -->
        <condition><select>select count(0) as AmtC from tblUserTransAccDet where f_ref=@ValueofDB:tblUserTransAcc_id and ReceiveAmt&lt;=0</select></condition>
        <exec condition="@SqlReturn:AmtC&gt;0">
            <error>ReceiveBank.Bill.error</error> 
        </exec>
    </sql>
    <sql type="condition"><!--存在收入类型未填的明细给出错误提示-->
        <condition><select>select count(0) as AmtNeC from tblUserTransAccDet where f_ref=@ValueofDB:tblUserTransAcc_id and isnull(ReceiveBankNo,'')=''</select></condition>
        <exec condition="@SqlReturn:AmtNeC&gt;0">
            <error>存在转入账户未填写的明细</error> 
        </exec>
    </sql>
    <sql type="condition"><!--总金额与明细表合计金额不相等，给出错误提示-->
        <condition><select>select dbo.getDigits('tblUserTransAccDet','ReceiveAmt',sum(ReceiveAmt)) as SumDetAmt from tblUserTransAccDet where f_ref=@ValueofDB:tblUserTransAcc_id</select></condition>
        <exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblUserTransAcc_PayAmt">               
            <error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblUserTransAcc_PayAmt,@SqlReturn:SumDetAmt</error>       
        </exec> 
    </sql>
    <sql type="condition"><!--检查账户是否出现负数:@Sess:NoAccNegative为系统配置是否启用账户余额负数控制  单账户-->
        <condition>
            <select>SELECT e.zh_CN AS AccountName FROM tblAccBalance b JOIN (SELECT a.SubCode,a.Nyear,MAX(a.Period) Period FROM tblAccBalance a JOIN (SELECT MAX(Nyear) Nyear FROM tblAccBalance WHERE SubCode = @ValueofDB:PayBankID AND Nyear&gt;=@ValueofDB:PeriodYear) b ON a.Nyear = b.Nyear WHERE a.SubCode = @ValueofDB:PayBankID GROUP BY a.SubCode,a.Nyear) c ON b.Period = c.Period AND b.Nyear = c.Nyear JOIN tblAccTypeInfo d ON d.AccNumber=@ValueofDB:PayBankID JOIN tblLanguage e ON d.AccName = e.id WHERE b.SubCode=@ValueofDB:PayBankID AND (b.PeriodBalaBase - @ValueofDB:PayAmt)&lt;0 AND (b.SubCode like '1001%' or b.SubCode like '1002%')</select>
        </condition>
        <exec condition="&quot;@SqlReturn:AccountName&quot;.length != 0 &amp;&amp; &quot;@SqlReturn:AccountName&quot; != &quot;null&quot; &amp;&amp; &quot;@MEM:NoAccNegative&quot; == &quot;true&quot;">
            <error>AccNegative.Account.error,@SqlReturn:AccountName</error>                     
        </exec> 
    </sql>
    <sql type="condition"><!--外币代码暂不处理-->
        <condition>
        <!--检查明细表中选择的帐户是否跟主表中选择的帐户为同一核算币种的-->        
        <select>select tblUserTransAccDet.ReceiveBankNo,tblAccTypeInfo.Currency from tblUserTransAccDet left join tblAccTypeInfo on tblAccTypeInfo.AccNumber=tblUserTransAccDet.ReceiveBankNo where tblAccTypeInfo.Currency != (select tblAccTypeInfo.Currency from tblUserTransAcc left join tblAccTypeInfo on tblAccTypeInfo.AccNumber=tblUserTransAcc.PayBankID where tblUserTransAcc.id=@ValueofDB:tblUserTransAcc_id) and tblUserTransAccDet.f_ref = @ValueofDB:tblUserTransAcc_id and tblAccTypeInfo.ScompanyID=@Sess:SCompanyID</select>
        <!--检查表头账户的币种核算，与所选的币种不是同一核算币种的-->        
        <select>select tblUserTransAcc.PayBankID as NoSameCodePay from tblUserTransAcc left join tblAccTypeInfo on tblAccTypeInfo.AccNumber=tblUserTransAcc.PayBankID where (tblAccTypeInfo.Currency!=tblUserTransAcc.Currency) and tblUserTransAcc.id = @ValueofDB:tblUserTransAcc_id</select>
        <!--检查明细表明细账户的币种核算，与所选的币种不是同一核算币种的-->        
        <select>select tblUserTransAccDet.ReceiveBankNo as NoSameCodeRec from tblUserTransAccDet join tblUserTransAcc on tblUserTransAcc.id=tblUserTransAccDet.f_ref left join tblAccTypeInfo on tblAccTypeInfo.AccNumber=tblUserTransAccDet.ReceiveBankNo where (tblAccTypeInfo.Currency!=tblUserTransAcc.Currency) and tblUserTransAccDet.f_ref = @ValueofDB:tblUserTransAcc_id</select>
        <select>select count(0) as ErrorDataC from tblUserTransAccDet where (len(ReceiveBankID)=0 and ReceiveAmt!=0) or (len(ReceiveBankID)!=0 and ReceiveAmt=0)</select>
        </condition>
        <!--存在明细跟主表选择的帐户不为同一核算的币种时报错-->
        <exec condition="'@SqlReturn:ReceiveBankNo' != 'null' &amp;&amp; '@SqlReturn:ReceiveBankNo'.length != 0">       
            <error>Currency.DoubleError.error,@SqlReturn:ReceiveBankNo</error> 
        </exec>
      <!--存在表头账户的币种核算，与所选的币种不是同一核算币种的-->
        <exec condition="'@SqlReturn:NoSameCodePay' != 'null' &amp;&amp; '@SqlReturn:NoSameCodePay'.length != 0">       
            <error>Currency.Transferout.error</error> 
        </exec>
        <!--存在明细表明细账户的币种核算，与所选的币种不是同一核算币种的-->  
        <exec condition="'@SqlReturn:NoSameCodeRec' != 'null' &amp;&amp; '@SqlReturn:NoSameCodeRec'.length != 0">       
            <error>Currency.TransferIn.error</error> 
        </exec>
        <!--如果是外币帐户，必须录入汇率-->   
        <exec condition=" ('@ValueofDB:tblUserTransAcc_Currency'.length != 0 &amp;&amp; @ValueofDB:tblUserTransAcc_CurrencyRate &lt;= 0 )">       
            <error>CurrencyRate.InputError.error</error> 
        </exec>
      <!--如果是本位币帐户，不用录入汇率-->    
        <exec condition=" ('@ValueofDB:tblUserTransAcc_Currency'.length == 0 &amp;&amp; @ValueofDB:tblUserTransAcc_CurrencyRate &gt; 0 &amp;&amp; @ValueofDB:tblUserTransAcc_CurrencyRate!=1)">       
            <error>CurrencyRate.putErrors.error</error> 
        </exec>
    </sql>  
    <sql type="condition">
			<exec condition="true">
				<sql>update tblUserTransAcc set CertificateNo='' where id=@ValueofDB:tblUserTransAcc_id</sql>
			</exec>
			<exec condition="'@MEM:tblUserTransAcc_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
				<sql type="define">tblUserTransAcc_Add_One</sql>
			</exec>
    </sql>  
</define>
<define name="tblUserTransAcc_Add_One">
    <sql type="condition">
        <exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblUserTransAcc</sql></exec>
    </sql>  
</define>
<define name="tblUserTransAcc_Del">
    <sql type="condition">
        <exec condition="'@MEM:tblUserTransAcc_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
            <sql type="define">tblUserTransAcc_Del_One</sql>
        </exec>
    </sql>
</define>   
<define name="tblUserTransAcc_Del_One">
    <sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
        <condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblUserTransAcc_id and workFlowNodeName='finish'</select></condition>
        <exec condition="'@SqlReturn:OrderNo'!='null'"> 
            <error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
        </exec>
    </sql>
    <!--删除凭证审核流或者减少科目余额，删除凭证信息-->
    <sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblUserTransAcc_id,retCode,retVal)}</sql>
</define>
<!--======================================================以上代码：现金银行转账单=======================================================--> 

<!--=======================================================月结、年结=======================================================--> 
<!--===========月结产生凭证代码==========-->
<define name="Settle_CreateAcc">
	<!--采购换货单-->
	<sql type="certificate">tblBuyReplace_SettleAcc</sql>
	<!--采购退货单-->
	<sql type="certificate">tblBuyOutStock_SettleAcc</sql>
	<!--销售出库单-->
	<sql type="certificate">tblSalesOutStock_SettleAcc</sql>
	<!--销售退货单-->
	<sql type="certificate">tblSalesReturnStock_SettleAcc</sql>
	<!--销售换货单-->
	<sql type="certificate">tblSalesReplace_SettleAcc</sql>
	<!--盘盈盘亏单-->
	<sql type="certificate">tblCheck_SettleAcc</sql>
	<!--变价调拨单-->
	<sql type="certificate">tblAllotChange_SettleAcc</sql>
	<!--配送单-->
	<sql type="certificate">tblSend_SettleAcc</sql>
	<!--配送验收单-->
	<sql type="certificate">tblSendcheck_SettleAcc</sql>
	<!--其他出库单-->
	<sql type="certificate">tblOtherOut_SettleAcc</sql>
	<!--存货调价单-->
	<sql type="certificate">tblAdjustPrice_SettleAcc</sql>
	<!--组拆装单-->
	<sql type="certificate">tblGoodsAssemblySplit_SettleAcc</sql>
</define>
<!--============重算成本==================-->
<define name="reCalcucateData">
	
</define>
<!--===================================================以上代码：月结、年结=======================================================--> 

</defineSqls>