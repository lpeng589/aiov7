<?xml version="1.0" encoding="gb2312"?>
<defineSqls>
<!--====================================================销售报价单======================================================-->
<define name="tblSalseQuote_add">	
	<sql type="condition">
		<!--如果有录入价格有效期，判断价格有效期小于单据日期，给出提示-->
		<exec condition="'@ValueofDB:tblSalseQuote_Validity'.length&gt;0&amp;&amp;'@ValueofDB:tblSalseQuote_Validity'&lt;'@ValueofDB:tblSalseQuote_BillDate'">				
			<error>tblBuyAskPrice.PriceDate.error</error>       
		</exec>
		<!--录入税率不能为负数-->			
		<exec condition="'@ValueofDB:tblSalseQuote_TaxR'&lt;0">		
			<error>common.tax.negative.error</error>                  
		</exec>
        <!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
        <exec condition="'@MEM:Availably'=='true'">     
            <sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
               update tblSalseQuoteDet set Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblSalseQuote  a join tblSalseQuoteDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblSalseQuote_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblSalseQuoteDet.id=a.id</sql>
            <sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
               update tblSalseQuoteDet set ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblSalseQuote a join tblSalseQuoteDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblSalseQuote_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblSalseQuoteDet.id=a.id</sql>
        </exec>
	</sql>		
	<sql type="condition"><!--提示录入大于0的数量-->
		<condition><select>select b.GoodsFullName as GoodsQ,Qty from tblSalseQuoteDet a,tblGoods b where b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalseQuote_id and isnull(a.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">				
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>	
	<sql type="condition"><!--录入大于0的单价-->	
		<condition><select>select b.GoodsFullName as GoodsP,Qty from tblSalseQuoteDet a,tblGoods b where b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalseQuote_id and isnull(a.Price,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsP' != 'null' ">				
			<error>common.price.negative.error,@SqlReturn:GoodsP</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--启用了价格控制，判断商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblSalseQuote_Add_PriceControl_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblSalseQuote_Currency'.length == 0 &amp;&amp; @ValueofDB:tblSalseQuote_CurrencyRate&gt; 0 &amp;&amp; @ValueofDB:tblSalseQuote_CurrencyRate!=1)">		
			<error>CurrencyRate.putErrors.error</error>       
		</exec>
	</sql>		
	<sql type="condition"><!--合计金额与明细表合计金额不相等,给出错误提示-->
		<condition><select>select dbo.getDigits('tblSalseQuoteDet','TaxAmount',sum(tblSalseQuoteDet.TaxAmount)) as SumDetAmt from tblSalseQuoteDet where  tblSalseQuoteDet.f_ref=@ValueofDB:tblSalseQuote_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt !=@ValueofDB:tblSalseQuote_TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblSalseQuote_TotalTaxAmount,@SqlReturn:SumDetAmt</error>       
		</exec>
	</sql>
</define>
<!--====启用了系统配置后，价格控制的判断=======-->
<define name="tblSalseQuote_Add_PriceControl_Validate">
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalseQuoteDet a,ViewPriceControl b,tblGoods c where a.f_ref=@ValueofDB:tblSalseQuote_id and UserID=@ValueofDB:tblSalseQuote_createBy and b.ControlType='Sell' and b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and (a.Price&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.Price&gt;b.HighestPrice))</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
</define>

<!--不管是否启用审核流，修改或者删除都会调用此define，但启用了审核流能够修改或者删除说明是未审核完成，未审核的单据不需要下面的判断-->
<define name="tblSalseQuote_Delete">
	<sql type="condition">
		<exec condition="@MEM:tblSalseQuote_IsStatart==0 &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSalseQuote_Del_One</sql> 
		</exec>
	</sql>
</define>

<define name="tblSalseQuote_Del_One">
	<sql type="condition">
		<condition><select>select BillNo from tblSalesOrder where RefSalseQuoteid=@ValueofDB:tblSalseQuote_id</select></condition>
		<exec condition="'@SqlReturn:BillNo' != 'null'">	 					
			<error>ids.noallow.delete,@SqlReturn:BillNo</error>       
		</exec>
	</sql>
</define>
<!--================================================以上代码：销售报价单=======================================================-->

<!--销售出库时的商品是否启用序列号验证-->
<define name="tblSalesOutStockDet_GoodsSeqSet">
<sql type="condition">
<condition>
<select>select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblSalesOutStockDet_GoodsCode
</select>
</condition>
<exec condition="@SqlReturn:isUsed == 0">
<error>goodsseq.set.res</error>       
</exec>
</sql>
</define>

<!--积分换商品时的商品是否启用序列号验证-->
<define name="tblItegralExchangeGoodsDet_GoodsSeqSet">
<sql type="condition">
<condition>
<select>
select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblItegralExchangeGoodsDet_GoodsCode
</select>
</condition>
<exec condition="@SqlReturn:isUsed == 0">
<error>goodsseq.set.res</error>       
</exec>
</sql>
</define>

<!--销售退货时的商品是否启用序列号验证-->
<define name="tblSalesReturnStockDet_GoodsSeqSet">
<sql type="condition">
<condition>
<select>
select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblSalesReturnStockDet_GoodsCode
</select>
</condition>
<exec condition="@SqlReturn:isUsed == 0">
<error>goodsseq.set.res</error>       
</exec>
</sql>
</define>

<!--==========================================================销售订单===================================================================-->
<define name="tblSalesOrder_add">
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示(销售报价)-->
		<condition><select>select billDate as QuoteDate from tblSalseQuote where id=@ValueofDB:tblSalesOrder_RefSalseQuoteid</select></condition>
		<exec condition="'@ValueofDB:tblSalesOrder_RefSalseQuoteid'.length&gt;0&amp;&amp;'@ValueofDB:tblSalesOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblSalesOrder_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示（CRM报价）-->
		<condition><select>select billDate as QuoteDate from CRMsalesQuot where id=@ValueofDB:tblSalesOrder_CRMIDS</select></condition>
		<exec condition="'@ValueofDB:tblSalesOrder_CRMIDS'.length&gt;0&amp;&amp;'@ValueofDB:tblSalesOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblSalesOrder_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition"><!--单据日期在引用的单据之前，给出错误提示（客户合同）-->
		<condition><select>select billDate as QuoteDate from CRMSaleContract where id=@ValueofDB:tblSalesOrder_CRMpactID</select></condition>
		<exec condition="'@ValueofDB:tblSalesOrder_CRMpactID'.length&gt;0&amp;&amp;'@ValueofDB:tblSalesOrder_BillDate' &lt; '@SqlReturn:QuoteDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblSalesOrder_BillDate,@SqlReturn:QuoteDate</error>       
		</exec>
	</sql>
	<sql type="condition">
		<!--输入了预收订金，没有选择收款账户时给出提示-->
		<exec condition="@ValueofDB:tblSalesOrder_AccountAmount!=0 &amp;&amp; '@ValueofDB:tblSalesOrder_Account'.length==0 "> 
			<error>sales.ReceiveAccCode.error</error>       
		</exec>	
		<!--选择了收款账户，输入预收订金小于等于0时给出提示-->
		<exec condition="@ValueofDB:tblSalesOrder_AccountAmount&lt;=0 &amp;&amp; '@ValueofDB:tblSalesOrder_Account'.length &gt; 0 "> 
			<error>salesorder.PreAccAmt.error</error>       
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblSalesOrder_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblSalesOrder_Tax!=0)||@ValueofDB:tblSalesOrder_Tax&lt;0">			
			<error>common.isReceipt.existsTax.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--发货日期小于订单日期，给出错误提示-->
		<condition><select>select SendDate as SendDate from tblSalesOrderDet a where a.f_ref=@ValueofDB:tblSalesOrder_id and len(a.SendDate)!=0 and a.SendDate &lt; @ValueofDB:tblSalesOrder_BillDate </select></condition>
		<exec condition="'@SqlReturn:SendDate'!='null'"> 
			<error>SendDate.BillDate.error</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblSalesOrderDet a,tblGoods b where len(ProDate)&gt;0 and len(Availably)&gt;0 and ProDate&gt;Availably and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblBuyOrder_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--数量小于等于0时，给出错误提示-->
		<condition><select>select b.GoodsFullName as GoodsQ,Qty from tblSalesOrderDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOrder_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&lt;=0</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">						
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--非赠品，样品的单价小于等于0时，给出错误提示-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblSalesOrderDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOrder_id and a.PresentSampleType not in ('1','2') and b.classCode=a.GoodsCode and (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0))</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>	
	</sql>
	<sql type="condition"><!--折扣不是0到1之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesOrderDet a where a.f_ref=@ValueofDB:tblSalesOrder_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblSalesOrder_Add_PriceControl_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--商品是赠样品时单价不为零，给出错误提示-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblSalesOrderDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOrder_id and b.classCode=a.GoodsCode and a.PresentSampleType in ('1','2') and isnull(a.Price,0)!=0</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">	 					
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>       
		</exec>
	</sql>
	<!--<sql type="condition">明细表的金额不等于数量*单价
		<condition><select>select b.GoodsNumber,b.GoodsFullName from tblSalesOrderDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOrder_id and a.GoodsCode=b.classCode and Amount!=round(Qty*Price,@MEM:DigitsAmount)</select></condition>
		<exec condition="'@SqlReturn:GoodsNumber'!='null'">			
			<error>common.AmtPriceQty.NotEqual.error,@SqlReturn:GoodsNumber,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>		-->
	<sql type="condition"><!--总金额与明细表合计金额不相等，给出错误提示-->
		<condition><select>select dbo.getDigits('tblSalesOrderDet','TaxAmount',sum(tblSalesOrderDet.TaxAmount)) as SumDetAmt from tblSalesOrderDet where  f_ref=@ValueofDB:tblSalesOrder_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblSalesOrder_TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblSalesOrder_TotalTaxAmount,@SqlReturn:SumDetAmt</error>       
		</exec>	
	</sql>
	
	<!--====================外币暂不处理==================-->
	<sql type="condition">
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblSalesOrder_Account and SCompanyID=@ValueofDB:tblSalesOrder_SCompanyID</select></condition>
		<!--选择的帐号不是该外币对应的帐号-->
		<exec condition="'@ValueofDB:tblSalesOrder_Currency'.length != 0 &amp;&amp; '@ValueofDB:tblSalesOrder_Account'.length != 0 &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  ) "> 
				<error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>	
	
	  <!--币种为空，付款帐户不为空时，选择的付款帐户存在核算外币时提示-->	<!--选择的收款帐户不是该币种对应的帐户-->
		<exec condition="'@ValueofDB:tblSalesOrder_Currency'.length == 0 &amp;&amp; '@ValueofDB:tblSalesOrder_Account'.length != 0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL')">
				<error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>	 
		<!--如果是本位币帐户，不用录入汇率-->	
	 	<exec condition=" ('@ValueofDB:tblSalesOrder_Currency'.length == 0 &amp;&amp; @ValueofDB:tblSalesOrder_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblSalesOrder_CurrencyRate!=1)">		
    	  <error>CurrencyRate.putErrors.error</error>       
		</exec>
	</sql>
	<!--====================以上代码：外币暂不处理==================-->	
	

	<sql type="condition"><!--如果启用了“提示可用库存不足”的系统配置，判断库存是否足够-->		
		<exec condition="@MEM:UsableNotEnough==true">
			<sql type="define">tblSalesOrder_Add_UsableQty_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--如果没有执行上面是否的提示，继续执行此操作-->
		<exec condition="true">
			<sql type="define">tblSalesOrder_Add_One1</sql>
		</exec>
	</sql>	
</define>

<define name="tblSalesOrder_Add_One1">
	<sql type="condition">
		<!--没有启用多仓库，用主表仓库更新明细表上的仓库值-->
		<exec condition="'@MEM:ManyStockSales'=='false'">				  
			<sql>update tblSalesOrderDet set StockCode=@ValueofDB:tblSalesOrder_StockCode where f_ref=@ValueofDB:tblSalesOrder_id</sql>	
		</exec>
		<!--更新订单明细表中未出库数量=订单数量，未生产数量=订单数量-->
		<exec condition="true">		  
			<sql>update tblSalesOrderDet set OutQty=0,NotOutQty=Qty,FinishStatus=0,NeedReceiveAmt=TaxAmount,CurNeedReceiveAmt=CurAmount,NotPayQty=Qty,NoInvoiceAmount=TaxAmount,InvoiceAmount=0,InvoiceStatus=0 where f_ref=@ValueofDB:tblSalesOrder_id</sql>
			<sql>update tblSalesOrder set statusId=0,NeedReturnAmt=TotalTaxAmount-AccountAmount,CurNeedReturnAmt=CurTotalAmount-CurAccountAmount,AlrAccAmt=AccountAmount,NotAmortDeposit=AccountAmount,CurAlrAccAmt=CurAccountAmount,CurNotAmortDeposit=CurAccountAmount,PayAmt=0,CurPayAmt=0,CertificateNo='',NoInvoiceAmount=TotalTaxAmount,InvoiceAmount=0,InvoiceStatus=0 where id=@ValueofDB:tblSalesOrder_id</sql>
		</exec>	
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			update tblSalesOrderDet set tblSalesOrderDet.Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblSalesOrder  a join tblSalesOrderDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblSalesOrder_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblSalesOrderDet.id=a.id
			</sql>
			<sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			update tblSalesOrderDet set tblSalesOrderDet.ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblSalesOrder a join tblSalesOrderDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblBuyOrder_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblSalesOrderDet.id=a.id
			 </sql>
		</exec>
		<!--如果不启用审核流，调用过账的define-->
		<exec condition="'@MEM:tblSalesOrder_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSalesOrder_Add_One</sql>
		</exec>
	</sql>
</define>
<!--==============启用了提示可用库存，可用库存的判断============-->
<define name="tblSalesOrder_Add_UsableQty_Validate">
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsexistName from (select sum(Qty) as Qty,goodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,case when @MEM:ManyStockSales='false' then k.StockCode else f.StockCode end as StockCode from tblSalesOrder k,tblSalesOrderDet f where k.id=f.f_ref and f.f_ref=@ValueofDB:tblSalesOrder_id group by goodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,k.StockCode,f.StockCode) a,tblGoods c where a.goodsCode=c.classCode and a.Qty&gt;isnull((select sum(isnull(b.UseQty,0)) from ViewVirtualStock b where a.goodsCode=b.goodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO and a.ProDate=b.ProDate and a.Availably=b.Availably and b.LastQty&gt;0 and (a.StockCode=b.stockCode or len(isnull(a.StockCode,''))=0)),0)</select></condition>	
		<exec condition="'@SqlReturn:GoodsexistName' != 'null'">	 										 
			<confirm yesDefine="tblSalesOrder_Add_One1" noDefine="">select.estimate.do.stock,@SqlReturn:GoodsexistName</confirm>
		</exec>
	</sql>
</define>
<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=========-->
<define name="tblSalesOrder_Add_PriceControl_Validate">
	<!--=======不含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesOrderDet a,ViewPriceControl b,tblGoods c where a.f_ref=@ValueofDB:tblSalesOrder_id and UserID=@ValueofDB:tblSalesOrder_createBy and b.ControlType='Sell' and b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and a.PresentSampleType not in ('1','2') and (a.DisPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.DisPrice&gt;b.HighestPrice))</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">		
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
	<!--=======含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesOrderDet a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='SellTax' and UserID=@ValueofDB:tblSalesOrder_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblSalesOrder_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.TaxPriceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">		
			<error>common.TaxPriceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">		
			<error>common.TaxPriceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
</define>
<!--=========销售订单过账操作==========-->
<define name="tblSalesOrder_Add_One">		
  <sql type="condition">		
		<!--当预收订金大于0时，产生收款单，并影响往来，凭证-->
		<exec condition="@ValueofDB:tblSalesOrder_AccountAmount&gt;0">
			<sql type="define">tblSalesOrder_Add_PreReceive</sql>
		</exec>
	</sql>
</define>

<!--===========插入凭证，影响科目余额，影响往来===============-->
<define name="tblSalesOrder_Add_PreReceive">
	<sql type="condition">
		<!--未启用预收预付记应收应付,影响往来 （1应付 2应收 3预付 4预收）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false'"> 
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSalesOrder_id,@ValueofDB:tblSalesOrder_CompanyCode,4,@ValueofDB:tblSalesOrder_BillDate,Period=@ValueofDB:tblSalesOrder_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOrder_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOrder_PeriodMonth@SPFieldLink:PreReceiveTotalDebit=0@SPFieldLink:PreReceiveTotalLend=@ValueofDB:tblSalesOrder_AccountAmount@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOrder_id@SPFieldLink:Currency=@ValueofDB:tblSalesOrder_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOrder_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesOrder_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOrder_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOrder_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOrder_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOrder_SCompanyID@SPFieldLink:FcPreRecTotalDebit=0@SPFieldLink:FcPreRecTotalCredit=@ValueofDB:tblSalesOrder_CurAccountAmount@SPFieldLink:BillType=tblSalesOrder@SPFieldLink:BillNo=@ValueofDB:tblSalesOrder_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOrder_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOrder_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesOrder_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblSalesOrder_Remark,retCode,retVal)}</sql>
		</exec>	
		<!--已启用预收预付记应收应付,影响往来 （1应付 2应收 3预付 4预收）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='true'"> 
			<sql type="procedure">{call proc_insertComIni(@ValueofDB:tblSalesOrder_id,@ValueofDB:tblSalesOrder_CompanyCode,2,@ValueofDB:tblSalesOrder_BillDate,Period=@ValueofDB:tblSalesOrder_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOrder_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOrder_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblSalesOrder_AccountAmount@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOrder_id@SPFieldLink:Currency=@ValueofDB:tblSalesOrder_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOrder_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesOrder_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOrder_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOrder_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOrder_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOrder_SCompanyID@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSalesOrder_CurAccountAmount@SPFieldLink:BillType=tblSalesOrder@SPFieldLink:BillNo=@ValueofDB:tblSalesOrder_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOrder_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOrder_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesOrder_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblSalesOrder_Remark,retCode,retVal)}</sql>
		</exec>	
		<exec condition="true"> <!--产生销售收款单-->	
			<sql type="define">tblSalesOrder_Add_CreateReceBill</sql>
		</exec>	
    <!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'">
			<sql type="certificate">tblSalesOrder</sql>                  
		</exec>
	</sql>    
</define>

<!--=========如果预收订金大于0，生成销售收款单==========-->
<define name="tblSalesOrder_Add_CreateReceBill">
	<sql type="condition">
		<condition><select>select (cast(@ValueofDB:tblSalesOrder_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblSalesOrder_AccountAmount as numeric(18,8))) as NeedRec,(case when @ValueofDB:tblSalesOrder_Account like '1001%' then 1 else (case @MEM:prerecvpaymarktoneedrecvpay when 'true' then 1 else 3 end) end) as SettleType,(case @MEM:prerecvpaymarktoneedrecvpay when 'true' then 'Receive' else 'PreReceive' end) as AcceptType</select></condition>
		<exec condition="true">
			<sql>insert into tblSaleReceive (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,SettleType,AcceptTypeID,ExeBalAmt,FactIncome,AccAmt,Currency,CurrencyRate,BillFcAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblSalesOrder_id,@ValueofDB:tblSalesOrder_BillDate,@CODE:[tblSaleReceive_BillNo],@ValueofDB:tblSalesOrder_CompanyCode,@ValueofDB:tblSalesOrder_DepartmentCode,@ValueofDB:tblSalesOrder_EmployeeID,@SqlReturn:SettleType,'PreReceive',@ValueofDB:tblSalesOrder_AccountAmount,@ValueofDB:tblSalesOrder_AccountAmount,@ValueofDB:tblSalesOrder_AccountAmount,@ValueofDB:tblSalesOrder_Currency,@ValueofDB:tblSalesOrder_CurrencyRate,@ValueofDB:tblSalesOrder_CurAccountAmount,@ValueofDB:tblSalesOrder_PeriodYear,@ValueofDB:tblSalesOrder_PeriodMonth,@ValueofDB:tblSalesOrder_Period,@ValueofDB:tblSalesOrder_createBy,@ValueofDB:tblSalesOrder_createTime,@ValueofDB:tblSalesOrder_lastUpdateBy,@ValueofDB:tblSalesOrder_lastUpdateTime,@ValueofDB:tblSalesOrder_SCompanyID,1,'finish','-1','',@ValueofDB:tblSalesOrder_TrackNo)</sql>
			<sql>insert into tblSaleReceivedet (id,f_ref,BillAmt,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,SalesOrderNo,SalesOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,ReceiveBillType) values ('1'+@ValueofDB:tblSalesOrder_id,'0'+@ValueofDB:tblSalesOrder_id,@ValueofDB:tblSalesOrder_TotalTaxAmount,@ValueofDB:tblSalesOrder_CurTotalAmount,(case when cast(@SqlReturn:NeedRec as numeric(18,8))&gt;=0.0 then @ValueofDB:tblSalesOrder_AccountAmount else @ValueofDB:tblSalesOrder_TotalTaxAmount end),(case when cast(@SqlReturn:NeedRec as numeric(18,8))&gt;=0.0 then @ValueofDB:tblSalesOrder_CurAccountAmount else @ValueofDB:tblSalesOrder_CurTotalAmount end),@ValueofDB:tblSalesOrder_Currency,@ValueofDB:tblSalesOrder_CurrencyRate,0,@ValueofDB:tblSalesOrder_TotalTaxAmount,0,@ValueofDB:tblSalesOrder_CurTotalAmount,@ValueofDB:tblSalesOrder_BillNo,@ValueofDB:tblSalesOrder_BillNo,@ValueofDB:tblSalesOrder_id,0,@ValueofDB:tblSalesOrder_SCompanyID,0,@ValueofDB:tblSalesOrder_id,'tblSalesOrder')</sql>
		</exec>
		<!--如果启用了多账户，向多账户明细表中插入数据-->
		<exec condition="true">
			<sql>insert into tblReceiveAccountDet (id,f_ref,SettleType,Amount,ExeBalFcAmt,Account,SCompanyID) values ('1'+@ValueofDB:tblSalesOrder_id,'0'+@ValueofDB:tblSalesOrder_id,@SqlReturn:SettleType,@ValueofDB:tblSalesOrder_AccountAmount,@ValueofDB:tblSalesOrder_CurAccountAmount,@ValueofDB:tblSalesOrder_Account,@ValueofDB:tblSalesOrder_SCompanyID)</sql>
		</exec>
		<!--自动生成的单据需更新单据编号连续-->
		<exec condition="'@MEM:BillNoSequence'=='true'">  
			<sql>update tblCodeGenerate set curValue=curValue+1 where code='SE'</sql>
		</exec>	
		<!--向追踪单号表中插入数据-->
		<exec condition="'@MEM:TrackNo'=='true'">  
			<sql>insert into tblTrackBill(id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID) select  substring(replace(newid(),'-',''),1,30),id,BillNo,'tblSaleReceive',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblSaleReceive where id='0'+@ValueofDB:tblSalesOrder_id</sql>
		</exec>
	</sql>
</define>
<!--============删除销售订单=============-->
<!--不管是否启用审核流，修改或者删除都会调用此define，但启用了审核流能够修改或者删除说明是未审核完成，未审核的单据不需要下面的判断-->
<define name="tblSalesOrder_Del">
	<sql type="condition">
		<exec condition="@MEM:tblSalesOrder_IsStatart==0 &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSalesOrder_Del_One</sql> 
		</exec>
		<!--修改电商销售订单的导入状态-->
		<exec condition="true">
			<sql>update tblEBOrder set InSign='1' where id=@ValueofDB:tblSalesOrder_id</sql> 
		</exec>
	</sql>
</define>	
<define name="tblSalesOrder_Del_One">
	<!--=======删除的控制类操作===============-->
	<!--若是订单状态不是未完成,不允许执行数据更新操作 -->
	<sql type="condition">
		<condition><select>select statusId from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id</select></condition>
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.noNormallyStatus.oper.error</error>       
		</exec>
	</sql>
	<!--凭证启用了审核流，关联次单据的审核流已经审核完毕，不能修改此单 -->
	<sql type="condition">
		<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblSalesOrder_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!= 'null' ">	 					
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
	</sql>
	<!--被采购订单引用，不能修改此单 -->
	<sql type="condition">
		<condition><select>select BillNo as BuyBillNo from tblBuyOrder where SalesOrderID=@ValueofDB:tblSalesOrder_id</select></condition>
		<exec condition="'@SqlReturn:BuyBillNo'!='null'">
        	<error>tblbuyOrder.delete.quoted,@SqlReturn:BuyBillNo</error>       
		</exec>
	</sql>
	<!--被销售出库单引用，不允许修改 -->
	<sql type="condition">
		<condition><select>select BillNo as SalBillNo from tblSalesOutStock a,tblSalesOutStockDet b where a.id=b.f_ref and b.SalesOrderID=@ValueofDB:tblSalesOrder_id and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:SalBillNo' != 'null'">	 					
			<error>tblSalesOrder.delete.quoted,@SqlReturn:SalBillNo</error>       
		</exec>
	</sql>
	<!--存在不是自动生成的相关的收款单，不允许修改 -->
	<sql type="condition">
		<condition><select>select a.BillNo as RecBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and b.RefbillID=@ValueofDB:tblSalesOrder_id and a.AutoBillMarker=0 and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:RecBillNo'!='null'">	 					
			<error>DelBill.ReBillNo.error,@SqlReturn:RecBillNo</error>       
		</exec>
	</sql>
	<!--存在自动生成的收款单存在关联的收款退款单，不允许修改 -->
	<sql type="condition">
		<condition><select>select a.BillNo as RecRfBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and b.RefbillID=(select c.id from tblSaleReceive c,tblSaleReceiveDet d where c.id=d.f_ref and d.RefbillID=@ValueofDB:tblSalesOrder_id and c.AutoBillMarker=1) and a.workFlowNodeName!='print'</select></condition>
		<exec condition="'@SqlReturn:RecRfBillNo'!='null'">	 					
			<error>DelBill.RecRBillNo.error,@SqlReturn:RecRfBillNo</error>       
		</exec>
	</sql>
	<!--被生成计划单引用，不允许修改
	<sql type="condition">
		<condition><select>select BillNo as PlanBillNo from tblPlan where RefBillID=@ValueofDB:tblSalesOrder_id</select></condition>
		<exec condition="'@SqlReturn:PlanBillNo' != 'null'">	 					
			<error>tblSalesOrder.tblPlan1.quoted,@SqlReturn:PlanBillNo</error>       
		</exec>
	</sql>-->

	<!--========删除的逻辑操作===========-->
	<sql type="condition">
		<condition><select>select AccountAmount from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id</select></condition>		
		<exec condition="true">	<!--删除虚拟库存不足提醒细记录-->
			<sql>delete from tblNotEnoughStock where RefBillId=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
		<!--根据是否启用预收预付记应收应付, 预收订金大于0时，删除凭证、往来、收款单, 删除本单据的往来记录（1应付 2应收 3预付 4预收)-->
		<exec condition="@SqlReturn:AccountAmount&gt;0">								
			<sql type="procedure">{call proc_iterateExeProc(select id as IniId from tblCompanyIni where relationDocID='@ValueofDB:tblSalesOrder_id',proc_deleteComIni,@IniId@ParamLink:(case when '@MEM:prerecvpaymarktoneedrecvpay'='true' then 2 else 4 end),retCode,retVal)}</sql>
		</exec>
		<exec condition="true">				
			<!--删除凭证审核流或者减少科目余额，删除凭证信息-->
			<sql type="define">tblSalesOrder_Del_DeleteAcc</sql>
			<!--删除销售收款单信息-->
			<sql>delete from tblSaleReceive where id in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOrder_id)</sql>
			<sql>delete from tblSalesRecAccount where f_ref=(select top 1 f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOrder_id)</sql>
			<sql>delete from tblTrackBill where RelationID in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOrder_id)</sql>
			<sql>delete from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
	</sql>
</define>		
<!--===========删除凭证操作=========-->
<define name="tblSalesOrder_Del_DeleteAcc">
	<sql type="condition"> 
	 	<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		 	<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblSalesOrder_id,retCode,retVal)}</sql>
		</exec>
	</sql>
</define>

<!--销售订单终止按钮-->
<define name="SalesOrderStatus_stop">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>       
		</exec>
		<!--单据状态是终止状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==2">
			<error>common.cannotStop.error</error>       
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblSalesOrder set statusId=2 where id=@ValueofDB:tblSalesOrder_id</sql>
			<sql>update tblSalesOrderDet set NotOutQty=0,FinishStatus=2 where f_ref=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
   </sql>
</define>
<!--销售订单完成按钮-->
<define name="SalesOrderStatus_finish">
   <sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>       
		</exec>
		<!--单据状态不是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId!=0">
			<error>common.cannotFinish.error</error>       
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblSalesOrder set statusId=1 where id=@ValueofDB:tblSalesOrder_id</sql>
			<sql>update tblSalesOrderDet set NotOutQty=0,FinishStatus=1 where f_ref=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
   </sql>
</define>
<!--销售订单激活按钮-->
<define name="SalesOrderStatusStop_reverse">
	<sql type="condition">
		<condition><select>select statusId,workFlowNodeName,StockCode from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id</select></condition>
		<!--单据没有审核完毕，不可以执行此操作-->
		<exec condition="'@SqlReturn:workFlowNodeName' != 'finish'">
			<error>Common.NotApproveNoOper.error</error>       
		</exec>
		<!--单据状态是未完成状态，不允许执行此操作-->
		<exec condition="@SqlReturn:statusId==0">
			<error>common.cannotActive.error</error>       
		</exec>
		<!--修改主表的状态，和明细表的未下订单数量-->
		<exec condition="true">
			<sql>update tblSalesOrder set statusId=0 where id=@ValueofDB:tblSalesOrder_id</sql>
			<sql>update tblSalesOrderDet set NotOutQty=case when isnull(Qty,0)-isnull(OutQty,0)&lt;0 then 0 else isnull(Qty,0)-isnull(OutQty,0) end,FinishStatus=0 where f_ref=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
	</sql>
</define>

<!--销售订单产生采购订单-->
<define name="tblSalesOrder_CreateBuyOrder">
	<sql type="condition"><!--没有审核完毕给出错误提示-->
		<condition><select>select count(0) as checkC from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id and workFlowNodeName!='finish'</select></condition>		
		<exec condition="@SqlReturn:checkC&gt;0">
			<error>tblSalesOrder.notApp.error</error>
		</exec>	
	</sql>
	<sql type="condition"><!--已经生成采购订单给出错误提示-->
		<condition><select>select count(0) as checkC from tblSalesOrder where id=@ValueofDB:tblSalesOrder_id and hasBuyOrder=1</select></condition>
		<exec condition="@SqlReturn:checkC&gt;0">
			<error>tblSalesOrder.hasBuyOrder.error</error>
		</exec>	
	</sql>
	<sql type="condition"><!--系统时间所在的期间已经月结，给出错误提示-->
		<condition><select>select a.statusId as periodStatusId from tblAccPeriod a,tblSalesOrder b where b.id=@ValueofDB:tblSalesOrder_id and a.AccPeriod=b.Period and a.AccYear=b.PeriodYear</select></condition>
		<exec condition="@SqlReturn:periodStatusId==2">
			<error>tblSalesOrder.settleMonthBuyOrder.error</error>
		</exec>	
	</sql>
	
	<sql type="condition">
  	<condition><select>select (case @MEM:tblBuyOrder_IsStatart when 0 then '-1' else '0' end) as WFNode,(case @MEM:tblBuyOrder_IsStatart when 0 then 'finish' else 'notApprove' end) as WFName,(case @MEM:tblBuyOrder_IsStatart when 0 then '' else ';'+@Sess:UserId+';' end) WFPerson</select></condition>
		<exec condition="true">
			<sql>insert into tblBuyOrder (id,createBy,lastUpdateBy,createTime,lastUpdateTime,ApproveRec,TotalAmount,BackAmount,Account,PeriodYear,PeriodMonth,Period,PayStatus,TotalPayAmt,Attachment,Remark,BillNo,BillDate,CompanyCode,EmployeeID,DepartmentCode,StockCode,SCompanyID,DiscountAmount,workFlowNode,workFlowNodeName,checkPersons,AutoBillMarker,SalesOrderID,TrackNo,BuyApplyNo,BuyApplyID,InvoiceType,TradeType,statusId,finishTime,NotAmortDeposit,ReceiveAmt,Tax,TotalCoTaxAmt,CertificateNo,Discount,Currency,CurrencyRate) select substring(replace(newid(),'-',''),1,28),@Sess:UserId,@Sess:UserId,@MEM:sysLongDate,@MEM:sysLongDate,'0',0,0,'',PeriodYear,PeriodMonth,Period,0,0,'','',a.BillNo+'_'+cast(ROW_NUMBER() over(order by c.companyCode) as varchar(10)),a.BillDate,c.CompanyCode,@Sess:UserId,@Sess:DepartmentCode,a.StockCode,a.SCompanyID,0,@SqlReturn:WFNode,@SqlReturn:WFName,@SqlReturn:WFPerson,1,@ValueofDB:tblSalesOrder_id,'','','',a.InvoiceType,'CreditBuy',0,@MEM:sysLongDate,0,0,a.Tax,0,'',a.Discount,a.Currency,a.CurrencyRate from tblSalesOrder a,tblSalesOrderDet b,tblGoods c where a.id=@ValueofDB:tblSalesOrder_id and a.id=b.f_ref and b.GoodsCode=c.classCode group by c.CompanyCode,a.SCompanyID,A.BillDate,A.PeriodYear,a.PeriodMonth,a.Period,a.StockCode,a.BillDate,a.BillNo,a.InvoiceType,a.Tax,a.Discount,a.Currency,a.CurrencyRate</sql>
	
			<sql>insert into tblBuyOrderDet(id,f_ref,SourceID,StockCode,GoodsCode,Unit,BatchNo,Inch,Hue,yearNO,ProDate,Availably,ArriveDate,Qty,Price,Amount,Discount,DisPrice,DisBackAmt,TaxPrice,TaxAmount,CoTaxAmt,FinishStatus,NotInQty,SCompanyID,SecUnit,BaseQty,SecQty,UnitIntQty,UnitBaseQty,UnitQty,UnitPrice,NotPayQty,InQty,PresentSampleType,CurPrice,CurAmount,DisAmount) select substring(replace(newid(),'-',''),1,30),k.id,a.id,a.StockCode,a.GoodsCode,a.Unit,BatchNo,Inch,Hue,yearNO,ProDate,Availably,'',a.Qty,b.PreBuyPrice,round(a.Qty*b.PreBuyPrice,@MEM:DigitsAmount),a.Discount,b.PreBuyPrice*a.Discount/100,round(a.Qty*b.PreBuyPrice*a.Discount/100,@MEM:DigitsAmount),(1+k.Tax/100)*b.PreBuyPrice*a.Discount/100,round((1+k.Tax/100)*a.Qty*b.PreBuyPrice*a.Discount/100,@MEM:DigitsAmount),round(k.Tax/100*a.Qty*b.PreBuyPrice*a.Discount/100,@MEM:DigitsAmount),0,Qty,a.SCompanyID,a.SecUnit,BaseQty,SecQty,a.UnitIntQty,a.UnitBaseQty,a.UnitQty,(case BaseQty when 0 then 0 else b.PreBuyPrice*(SecQty/BaseQty) end),a.Qty,0,(case when b.PreBuyPrice=0 then '1' else '' end),(1+k.Tax/100)*b.PreBuyPrice*a.Discount/100*k.CurrencyRate,round((1+k.Tax/100)*a.Qty*b.PreBuyPrice*a.Discount/100,@MEM:DigitsAmount)/k.CurrencyRate,round(a.Qty*b.PreBuyPrice,@MEM:DigitsAmount)-round(a.Qty*b.PreBuyPrice*a.Discount/100,@MEM:DigitsAmount) from tblSalesOrderDet a,tblGoods b,tblBuyOrder k where a.GoodsCode=b.classCode and a.f_ref=@ValueofDB:tblSalesOrder_id and k.SalesOrderID=a.f_ref and AutoBillMarker=1 and k.CompanyCode=b.CompanyCode</sql>
			<sql>update tblBuyOrder set TotalAmount=a.DisBackAmt,TotalTaxAmount=a.taxAmount,TotalCoTaxAmt=a.CoTaxAmt,DisAmount=Amount-a.DisBackAmt,CurTotalAmount=a.CurAmount from (select a.id,SUM(b.TaxAmount) as taxAmount,SUM(CoTaxAmt) as CoTaxAmt,SUM(DisBackAmt) as DisBackAmt,SUM(b.Amount) as Amount,SUM(CurAmount) as CurAmount from tblBuyOrder a,tblBuyOrderDet b where a.id=b.f_ref and a.AutoBillMarker=1 and a.SalesOrderID=@ValueofDB:tblSalesOrder_id group by a.id) as a where a.id=tblBuyOrder.id and tblBuyOrder.AutoBillMarker=1 and tblBuyOrder.SalesOrderID=@ValueofDB:tblSalesOrder_id</sql>
			<sql>update tblSalesOrder set HasBuyOrder=1 where id=@ValueofDB:tblSalesOrder_id</sql>
		</exec>
		<!--如果采购订单启用了审核流，则插入一条记录OAMyWorkFlow 审核人为自己-->
		<exec condition="'@MEM:tblBuyOrder_IsStatart' == '1'">
			<sql>insert into OAMyWorkFlow(id,applyDate,applyType,tableName,keyId,createBy,checkPerson,currentNode,createtime,lastUpdatetime,nextNodeIds,departmentCode,statusId) select 'w'+id,convert(varchar(10),getdate(),120),(select top 1 id from OAWorkFlowTemplate where templateFile='tblBuyOrder' and statusId=0),'tblBuyOrder',id,@Sess:UserId,';'+@Sess:UserId+';',0,@MEM:sysLongDate,@MEM:sysLongDate,'',(select departmentCode from tblEmployee a where a.id=@Sess:UserId),0 from tblBuyOrder where SalesOrderID=@ValueofDB:tblSalesOrder_id and AutoBillMarker=1</sql>
		</exec>
	</sql>
</define>


<!--==========================================================以上代码：销售订单=========================================================-->	

<!--=====删除销售出库单据时如引起负库存，提示开始引起出现负库存的单据======-->
<define name="NegativeInStock_tblSalesOutStock">
<sql type="condition">
 <condition>
 <select>select id as SalesOutID from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id</select>
 </condition>
 <exec condition="@MEM:NegativeStock != true">
<sql type="procedure"> 
  {call proc_negativeUpdateInStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,NegativeCode,NegativeBillNo)}
  </sql> 
  </exec>
 </sql>
</define>
<!--=====删除单据时如引起负库存，提示开始引起出现负库存的单据======-->

<!--=====删除销售出库单据时如引起负库存，提示开始引起出现负库存的单据不提示错误窗======-->
<define name="NegativeInStock_tblSalesOutStock_Noerror">
<sql type="condition">
 <condition>
 <select>select id as SalesOutID from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id</select>
 </condition>
 <exec condition="@MEM:NegativeStock != true">
<sql type="procedure"> 
  {call proc_negativeUpdateInStock(@Sess:Local,@SqlReturn:SalesOutID,@Sess:SCompanyID,retCode,retVal)}
  </sql> 
  </exec> 
 </sql>
</define>
<!--=====删除单据时如引起负库存，提示开始引起出现负库存的单据======-->

<!--===============================================================销售出库单===========================================================-->		
<define name="SalesOutStock_Add">
	<!--如果启用了“销售出库必须引用销售订单”的系统配置，如果没有引用给出错误提示-->
	<sql type="condition">
		<condition><select>select count(0) NoQuote from tblSalesOutStockDet a left join tblSalesOrderDet b on isnull(a.SalesOrderID,'')=b.f_ref and a.GoodsCode=b.GoodsCode and (a.BatchNo=b.BatchNo or b.BatchNo='') and (a.Inch=b.Inch or b.Inch='') and (a.Hue=b.Hue or b.Hue='') and (a.yearNo=b.yearNo or b.yearNo='') and (a.ProDate=b.ProDate or b.ProDate='') and (a.Availably=b.Availably or b.Availably='') where @MEM:QuoteSalOrder ='true' and a.f_ref=@ValueofDB:tblSalesOutStock_id and b.id is null</select></condition>		
			<exec condition="@SqlReturn:NoQuote&gt;0">
				<error>SalesOutStock.quoteOrder.error</error>       
			</exec>
	</sql>		
	<sql type="condition">
		<!--如果本次结算金额小于零，提示错误--> 
		<exec condition="@ValueofDB:tblSalesOutStock_AccAmt &lt; 0">
			<error>negtive.Amount.error</error>       
	  </exec>
		<!--如果主表优惠后金额为负数 提示错误--> 
		<exec condition="@ValueofDB:tblSalesOutStock_TotalTaxAmount &lt; 0">
			<error>common.TotalTaxAmount.negative.error</error>       
	  </exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblSalesOutStock_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblSalesOutStock_Tax!=0)||@ValueofDB:tblSalesOutStock_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>        
		</exec>
		<!--如果代收金额小于零，提示错误--> 
		<exec condition="@ValueofDB:tblSalesOutStock_deputyReceAmt &lt; 0">
			<error>sales.deputyAmt.negtive.error</error>       
	  </exec>
		<!--代收款为是，则必须选择代收物流公司及代收金额-->
		<exec condition="'@ValueofDB:tblSalesOutStock_deputyRece'.length&gt;0&amp;&amp;('@ValueofDB:tblSalesOutStock_FreightCom'.length==0||@ValueofDB:tblSalesOutStock_deputyReceAmt==0)">				
			<error>sales.deputy.noData.error</error>        
		</exec>
		<!--有输入代收金额，必须勾选代收款，选择运输公司-->
		<exec condition="@ValueofDB:tblSalesOutStock_deputyReceAmt!=0&amp;&amp;('@ValueofDB:tblSalesOutStock_deputyRece'.length==0||'@ValueofDB:tblSalesOutStock_FreightCom'.length==0)">				
			<error>sales.deputyAmt.noData.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--明细表中的条码与商品表的条码复核不同给出提示--> 
		<condition><select>select c.GoodsFullName as CheckGoods from tblSalesOutStockDet b join tblSalesOutStock a on a.id=b.f_ref join tblGoods c on c.classCode=b.GoodsCode where @MEM:BarcodecheckedSalesOut='true' and a.id=@ValueofDB:tblSalesOutStock_id and c.BarCode!=b.CheckBarCode </select></condition>
		<exec condition="'@SqlReturn:CheckGoods' != 'null'">					
			<error>CheckBarCode.diffent.error,@SqlReturn:CheckGoods</error>       
		</exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblSalesOutStockDet a left join tblgoods c on c.classCode=a.GoodsCode where c.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblSalesOutStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>       
	  </exec>
	</sql>
	<sql type="condition"><!--数量小于等于0的商品判断-->
		<condition><select>select tblGoods.GoodsFullName as GoodsQ from tblSalesOutStockDet,tblGoods where isnull(tblSalesOutStockDet.Qty,0)&lt;=0 and tblGoods.classCode=tblSalesOutStockDet.GoodsCode and f_ref=@ValueofDB:tblSalesOutStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>
	<sql type="condition">
		<!--如果有引用单据，将引用ID映射到明细表-->			
		<exec condition="'@ValueofDB:tblSalesOutStock_SalesOrderID'.length&gt;0">  
			<sql>update tblSalesOutStockDet set SalesOrderID=@ValueofDB:tblSalesOutStock_SalesOrderID where f_ref=@ValueofDB:tblSalesOutStock_id and len(isnull(SalesOrderID,''))=0</sql>
		</exec>
		<!--引用销售订单的控制判断-->
		<exec condition="true">
			<sql type="define">tblSalesOutStock_Add_QuoteOrder_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--非赠品，样品单价小于等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblSalesOutStockDet a,tblGoods b where (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesOutStock_id and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--赠品，样品单价不等于0的商品判断-->
		<condition><select>select tblGoods.GoodsFullName as GoodsSample from tblSalesOutStockDet,tblGoods where isnull(tblSalesOutStockDet.Price,0)!=0 and tblGoods.classCode=tblSalesOutStockDet.GoodsCode and f_ref=@ValueofDB:tblSalesOutStock_id and tblSalesOutStockDet.PresentSampleType in ('1','2')</select>
		</condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>       
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblSalesOutStock_Add_PriceControl_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--折扣不是0到1之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesOutStockDet a where a.f_ref=@ValueofDB:tblSalesOutStock_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>

	<sql type="condition"><!--赠样品的单价为负数的判断-->
		<condition><select>select tblGoods.GoodsFullName as GoodsPresent from tblSalesOutStockDet,tblGoods where  f_ref=@ValueofDB:tblSalesOutStock_id and tblGoods.classCode=tblSalesOutStockDet.GoodsCode and tblSalesOutStockDet.PresentPrice&lt;0</select></condition>
		<exec condition="'@SqlReturn:GoodsPresent' != 'null'">				
			<error>tblSalesOutStock.Present.PriceOrAmt.error,@SqlReturn:GoodsPresent</error>        
		</exec>
	</sql>
	<!--<sql type="condition">明细表的金额不等于数量*单价  如果是录入的含税金额这里可能会差几分钱
		<condition><select>select b.GoodsNumber,b.GoodsFullName from tblSalesOutStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOutStock_id and a.GoodsCode=b.classCode and Amount!=round(Qty*Price,@MEM:DigitsAmount)</select></condition>
		<exec condition="'@SqlReturn:GoodsNumber'!='null'">			
			<error>common.AmtPriceQty.NotEqual.error,@SqlReturn:GoodsNumber,@SqlReturn:GoodsFullName</error>                  
		</exec>
	</sql>-->
	<sql type="condition"><!--主表总金额与明细表不相等-->
		<condition><select>select isnull(dbo.getDigits('tblSalesOutStockDet','TaxAmount',sum(tblSalesOutStockDet.TaxAmount)),'0') as SumDetAmt, dbo.getDigits('tblSalesOutStockDet','TaxAmount',(cast(@ValueofDB:tblSalesOutStock_TotalTaxAmount as numeric(18,8))+cast(@ValueofDB:tblSalesOutStock_DiscountAmount as numeric(18,8)))) as sumMainAmt from tblSalesOutStockDet where  f_ref=@ValueofDB:tblSalesOutStock_id</select></condition>
		<exec condition="@SqlReturn:SumDetAmt!=@SqlReturn:sumMainAmt">			
			<error>common.mainDetilAmt.NotEqual.error,@SqlReturn:sumMainAmt,@SqlReturn:SumDetAmt</error>       
		</exec>
	</sql>
	<sql type="condition"><!--启用了多账户，进行多账户的判断提示-->
		<exec condition="true">
			<sql type="define">tblSalesOutStock_Add_ManyAccount_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--启用审核流，保存时要判断是否超过信用额度-->		
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' == '1'&amp;&amp;@MEM:CustomerCreditLimit==true">
			<sql type="define">tblSalesOutStock_Add_CustomerCreditLimit_Validate</sql>
		</exec>
	</sql>


	<!--=====================================外币代码暂不处理=============================================-->
	<sql type="condition"><!--如果是本位币帐户，不用录入汇率-->	
     <condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblSalesOutStock_PayAccCode and SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID</select></condition>
		 <exec condition="('@ValueofDB:tblSalesOutStock_Currency'.length == 0 &amp;&amp; @ValueofDB:tblSalesOutStock_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblSalesOutStock_CurrencyRate!=1)">		
     			<error>CurrencyRate.putErrors.error</error>       
		 </exec>
	</sql>
	<sql type="condition"><!--如果收款账户的币种和该单据币种不同，给出错误提示-->	
		<condition><select> select COUNT(0) as CurrencyC from tblSalesRecAccount a,tblAccTypeInfo b where a.f_ref=@ValueofDB:tblSalesOutStock_id and a.Account=b.AccNumber and b.Currency!=@ValueofDB:tblSalesOutStock_Currency</select></condition>
		<exec condition="@SqlReturn:CurrencyC&gt;0"> 
				<error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>
	</sql>
	<!--===================================以上代码：外币代码暂不处理=====================================-->	
	
	
	<sql type="condition"><!--有引用单据，并且启用了控制超订单出库系统配置，判断是否有超订单出库-->
		<exec condition="'@MEM:OverSalesorder'=='true'">
			<sql type="define">tblSalesOutStock_Add_OverOrderOut_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了控制低于最低限售，判断非赠品，样品商品折后单价是否低于最低限售-->
		<exec condition="@MEM:UnderLimitprice==true">			
			<sql type="define">tblSalesOutStock_Add_UnderLimitPrice_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了控制低于成本价，判断非赠品，样品商品折后单价是否低于成本-->
		<!--没有启用多仓库时将主表的仓库设置到明细表,便于后续查询-->	
		<exec condition="'@MEM:ManyStockSales'=='false'">			  
			<sql>update tblSalesOutStockDet set StockCode=@ValueofDB:tblSalesOutStock_StockCode where f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		<exec condition="@MEM:UnderCostprice==true">			
			<sql type="define">tblSalesOutStock_Add_UnderCostPrice_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--未选择仓库报错-->
		<condition>
			<select> select count(0) nostockcode from tblSalesOutStockDet where f_ref=@ValueofDB:tblSalesOutStock_id and len(isnull(stockcode,''))=0  </select>
		</condition>
		<exec condition=" @SqlReturn:nostockcode &gt; 0 ">			  
			<error>仓库不能为空</error>
		</exec>
	</sql>
	<sql type="condition"><!--启用了控制对超结算账期未收款客户销售-->
		<exec condition="@MEM:WithOutSettleCys==true">		
			<sql type="define">tblSalesOutStock_Add_WithOutSettleCys_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果没有执行到最低限售，成本价销售的确定，取消，执行下面的define-->
		<exec condition="true">			
			<sql type="define">tblSalesOutStock_Add_AccBefore</sql>
		</exec>
	</sql>
</define>

<!--低于限售价确定保存时，执行低于成本的控制及过账前操作define-->
<define name="tblSalesOutStock_Add_AccBefore1">
		<sql type="condition">
			<exec condition="@MEM:UnderLimitprice==true"><!--低于最低限售控制-->			
				<sql type="define">tblSalesOutStock_Add_UnderLimitPrice_Validate</sql>
			</exec>
			<exec condition="@MEM:UnderCostprice==true"><!--低于成本价控制-->		
				<sql type="define">tblSalesOutStock_Add_UnderCostPrice_Validate</sql>
			</exec>
			<exec condition="@MEM:WithOutSettleCys==true"><!--启用了控制对超结算账期未收款客户销售-->		
				<sql type="define">tblSalesOutStock_Add_WithOutSettleCys_Validate</sql>
			</exec>
			<exec condition="true"><!--过账前操作-->		
				<sql type="define">tblSalesOutStock_Add_AccBefore</sql>
			</exec>
		</sql>	
</define>
<!--低于限售价确定保存时，执行低于成本的控制及过账前操作define-->
<define name="tblSalesOutStock_Add_AccBefore2">
	<sql type="condition">
		<exec condition="@MEM:UnderCostprice==true"><!--低于成本价控制-->			
			<sql type="define">tblSalesOutStock_Add_UnderCostPrice_Validate</sql>
		</exec>
		<exec condition="@MEM:WithOutSettleCys==true"><!--启用了控制对超结算账期未收款客户销售-->		
			<sql type="define">tblSalesOutStock_Add_WithOutSettleCys_Validate</sql>
		</exec>
		<exec condition="true"><!--过账前操作-->		
			<sql type="define">tblSalesOutStock_Add_AccBefore</sql>
		</exec>
	</sql>
</define>
<!--低于成本价确定保存时，执行控制对超结算账期未收款客户销售操作define-->
<define name="tblSalesOutStock_Add_AccBefore3">
	<sql type="condition">
		<exec condition="@MEM:WithOutSettleCys==true"><!--启用了控制对超结算账期未收款客户销售-->		
			<sql type="define">tblSalesOutStock_Add_WithOutSettleCys_Validate</sql>
		</exec>
		<exec condition="true"><!--过账前操作-->		
			<sql type="define">tblSalesOutStock_Add_AccBefore</sql>
		</exec>
	</sql>
</define>
<!--===========启用了信用额度控制，判断是否超出信用额度=========-->
<define name="tblSalesOutStock_Add_CustomerCreditLimit_Validate">
	<sql type="condition">
		<condition>
			<!--查询此客户的之前的应收余额-->
			<select>select sum(isnull(a.ReceiveTotalRemain,0)-isnull(a.PreReceiveTotalRemain,0)-isnull(a.PayTotalRemain,0)+isnull(a.PrePayTotalRemain,0)) as RecRemain from tblCompany a where a.classCode=@ValueofDB:tblSalesOutStock_CompanyCode</select>
			<!--查询此客户在客户模块设置的额度,本单待收款-->
			<select>select a.Credit+isnull(b.Credit,0) as cred,cast(dbo.throwZero(a.Credit+isnull(b.Credit,0)-cast(@SqlReturn:RecRemain as numeric(18,8))) as Varchar(50)) as Credit,dbo.getDigits('tblSalesOutStock','TotalTaxAmount',cast(@ValueofDB:tblSalesOutStock_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblSalesOutStock_AlrAccAmt as numeric(18,8))) as CurrBillRece from tblCompany a left join tblTempCreditApply b on a.classCode=b.CompanyCode and b.workFlowNodeName='finish' and @ValueofDB:tblSalesOutStock_BillDate&gt;=StartDate and @ValueofDB:tblSalesOutStock_BillDate&lt;=EndDate where a.classCode=@ValueofDB:tblSalesOutStock_CompanyCode</select>
		</condition>
		<!--当本单待收款大于 信用额度-应收余额 给出错误提示-->
		<exec condition="@SqlReturn:cred&gt;0 &amp;&amp;@SqlReturn:CurrBillRece&gt;@SqlReturn:Credit"> 
			<error>tblSalesOutStock.CustomerCreditLimit.add.Notice,@SqlReturn:cred</error>       
		</exec>
	</sql>
</define>
<!--===========启用了多账户，进行多账户的判断提示=========-->
<define name="tblSalesOutStock_Add_ManyAccount_Validate">
	<!--选择收款账户-->
	<sql type="condition">
		<condition><select>select 'exisAccErr' as exisAccErr from tblSalesRecAccount where tblSalesRecAccount.f_ref=@ValueofDB:tblSalesOutStock_id and (isnull(tblSalesRecAccount.Amount,0)=0)</select></condition>
		<exec condition="'@SqlReturn:exisAccErr'!='null'">
			<error>common.AccountAmt.input.error</error>       
		</exec>
	</sql>
	<!--选择了重复的付款账户，给出错误提示-->
	<sql type="condition">
		<condition><select>select 'sameAcc' as sameAcc from tblSalesRecAccount where f_ref=@ValueofDB:tblSalesOutStock_id group by Account having count(Account)&gt;1</select></condition>
		<exec condition="'@SqlReturn:sameAcc'=='sameAcc'">
			<error>common.recAccount.same.error</error>       
		</exec>
	</sql>
</define>	
<!--===========启用了“控制低于成本价销售出库”，根据逻辑给出相应提示=========-->
<define name="tblSalesOutStock_Add_UnderCostPrice_Validate">
	<sql type="condition">
		<exec condition="'@MEM:GoodsCostingMethod'=='MONTH'||'@MEM:GoodsCostingMethod'=='FIFO'">
			<sql type="define">UnderCostPrice_MONTH_Validate</sql>
		</exec>
		<exec condition="'@MEM:GoodsCostingMethod'=='MWAM'">
			<sql type="define">UnderCostPrice_MWAM_Validate</sql>
		</exec>
	</sql>
</define>		
<!--全月一次平均，先进先出-->
<define name="UnderCostPrice_MONTH_Validate">
	<sql type="condition">
		<condition>
			<!--查询此用户是否有权限低于成本价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowLittleCostOut' and hasRight=1</select>
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(c.lastPrice as numeric(18,4)) as lastPrice from tblSalesOutStockDet a,tblGoods b,tblStocks c where a.f_ref=@ValueofDB:tblSalesOutStock_id and a.goodsCode=b.classCode and a.goodsCode=c.goodsCode and (case when len(a.stockCode)=0 then @ValueofDB:tblSalesOutStock_StockCode else a.stockCode end)=c.stockCode and a.BatchNo=c.BatchNo and a.yearNO=c.yearNO and a.ProDate=c.ProDate and a.Availably=c.Availably and a.Inch=c.Inch and a.Hue=c.Hue and a.PresentSampleType not in ('1','2') and a.DisPrice&lt;c.lastPrice</select>
			<!--查询此用户是否有查看成本价的权限-->
			<select>select count(0) as Cost from tblUserSunCompany a,tblRole b where a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%' and b.hiddenField like '%'+'1'+',%'</select>
		</condition>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户没有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost!=0">
			<error>商品 @SqlReturn:GoodsFullName 的售价 @SqlReturn:DisPrice 低于其成本价，不允许保存！</error>       
		</exec>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost==0">
			<error>tblSalesOutStock.UnderCostPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</error>       
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户没有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost!=0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.Cost.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice</confirm>
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost==0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</confirm>
		</exec>
	</sql>
</define>		

<!--移动加权-->
<define name="UnderCostPrice_MWAM_Validate">
	<sql type="condition"><!--序列号判断-->
		<condition>
			<!--查询此用户是否有权限低于成本价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowLittleCostOut' and hasRight=1</select>
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(max(c.lastPrice) as numeric(18,4)) as lastPrice from tblSalesOutStockDet a,tblStockDet c,tblGoods b where a.f_ref=@ValueofDB:tblSalesOutStock_id and len(a.Seq)&gt;0 and LEN(c.Seq)&gt;0 and charIndex(c.seq+'~',a.seq)&gt;0 and c.id=(select top 1 id from tblStockDet k where k.goodPropHash=c.goodPropHash and (k.BillDate&lt;@ValueofDB:tblSalesOutStock_BillDate or (k.BillDate=@ValueofDB:tblSalesOutStock_BillDate and (k.createTime&lt;@ValueofDB:tblSalesOutStock_createTime))) order by BillDate desc,createTime desc,itemOrder desc)and a.goodsCode=b.classCode and a.PresentSampleType not in ('1','2') group by a.id,b.GoodsFullName,a.DisPrice having a.DisPrice&lt;max(c.lastPrice)</select>
			<!--查询此用户是否有查看成本价的权限-->
			<select>select count(0) as Cost from tblUserSunCompany a,tblRole b where a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%' and b.hiddenField like '%'+'1'+',%'</select>
		</condition>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户没有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost!=0">
			<error>商品 @SqlReturn:GoodsFullName 的售价 @SqlReturn:DisPrice 低于其成本价，不允许保存！</error>       
		</exec>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost==0">
			<error>tblSalesOutStock.UnderCostPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</error>       
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户没有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost!=0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.Cost.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice</confirm>
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost==0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</confirm>
		</exec>
	</sql>
	<sql type="condition"><!--非序列号判断-->
		<condition>
			<!--查询此用户是否有权限低于成本价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowLittleCostOut' and hasRight=1</select>
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(c.lastPrice as numeric(18,4)) as lastPrice from tblSalesOutStockDet a,tblStockDet c,tblGoods b where a.f_ref=@ValueofDB:tblSalesOutStock_id and len(a.Seq)=0 and Hashbytes('md5',Lower(a.GoodsCode+'GoodsCode'+a.StockCode+'StockCode'+a.Availably+'Availably'+a.BatchNo+'BatchNo'+a.Hue+'Hue'+a.Inch+'Inch'+a.ProDate+'ProDate'+'Seq'+a.yearNO+'yearNO'))=c.goodPropHash and c.id=(select top 1 id from tblStockDet k where k.goodPropHash=c.goodPropHash and (k.BillDate&lt;@ValueofDB:tblSalesOutStock_BillDate or (k.BillDate=@ValueofDB:tblSalesOutStock_BillDate and (k.createTime&lt;@ValueofDB:tblSalesOutStock_createTime))) order by BillDate desc,createTime desc,itemOrder desc)and a.goodsCode=b.classCode and a.PresentSampleType not in ('1','2') and a.DisPrice&lt;c.lastPrice</select>
			<!--查询此用户是否有查看成本价的权限-->
			<select>select count(0) as Cost from tblUserSunCompany a,tblRole b where a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%' and b.hiddenField like '%'+'1'+',%'</select>
		</condition>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户没有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost!=0">
			<error>商品 @SqlReturn:GoodsFullName 的售价 @SqlReturn:DisPrice 低于其成本价，不允许保存！</error>       
		</exec>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，用户有查看成本价权限，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost==0">
			<error>tblSalesOutStock.UnderCostPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</error>       
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户没有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost!=0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.Cost.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice</confirm>
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost==0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore3" noDefine="">tblSalesOutStock.UnderCostPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</confirm>
		</exec>
	</sql>
</define>	
<!--判断用户是否有权限对超结算账期未收款客户销售-->
<define name="tblSalesOutStock_Add_WithOutSettleCys_Validate">	
	<sql type="condition">
			<condition><select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='WithOutSettleCys' and hasRight=1</select>
							 <select>select tblSalesOutStock.BillNo,convert(int,DATEDIFF(DAY,tblSalesOutStock.AcceptDate,GETDATE())) as exceedtime from tblSalesOutStock join tblCompany on tblCompany.classCode=tblSalesOutStock.CompanyCode where tblSalesOutStock.CompanyCode=(select CompanyCode from tblSalesOutStock where id=@ValueofDB:id) and tblSalesOutStock.NeedReturnAmt&gt;0 and convert(int,DATEDIFF(DAY,(case tblSalesOutStock.AcceptDate when '' then null else tblSalesOutStock.AcceptDate end),GETDATE()))&gt;0</select>
			</condition>
		<!--查询出有超结算账期未收款的客户，并且此用户没有权限超结算账期，也不是系统管理员给出错误提示-->
			<exec condition="'@SqlReturn:BillNo'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
					<error>tblSalesOutStock.SettleCys.error,@SqlReturn:BillNo</error>       
			</exec>			
   <!--查询出有超结算账期未收款的客户，并且此用户有权限超结算账期，或者是系统管理员给出提示-->
			<exec condition="'@SqlReturn:BillNo'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
					<confirm yesDefine="tblSalesOutStock_Add_AccBefore" noDefine="">tblSalesOutStock.SettleCys.confirm,@SqlReturn:BillNo</confirm>
			</exec>						
	</sql>
</define>

		
<!--===========启用了“控制低于限售价销售出库”，根据逻辑给出相应提示=========-->
<define name="tblSalesOutStock_Add_UnderLimitPrice_Validate">
	<sql type="condition">
		<condition>
			<!--查询此用户是否有权限低于限售价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='UnderLimitprice' and hasRight=1</select>
			<!--查询是否有折后单价低于其最低限售的商品-->
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(b.Pricefixing as numeric(18,4)) as Pricefixing from tblSalesOutStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesOutStock_id and a.goodsCode=b.classCode and a.PresentSampleType not in ('1','2') and b.Pricefixing&gt;0 and a.DisPrice&lt;b.Pricefixing</select>
		</condition>
		<!--查询出有低于限售价的商品，并且此用户没有权限低于限售价销售，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
			<error>tblSalesOutStock.UnderLimitPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:Pricefixing</error>       
		</exec>
		<!--查询出有低于限售价的商品，但此用户有权限低于限售价销售或者是系统管理员，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore2" noDefine="">tblSalesOutStock.UnderLimitPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:Pricefixing</confirm>
		</exec>
	</sql>
</define>
<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=========-->
<define name="tblSalesOutStock_Add_PriceControl_Validate">
	<!--=======不含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesOutStockDet a,ViewPriceControl b,tblGoods c where a.f_ref=@ValueofDB:tblSalesOutStock_id and UserID=@ValueofDB:tblSalesOutStock_createBy and b.ControlType='Sell' and b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and a.PresentSampleType not in ('1','2') and (a.DisPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.DisPrice&gt;b.HighestPrice))</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
	<!--=======含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesOutStockDet a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='SellTax' and UserID=@ValueofDB:tblSalesOutStock_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblSalesOutStock_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.TaxPriceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.TaxPriceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.TaxPriceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
</define>
<!--===========启用了“控制超订单出库”，需判断是否有超出订单出库=========-->
<define name="tblSalesOutStock_Add_OverOrderOut_Validate">
	<sql type="condition">
		<condition>
			<!--查询此用户是否有权限超订单出库-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowMoreOrderOut' and hasRight=1</select>
			<!--查询是否有超订单入库的商品-->
			<select>select l.BillNo,k.GoodsFullName,dbo.throwZero((select sum(NotOutQty) from tblSalesOrderDet b where b.f_ref=a.SalesOrderID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO)) as NotOutQty from tblSalesOutStockDet a,tblGoods k,tblSalesOrder l where a.f_ref=@ValueofDB:tblSalesOutStock_id and LEN(SalesOrderID)&gt;0 and a.SalesOrderID=l.id and a.GoodsCode=k.classCode group by SalesOrderID,l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,k.GoodsFullName having SUM(Qty)&gt;(select sum(NotOutQty) from tblSalesOrderDet b where b.f_ref=a.SalesOrderID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO)</select>
		</condition>
		<!--查询出有超订单出库的商品，并且此用户没有权限超订单出库，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
			<error>tblSalesOutStock.add.OverOrderQty.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName,@SqlReturn:NotOutQty</error>       
		</exec>
		<!--查询出有超订单出库的商品，但此用户有权限超订单出库或者是系统管理员，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesOutStock_Add_AccBefore1" noDefine="">tblSalesOutStock.add.OverOrderQty.confirm,@SqlReturn:BillNo,@SqlReturn:GoodsFullName,@SqlReturn:NotOutQty</confirm>
		</exec>
	</sql>
</define>

<!--==============引用销售订单的控制判断=================-->
<define name="tblSalesOutStock_Add_QuoteOrder_Validate">
	<sql type="condition"><!--判断销售出库的单据日期在引用销售订单前，给出错误提示-->
		<condition><select>select a.BillNo,billDate as BuyInDate from tblSalesOrder a,tblSalesOutStockDet b where b.f_ref=@ValueofDB:tblSalesOutStock_id and b.SalesOrderID=a.id and a.BillDate&gt;@ValueofDB:tblSalesOutStock_BillDate</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.QuoteDate.error,@SqlReturn:BillNo,@SqlReturn:BuyInDate</error>       
		</exec>
	</sql>
	<sql type="condition"><!--客户不同，给出错误提示-->
		<condition><select>select a.BillNo,c.ComFullName from tblSalesOrder a,tblSalesOutStockDet b,tblCompany c where b.f_ref=@ValueofDB:tblSalesOutStock_id and b.SalesOrderID=a.id and a.CompanyCode=c.classCode and a.CompanyCode!=@ValueofDB:tblSalesOutStock_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.clientQuote.error,@SqlReturn:BillNo,@SqlReturn:ComFullName</error>       
		</exec>
	</sql>
	<sql type="condition"><!--引用单据发票类型与主表不符-->
		<condition><select>select tblSalesOrder.BillNo as BuyOrderID from tblSalesOutStock left join tblSalesOutStockDet on tblSalesOutStock.id=tblSalesOutStockDet.f_ref left join tblSalesOrderDet on tblSalesOrderDet.id=tblSalesOutStockDet.SourceID inner join tblSalesOrder on tblSalesOrder.id=tblSalesOrderDet.f_ref where tblSalesOutStockDet.f_ref=@ValueofDB:tblSalesOutStock_id and tblSalesOutStock.InVoiceType!=tblSalesOrder.InVoiceType</select></condition>
			<exec condition="'@SqlReturn:BuyOrderID'!='null'">			
				<error>tblSalesOutStock.InvoiceType.error,@SqlReturn:BuyOrderID</error>       
			</exec>
	</sql>
</define>
<!--=======启用了价格跟踪，向价格管理表中插入数据================-->
<define name="tblSalesOutStock_Add_PriceTracking">
	<sql type="condition">
		<condition>
			<select>select id as CPID from tblCustomerPrice where CompanyCode=@ValueofDB:tblSalesOutStock_CompanyCode</select>
			<select>select lower(substring(replace(newid(),'-',''),1,28)) as NCPID</select>
		</condition>
		<!--判断如果价格管理表中没有此客户的记录，插入一条主表记录-->
		<exec condition="'@SqlReturn:CPID'=='null'">
			<sql>insert into tblCustomerPrice(id,classCode,workFlowNodeName,CompanyCode,createBy,lastUpdateBy,createTime,lastUpdateTime,statusId,SCompanyID) values (@SqlReturn:NCPID,'','finish',@ValueofDB:tblSalesOutStock_CompanyCode,'1','1',@ValueofDB:tblSalesOutStock_createTime,@ValueofDB:tblSalesOutStock_lastUpdateTime,0,@ValueofDB:tblSalesOutStock_SCompanyID)</sql>
		</exec>
		<!--查询在价格管理表中存在的商品，并且修改其最近售价，售价折扣-->
		<exec condition="'@SqlReturn:CPID'!='null'">
			<sql>update tblCustomerPriceDet set tblCustomerPriceDet.Price=a.Price,tblCustomerPriceDet.OutDiscount=case when (tblCustomerPriceDet.OutDiscount!=1 and @MEM:OutDiscountTracke!='true') then tblCustomerPriceDet.OutDiscount else a.Discount end from(select b.id as CDetID,(case @MEM:OutPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,(case when @MEM:OutDiscountTracke='true' then Discount else 100 end) as Discount from tblSalesOutStockDet a,tblCustomerPriceDet b where a.f_ref=@ValueofDB:tblSalesOutStock_id and b.f_ref=@SqlReturn:CPID and a.goodsCode=b.goodsCode and a.Price&gt;0)a where tblCustomerPriceDet.id=a.CDetID</sql>
		</exec>
		<!--查询在价格管理表中不存在的商品，并且插入最近进价，进价折扣-->
		<exec condition="true">
			<sql>insert into tblCustomerPriceDet(id,f_ref,GoodsCode,Price,SecQty,BaseQty,OutDiscount,SCompanyID)select a.sdid,a.CID,a.GoodsCode,a.Price,a.SecQty,a.BaseQty,a.Discount,a.CSID from(select substring(replace(newid(),'-',''),1,30) as sdid,a.GoodsCode as GoodsCode,(case @MEM:OutPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price,isnull(a.SecUnit,'') as SecUnit,a.SecQty,a.BaseQty,a.UnitPrice as UnitPrice,(case @SqlReturn:CPID when 'null' then @SqlReturn:NCPID else @SqlReturn:CPID end) as CID,@ValueofDB:tblSalesOutStock_SCompanyID as CSID,(case when @MEM:OutDiscountTracke='true' then Discount else 100 end) as Discount from tblSalesOutStockDet a where a.f_ref=@ValueofDB:tblSalesOutStock_id and a.price&gt;0 and (select count(0) from tblCustomerPriceDet b where b.f_ref=(case @SqlReturn:CPID when null then @SqlReturn:NCPID else @SqlReturn:CPID end) and a.goodsCode=b.goodsCode)=0 and a.detOrderNo=(select top 1 detOrderNo from tblSalesOutStockDet b where b.f_ref=a.f_ref and a.GoodsCode=b.GoodsCode order by b.detOrderNo desc))a</sql>
		</exec>		
	</sql>
</define>
<!--=====出库数量不能大于可用库存======-->
<define name="tblSalesOutStock_OutBillUseQty_validate">
	<sql type="condition">
		<condition><select>select isnull(c.GoodsFullName,'') as GoodsFullName,isnull(tblStock.StockFullName,'') as StockFullName,cast(case c.isCatalog when 0 then isnull(b.LastQty+b.inQtyNotAudit+b.SInQtyNotAudit-b.outQtyNotAudit-b.BOutQtyNotAudit,0) else -99999999 end - a.Qty as numeric(18,4)) as Qty from(select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblSalesOutStockDet where f_ref=@ValueofDB:tblSalesOutStock_id group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode)a left join tblStocks b on a.GoodsCode=b.GoodsCode and a.StockCode=b.StockCode and a.BatchNo=b.BatchNo and a.Hue=b.Hue and a.yearNO=b.yearNO and a.Inch=b.Inch and a.Availably=b.Availably and a.ProDate=b.ProDate left join tblStock on a.StockCode=tblStock.classCode left join tblGoods c on a.GoodsCode=c.classCode  where  a.Qty&gt;(case c.isCatalog when 0 then isnull(b.LastQty+b.inQtyNotAudit+b.SInQtyNotAudit-b.outQtyNotAudit-b.BOutQtyNotAudit,0) else -99999999 end)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName' != 'null'">			
			<error>common.VirtualStock.excess.error,@ValueofDB:tblSalesOutStock_BillNo,@SqlReturn:GoodsFullName,@SqlReturn:Qty,@SqlReturn:StockFullName</error>       
		</exec>	
	</sql>	
</define>
<!--=======过账前应该执行的操作（如果遇到确定，取消的提示信息，点击“确定”时必须调用一个define,所以将此代码独立出来）===============-->
<define name="tblSalesOutStock_Add_AccBefore">
	<sql type="condition">
		<!--没有启用多仓库时将主表的仓库设置到明细表-->	
		<exec condition="'@MEM:ManyStockSales'=='false'">			  
			<sql>update tblSalesOutStockDet set StockCode=@ValueofDB:tblSalesOutStock_StockCode where f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		<!--出库数量不能大于可用库存-->
		<exec condition="'@MEM:OutBillUseQtyCheck'=='true'">
			<sql type="define">tblSalesOutStock_OutBillUseQty_validate</sql>
		</exec>
	</sql>
	<sql type="condition">			
		<!--如果有引用单据，将引用ID映射到明细表-->
		<exec condition="'@ValueofDB:tblSalesOutStock_SalesOrderID'.length&gt;0">				  
			<sql>update tblSalesOutStockDet set SalesOrderID=@ValueofDB:tblSalesOutStock_SalesOrderID where f_ref=@ValueofDB:tblSalesOutStock_id and len(isnull(SalesOrderID,''))=0</sql>
		</exec>
		<!--多账户时由于某些情况下，账户金额不能更新主表累计收款金额，导致无法生成凭证等错误-->
		<exec condition="true">
			<sql>update tblSalesOutStock set FactIncome=a.Amount,AlrAccAmt=a.Amount,AccAmt=a.Amount,CurAlrAccAmt=a.CurAmount from (select isnull(sum(Amount),0) as Amount,isnull(sum(isnull(ExeBalFcAmt,0)),0) curAmount from tblSalesRecAccount as a where a.f_ref=@ValueofDB:id) as a where tblSalesOutStock.id=@ValueofDB:id</sql>
		</exec>
		<exec condition="true">
			<!--销售出库单优惠金额赋予初值-->
			<sql>UPDATE b SET b.PreferAmount=case when convert(numeric(18,8),@ValueofDB:tblSalesOutStock_TotalTaxAmount)+convert(numeric(18,8),@ValueofDB:tblSalesOutStock_DiscountAmount)=0 then 0 else round(convert(numeric(28,8),@ValueofDB:tblSalesOutStock_DiscountAmount*TaxAmount)/(convert(numeric(18,8),@ValueofDB:tblSalesOutStock_TotalTaxAmount)+convert(numeric(18,8),@ValueofDB:tblSalesOutStock_DiscountAmount)),@MEM:DigitsAmount) end FROM tblSalesOutStock a, tblSalesOutStockDet b WHERE a.id=b.f_ref and a.id=@ValueofDB:id</sql>
			<!--通过上述方式将优惠金额分摊到明细表某些情况会产生差额，将差额记录到最后一条记录中-->
			<sql>update tblSalesOutStockDet set PreferAmount=PreferAmount+@ValueofDB:tblSalesOutStock_DiscountAmount-(select sum(PreferAmount) from tblSalesOutStockDet a where a.f_ref=@ValueofDB:id) where f_ref=@ValueofDB:id and id=(select top 1 id from tblSalesOutStockDet k where k.f_ref=@ValueofDB:id and TaxAmount!=0 order by detOrderNo desc)</sql>
			<!--修改明细表的实际出库数量=数量 含税金额=待收款金额-->
			<sql>UPDATE tblSalesOutStockDet SET PreferBackAmount=TaxAmount-PreferAmount,AfterChangeAmt=TaxAmount-PreferAmount,NeedReceiveAmt=TaxAmount,CurAfterChangeAmt=CurAmount-PreferAmount/@ValueofDB:CurrencyRate,CurNeedReceiveAmt=CurAmount,FactOutQty=Qty,BackQty=0,BackAmount=0,NoInvoiceQty=Qty,InvoiceQty=0 where tblSalesOutStockDet.f_ref=@ValueofDB:id</sql>
			<!--修改主表的未开票金额，开票状态，待付款金额，累计付款金额，已代收金额-->
			<sql>update tblSalesOutStock set BackAmount=0,CurBackAmount=0,AfterChangeAmt=TotalTaxAmount,CurAfterChangeAmt=CurTotalAmount,InvoiceAmount=0,NoInvoiceAmount=TotalTaxAmount,InvoiceStatus='False',TotalAlrAccAmt=AlrAccAmt,NeedReturnAmt=TotalTaxAmount-AlrAccAmt,CurTotalAlrAccAmt=CurAlrAccAmt,CurNeedReturnAmt=CurTotalAmount-CurAlrAccAmt,hashDeputyReceAmt=0,CertificateNo='' where id=@ValueofDB:tblSalesOutStock_id</sql>	
		</exec>
		<!-- 应开票金额=明细含税金额/明细含税金额总和*主表优惠后金额  -->
		<exec condition="@ValueofDB:TotalAmount &gt; 0">
			<sql>UPDATE c SET c.InvoiceAmountH=round(c.TaxAmount/b.alltax*a.TotalTaxAmount,@MEM:DigitsAmount) from tblSalesOutStock a,(SELECT SUM(TaxAmount) AS alltax FROM tblSalesOutStockDet where f_ref=@ValueofDB:tblSalesOutStock_id) b,tblSalesOutStockDet c WHERE a.id=c.f_ref and a.id=@ValueofDB:tblSalesOutStock_id </sql>
		</exec>
		<!-- 明细表未开票金额，开票状态赋初始值  未开票金额=应开票金额-已开票金额 开票状态 '未开票'-->
		<exec condition="true">	
			<sql>update tblSalesOutStockDet set NoInvoiceAmount=InvoiceAmountH-InvoiceAmount,InvoiceStatus='False' where f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		<!--如果有引用销售订单。回填订单的相关字段-->
		<exec condition="true">	
			<sql type="procedure">{call proc_SalesUpdateOrderQty(@ValueofDB:tblSalesOutStock_id,add,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesOutStockDet.GoodsCode,@StockCode=tblSalesOutStockDet.StockCode,@BillType=tblSalesOutStock,@InstoreQty=0,@OutstoreQty=tblSalesOutStockDet.Qty,@from=tblSalesOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		
		<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		
		<!--销售出库单不启用审核流时，直接执行过账操作。启用审核流时，通过界面点击流程终止调用此define-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">SalesOutStock_Add_One</sql>
		</exec>
	</sql>
	<!--销售出库单付款与优惠金额比较回填明细表-->
	<sql type="condition">
		<condition>
			<select>select isnull(sum(Amount),0) as sumAmount from tblSalesRecAccount where f_ref=@ValueofDB:tblSalesOutStock_id
			</select>
		</condition>
		<exec condition="@SqlReturn:sumAmount&gt;=@ValueofDB:tblSalesOutStock_TotalTaxAmount">				
			<sql>update tblSalesOutStockDet set TotalReceiveAmt=TaxAmount where f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		<exec condition="@SqlReturn:sumAmount&lt;@ValueofDB:tblSalesOutStock_TotalTaxAmount">				
			<sql>update tblSalesOutStockDet set TotalReceiveAmt=case when convert(numeric(28,8),@ValueofDB:tblSalesOutStock_TotalTaxAmount)+convert(numeric(28,8),@ValueofDB:tblSalesOutStock_DiscountAmount)=0 then 0 else round(convert(numeric(28,8),@SqlReturn:sumAmount*TaxAmount)/(convert(numeric(28,8),@ValueofDB:tblSalesOutStock_TotalTaxAmount)+convert(numeric(28,8),@ValueofDB:tblSalesOutStock_DiscountAmount)),@MEM:DigitsAmount) end where f_ref=@ValueofDB:tblSalesOutStock_id
			</sql>
		</exec>
	</sql>
</define>
<!--=============销售出库单审核过账执行的操作============-->
<define name="SalesOutStock_Add_One">
	<sql type="condition"><!--如果启用审核流，删除已审核完毕的序列号出入明细-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,delete,retCode,retVal)}</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了系统配置 信用额度控制，判断是否大于可用额度-->
		<exec condition="@MEM:CustomerCreditLimit==true">
			<sql type="define">tblSalesOutStock_Add_CustomerCreditLimit_Validate</sql>
		</exec>
	</sql>
	
	<sql type="condition">
	<!--如果启用了价格跟踪，将单价插入到价格管理表中-->	
		<exec condition="'@MEM:OutPriceTrack'!='PriceNo'">
			<sql type="define">tblSalesOutStock_Add_PriceTracking</sql>
		</exec>
	</sql>	
	
	<sql type="condition">
		<condition><select>select 'isUsed' as isUseSeq from tblGoodsAttribute where propName='Seq' and isUsed=1</select></condition>
		<!--如果启用审核流，则过账时更新分仓库存-未审核字段-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesOutStockDet.GoodsCode,@StockCode=tblSalesOutStockDet.StockCode,@BillType=tblSalesOutStock,@InstoreQty=0,@OutstoreQty=-1*tblSalesOutStockDet.Qty,@from=tblSalesOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<exec condition="true"><!--插入出入库明细-->
			<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblSalesOutStock_Period,@PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear,@PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth,@GoodsCode=tblSalesOutStockDet.GoodsCode,@StockCode=tblSalesOutStockDet.StockCode,@BillID=@ValueofDB:tblSalesOutStock_id,@BillType=tblSalesOutStock,@BillDate=@ValueofDB:tblSalesOutStock_BillDate,@BillNo=@ValueofDB:tblSalesOutStock_BillNo,@OutstoreQty=tblSalesOutStockDet.Qty,@OutstorePrice=tblSalesOutStockDet.CostPrice,@OutstoreAmount=tblSalesOutStockDet.CostAmount,@createBy=@ValueofDB:tblSalesOutStock_createBy,@lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy,@createTime=@ValueofDB:tblSalesOutStock_finishTime,@lastUpdateTime=@MEM:sysLongDate,@SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID,@MRemark=@ValueofDB:tblSalesOutStock_Remark,@DRemark=tblSalesOutStockDet.Remark,@SourceID=tblSalesOutStockDet.id,@CompanyCode=@ValueofDB:tblSalesOutStock_CompanyCode,@EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID,@DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode,@SalesPrice=case when @ValueofDB:tblSalesOutStock_InVoiceType=2 then tblSalesOutStockDet.DisPrice else tblSalesOutStockDet.TaxPrice end,@SalesAmount=tblSalesOutStockDet.Qty*(case when @ValueofDB:tblSalesOutStock_InVoiceType=2 then tblSalesOutStockDet.DisPrice else tblSalesOutStockDet.TaxPrice end),@SalesQty=tblSalesOutStockDet.Qty,@Amount=tblSalesOutStockDet.Qty*(tblSalesOutStockDet.DisPrice),@Price=tblSalesOutStockDet.DisPrice,@DiscountAmount=tblSalesOutStockDet.PreferAmount,@TrackNo=tblSalesOutStockDet.TrackNo,@AccountingPrice=tblSalesOutStockDet.AccountingPrice,@PresentSampleType=tblSalesOutStockDet.PresentSampleType,@from=tblSalesOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--更新出库单明细未入库数量字段,更新未收款数量-->
		<exec condition="true">
			<sql>update tblSalesOutStockDet set NotBuyQty=Qty,NotPayQty=Qty,PayQty=0 where tblSalesOutStockDet.f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		
		<!--出库单在修改后，用户可能删除某些序列号，使其入库，进行序列号判断-->
		<exec condition="'@Sess:BillOper'=='update'">
			<sql type="define">validateSameSeq</sql>
		</exec>
		<exec condition="true"><!--负库存判断-->
			<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
		</exec>
		<!--分摊销售订单订金回填销售订单累积付款-->
		<exec condition="true">	
			<sql type="procedure">{call proc_SalesOutReceiveAmort(@ValueofDB:tblSalesOutStock_id,add,retCode,retVal)}</sql>
		</exec>
	</sql>
	<!--===========插入凭证，影响科目余额，影响往来===============-->
	<sql type="condition">
		<!--发票类型（InVoiceType）分为： 1、普通发票 2、增值税发票 3、收据-->
		<!--系统变量（accSetting）分为：  1、一般纳税人 2、小规模纳税人  3、收据-->
		<!--得到本单待收款金额-->
		<condition><select>select cast(@ValueofDB:tblSalesOutStock_TotalTaxAmount as numeric(18,8))-AlrAccAmt as NeedRec,abs(cast(@ValueofDB:tblSalesOutStock_TotalTaxAmount as numeric(18,8))-AlrAccAmt) as AbsNeedRec,AccAmt,AlrAccAmt,cast(@ValueofDB:tblSalesOutStock_CurTotalAmount as numeric(18,8))-cast(@ValueofDB:tblSalesOutStock_CurAlrAccAmt as numeric(18,8)) as NeedRecCur,abs(cast(@ValueofDB:tblSalesOutStock_CurTotalAmount as numeric(18,8))-cast(@ValueofDB:tblSalesOutStock_CurAlrAccAmt as numeric(18,8))) as AbsNeedRecCur from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id</select></condition>

		<!--如果启用“自动产生凭证”，则自动插入凭证-->
		<exec condition="'@MEM:autoGenerateAcc'=='true'"><sql type="certificate">tblSalesOutStock</sql></exec>
		<!--========影响往来===========-->
		<!--优惠金额大于0时，插入往来明细 借：应收款（优惠金额）往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="@ValueofDB:tblSalesOutStock_TotalTaxAmount&gt;0">
			<sql type="procedure">{call proc_insertComIni(0@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_CompanyCode,2,@ValueofDB:tblSalesOutStock_BillDate,Period=@ValueofDB:tblSalesOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=@ValueofDB:tblSalesOutStock_TotalTaxAmount@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOutStock_id@SPFieldLink:Currency=@ValueofDB:tblSalesOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOutStock_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID@SPFieldLink:FcRecTotalDebit=@ValueofDB:tblSalesOutStock_CurTotalAmount@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:BillType=tblSalesOutStock@SPFieldLink:BillNo=@ValueofDB:tblSalesOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesOutStock_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblSalesOutStock_Remark,retCode,retVal)}</sql>
		</exec>
		<!--本次结算金额大于0，并且小于等于优惠后金额，插入往来明细 贷：应收款（本次结算）-->
		<exec condition="@SqlReturn:AlrAccAmt&gt;0&amp;&amp;@SqlReturn:NeedRec&gt;=0">
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_CompanyCode,2,@ValueofDB:tblSalesOutStock_BillDate,Period=@ValueofDB:tblSalesOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@SqlReturn:AlrAccAmt@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOutStock_id@SPFieldLink:Currency=@ValueofDB:tblSalesOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOutStock_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSalesOutStock_CurAlrAccAmt@SPFieldLink:BillType=tblSalesOutStock@SPFieldLink:BillNo=@ValueofDB:tblSalesOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode,retCode,retVal)}</sql>
		</exec>
		<!--优惠后金额大于，并且待结算金额小于0，插入往来明细 贷：应收款（优惠后金额）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false' &amp;&amp; @ValueofDB:tblSalesOutStock_TotalTaxAmount&gt;0&amp;&amp;@SqlReturn:NeedRec&lt;0">
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_CompanyCode,2,@ValueofDB:tblSalesOutStock_BillDate,Period=@ValueofDB:tblSalesOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblSalesOutStock_TotalTaxAmount@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOutStock_id@SPFieldLink:Currency=@ValueofDB:tblSalesOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOutStock_CurrencyRate@ParamNum:@SPFieldLink:createBy=@ValueofDB:tblSalesOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID@SPFieldLink:FcRecTotalDebit=0@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSalesOutStock_CurTotalAmount@ParamNum:@SPFieldLink:BillType=tblSalesOutStock@SPFieldLink:BillNo=@ValueofDB:tblSalesOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode,retCode,retVal)}</sql>
		</exec>
		<!--未启用预收预付记应收应付,待结算金额小于0，插入往来明细 贷：预收款（ABS(待结算金额)）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='false' &amp;&amp; @SqlReturn:NeedRec&lt;0">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_CompanyCode,4,@ValueofDB:tblSalesOutStock_BillDate,Period=@ValueofDB:tblSalesOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth@SPFieldLink:PreReceiveTotalDebit=0@SPFieldLink:PreReceiveTotalLend=@SqlReturn:AbsNeedRec@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOutStock_id@SPFieldLink:Currency=@ValueofDB:tblSalesOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOutStock_CurrencyRate@ParamNum:@SPFieldLink:createBy=@ValueofDB:tblSalesOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID@SPFieldLink:FcPreRecTotalCredit=@SqlReturn:AbsNeedRecCur@ParamNum:@SPFieldLink:FcPreRecTotalDebit=0@ParamNum:@SPFieldLink:BillType=tblSalesOutStock@SPFieldLink:BillNo=@ValueofDB:tblSalesOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode,retCode,retVal)}</sql>
		</exec>
		<!--已启用预收预付记应收应付,待结算金额小于0，插入往来明细 贷：应收款（ABS(待结算金额)）-->
		<exec condition="'@MEM:prerecvpaymarktoneedrecvpay'=='true' &amp;&amp; @SqlReturn:NeedRec&lt;0">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_CompanyCode,2,@ValueofDB:tblSalesOutStock_BillDate,Period=@ValueofDB:tblSalesOutStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesOutStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesOutStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@SPFieldLink:ReceiveTotalLend=@SqlReturn:AlrAccAmt@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblSalesOutStock_id@SPFieldLink:Currency=@ValueofDB:tblSalesOutStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesOutStock_CurrencyRate@ParamNum:@SPFieldLink:createBy=@ValueofDB:tblSalesOutStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesOutStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesOutStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesOutStock_SCompanyID@SPFieldLink:FcRecTotalCredit=@SqlReturn:AbsNeedRecCur@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:BillType=tblSalesOutStock@SPFieldLink:BillNo=@ValueofDB:tblSalesOutStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesOutStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesOutStock_DepartmentCode,retCode,retVal)}</sql>
		</exec>
		<!--本次结算金额大于0，产生收款单-->
		<exec condition="@SqlReturn:AlrAccAmt&gt;0 &amp;&amp; @SqlReturn:AccAmt&gt;0">
			<sql type="define">SalesOutStock_Add_CreateReceBill</sql>
		</exec>
	</sql>
</define>

<!--=========如果结算账户大于0，生成销售收款单==========-->
<define name="SalesOutStock_Add_CreateReceBill">
	<sql type="condition">
		<condition>
		  <select>select (TotalTaxAmount-AlrAccAmt) as NeedRec,AlrAccAmt, (case when (TotalTaxAmount-AlrAccAmt)&gt;=0.0 then 'Receive' else (case @MEM:prerecvpaymarktoneedrecvpay when 'true' then 'Receive' else 'PreReceive' end) end) as AcceptType,(AlrAccAmt) as factAmt,(case when '' like '1001%' then 1 else (case @MEM:prerecvpaymarktoneedrecvpay when 'true' then 1 else 3 end) end) as SettleType from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id</select>
		</condition>		
		<exec condition="true">
			<sql>insert into tblSaleReceive (id,BillDate,BillNo,ProjectCode,CompanyCode,DepartmentCode,EmployeeID,SettleType,AcceptTypeID,ExeBalAmt,FactIncome,AccAmt,Currency,CurrencyRate,BillFcAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_BillDate,@CODE:[tblSaleReceive_BillNo],@ValueofDB:tblSalesOutStock_ProjectCode,@ValueofDB:tblSalesOutStock_CompanyCode,@ValueofDB:tblSalesOutStock_DepartmentCode,@ValueofDB:tblSalesOutStock_EmployeeID,@SqlReturn:SettleType,@SqlReturn:AcceptType,@SqlReturn:AlrAccAmt,@SqlReturn:factAmt,@SqlReturn:factAmt,@ValueofDB:tblSalesOutStock_Currency,@ValueofDB:tblSalesOutStock_CurrencyRate,@ValueofDB:tblSalesOutStock_CurAlrAccAmt,@ValueofDB:tblSalesOutStock_PeriodYear,@ValueofDB:tblSalesOutStock_PeriodMonth,@ValueofDB:tblSalesOutStock_Period,@ValueofDB:tblSalesOutStock_createBy,@ValueofDB:tblSalesOutStock_createTime,@ValueofDB:tblSalesOutStock_lastUpdateBy,@ValueofDB:tblSalesOutStock_lastUpdateTime,@ValueofDB:tblSalesOutStock_SCompanyID,1,'finish','-1','',@ValueofDB:tblSalesOutStock_TrackNo)</sql>
			<sql>insert into tblSaleReceivedet (id,f_ref,BillAmt,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,SalesOrderNo,SalesOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,ReceiveBillType) values ('1'+@ValueofDB:tblSalesOutStock_id,'0'+@ValueofDB:tblSalesOutStock_id,@ValueofDB:tblSalesOutStock_TotalTaxAmount,@ValueofDB:tblSalesOutStock_CurTotalAmount,(case when cast(@SqlReturn:NeedRec as numeric(18,8))&gt;=0.0 then @SqlReturn:AlrAccAmt else @ValueofDB:tblSalesOutStock_TotalTaxAmount end),(case when cast(@SqlReturn:NeedRec as numeric(18,8))&gt;=0.0 then @ValueofDB:tblSalesOutStock_CurAlrAccAmt else @ValueofDB:tblSalesOutStock_CurTotalAmount end),@ValueofDB:tblSalesOutStock_Currency,@ValueofDB:tblSalesOutStock_CurrencyRate,0,@ValueofDB:tblSalesOutStock_TotalTaxAmount,0,@ValueofDB:tblSalesOutStock_CurTotalAmount,@ValueofDB:tblSalesOutStock_BillNo,@ValueofDB:tblSalesOutStock_SalesOrderNo,@ValueofDB:tblSalesOutStock_SalesOrderID,0,@ValueofDB:tblBuyInStock_SCompanyID,0,@ValueofDB:tblSalesOutStock_id,'tblSalesOutStock')</sql>
		</exec>
		<!--如果启用了多账户，向多账户明细表中插入数据-->
		<exec condition="true">
			<sql>insert into tblReceiveAccountDet (id,f_ref,SettleType,Amount,ExeBalFcAmt,Account,SCompanyID,Remark) select id,'0'+@ValueofDB:tblSalesOutStock_id,SettleType,Amount,ExeBalFcAmt,Account,SCompanyID,Remark from tblSalesRecAccount where f_ref=@ValueofDB:tblSalesOutStock_id</sql>
		</exec>
		<!--自动生成的单据需更新单据编号连续-->
		<exec condition="'@MEM:BillNoSequence'=='true'">  
			<sql>update tblCodeGenerate set curValue=curValue+1 where code='SE'</sql>
		</exec>	
	</sql>
</define>

<!--================点击删除，修改时调用==========-->
<define name="SalesOutStock_Delete">
	<sql type="condition">
	<!--如果关联销售订单回填销售订单信息-->
	<exec condition="true">
		<sql type="procedure">{call proc_SalesUpdateOrderQty(@ValueofDB:tblSalesOutStock_id,delete,retCode,retVal)}</sql>
	</exec>	
	<!--如果启用审核流，则删除单据时更新分仓库存-未审核字段-->
	<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesOutStockDet.GoodsCode,@StockCode=tblSalesOutStockDet.StockCode,@BillType=tblSalesOutStock,@InstoreQty=0,@OutstoreQty=-1*tblSalesOutStockDet.Qty,@from=tblSalesOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<!--删除和修改操作时，更新序列号出入明细-->
	<exec condition="'@Sess:BillOper' =='delete'||'@Sess:BillOper' =='update'">
		<sql>delete from tblSeqAuditing where BillID=@ValueofDB:id</sql>
	</exec>	
	
	<!--启用审核后能修改或者删除的说明此单没有审核，不必调用此define. 不启用审核流，执行所有控制及过账操作，启用审核，点击反审核时执行此操作-->
	<exec condition="'@MEM:tblSalesOutStock_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
		<sql type="define">SalesOutStock_Delete_One</sql>
	</exec>
</sql>
</define>

<define name="SalesOutStock_Delete_One">
<!--===判断如果此单据有如下关联，不允许删除====-->
	<sql type="condition"><!--被采购入库单引用判断提示-->		
		<condition><select>select top 1 BillNo from tblBuyInStock left join tblBuyInStockDet on tblBuyInStock.id=tblBuyInStockDet.f_ref where tblBuyInStockDet.SalesOutID=@ValueofDB:tblSalesOutStock_id</select></condition>		
		<exec condition="'@SqlReturn:BillNo'!='null'">
			<error>BuyOrderDel.BillNo.error,@SqlReturn:BillNo</error>       
		</exec>
	</sql>
	<sql type="condition"><!--存在关联的销售退货单，不允许此操作-->
	<condition><select>select BillNo as SalesReturnNo from tblSalesReturnStock a,tblSalesReturnStockDet b where a.id=b.f_ref and b.SalesOutStockID=@ValueofDB:tblSalesOutStock_id and a.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:SalesReturnNo' != 'null'">	 					
		<error>SalesBillDel.BillNo.error,@SqlReturn:SalesReturnNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--存在不是自动产生的销售收款单，不允许此操作-->
	<condition><select>select a.BillNo as ReBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and a.AutoBillMarker=0 and b.RefbillID=@ValueofDB:tblSalesOutStock_id</select></condition>
	<exec condition="'@SqlReturn:ReBillNo' != 'null'">	 					
		<error>DelBill.ReBillNo.error,@SqlReturn:ReBillNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--自动产生的收款单存在收款退款，不允许此操作-->
	<condition><select>select a.BillNo as ReRBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and b.RefbillID=(select c.id from tblSaleReceive c,tblSaleReceiveDet d where c.id=d.f_ref and c.AutoBillMarker=1 and d.RefbillID=@ValueofDB:tblSalesOutStock_id)</select></condition>
	<exec condition="'@SqlReturn:ReRBillNo' != 'null'">	 					
		<error>tblsalereceive.ReturnBill.error,@SqlReturn:ReRBillNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--存在关联的销售开票，不允许此操作-->
	<condition><select>select a.BillNo as InvoiceBillNo from tblSalesInvoiceInfo a,tblSalesInfoDet b where a.id=b.f_ref and b.RefBillID=@ValueofDB:tblSalesOutStock_id and a.workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:InvoiceBillNo' != 'null'">	 					
		<error>tblSalesInfoDet.BillNo.error,@SqlReturn:InvoiceBillNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--存在关联的销售换货单，不允许此操作-->
		<condition><select>select BillNo as SalesReplaceNo from tblSalesReplace where SalesOutStockID=@ValueofDB:tblSalesOutStock_id</select></condition>
	<exec condition="'@SqlReturn:SalesReplaceNo' != 'null'">	 					
		<error>SalesReplaceDel.BillNo.error,@SqlReturn:SalesReplaceNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--存在关联的预收转应收，不允许此操作-->
	<condition><select>select a.BillNo as TFS1BillNo from tblTransferSale1 a,tblTransferSaleDet1 b where a.id=b.f_ref and a.workFlowNodeName!='print' and b.RefSalesOutID=@ValueofDB:tblSalesOutStock_id</select></condition>
	<exec condition="'@SqlReturn:TFS1BillNo' != 'null'">	 					
		 <error>SalesInfoDet.ReTFS1No.error,@SqlReturn:TFS1BillNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--存在关联的应付转应收，不允许此操作-->
	<condition><select>select a.BillNo as TFS2BillNo from tblTransferSale2 a,tblTransferSaleDet2 b where a.id=b.f_ref and a.workFlowNodeName!='print' and b.refbillID=(select BillNo from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id)</select></condition>
	<exec condition="'@SqlReturn:TFS2BillNo' != 'null'">	 					
		 <error>SalesInfoDet.ReTFS2No.error,@SqlReturn:TFS2BillNo</error>       
	</exec>
	</sql>
	<sql type="condition"><!--判断是否存在对应应付转应收-->
	<condition><select>select tblTransferSale4.BillNo as TFS4No from tblTransferSale4 where RefBillNo=(select BillNo from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id) and workFlowNodeName!='print'</select></condition>
	<exec condition="'@SqlReturn:TFS4No'!='null'">	
		<error>BuyInvoice.ReTFS4No.error,@SqlReturn:TFS4No</error>                  
	</exec>
</sql>
<sql type="condition"><!--存在关联的应收调账单，不允许此操作-->
	<condition><select>select a.BillNo as AccBillNo from tblAccAdjust a,tblAccAdjustDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and b.RefBillID=@ValueofDB:tblSalesOutStock_id</select></condition>
	<exec condition="'@SqlReturn:AccBillNo' != 'null'">	 					
		<error>SalesAccDel.BillNo.error,@SqlReturn:AccBillNo</error>       
	</exec>
</sql>
<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
	<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblSalesOutStock_id and workFlowNodeName='finish'</select></condition>
		<exec condition="'@SqlReturn:OrderNo'!='null'">	
			<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
</sql>	
<sql type="condition">
<!--如果启用审核流，更新序列号审核库存表-->
		<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
</sql>		
<!--=================逻辑操作==============-->
<!--判断如果启用了序列号，验证出库单删除后是否有1个以上相同的序列号-->
<sql type="condition">
	<condition><select>select 'isUsed' as isUseSeq from tblGoodsAttribute where propName='Seq' and isUsed=1</select></condition>
	<!--如果启用审核流，则过账时更新分仓库存+未审核字段-->
	<exec condition="'@MEM:tblSalesOutStock_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesOutStockDet.GoodsCode,@StockCode=tblSalesOutStockDet.StockCode,@BillType=tblSalesOutStock,@InstoreQty=0,@OutstoreQty=tblSalesOutStockDet.Qty,@from=tblSalesOutStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<exec condition="true"><!--删除出入库明细-->
		<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblSalesOutStock_id,tblSalesOutStock,2,retCode,retVal)}</sql>
	</exec>
	<!--出库单在删除，反审核时进行序列号判断，如果是修改操作，要修改后进行判断-->
	<exec condition="'@Sess:BillOper'!='update'">
		<sql type="define">validateSameSeq</sql>
	</exec>
</sql>
<sql type="condition">
	<condition>
		<select>select BillNo,SalesOrderID,StockCode,AlrAccAmt,CurAlrAccAmt,BillDate from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id</select>
	</condition>
	<exec condition="true">	<!--分摊销售订单订金回填销售订单累积付款-->
		<sql type="procedure">{call proc_SalesOutReceiveAmort(@ValueofDB:tblSalesOutStock_id,delete,retCode,retVal)}</sql>
	</exec>
	<exec condition="true"> <!--根据是否启用预收预付记应收应付,决定删除往来明细的类型（1应付 2应收 3预付 4预收)-->
		<sql type="procedure">{call proc_iterateExeProc(select id as IniId@SPFieldLink:case when isnull(ReceiveTotalDebit@RepComma:0)!=0 or isnull(ReceiveTotalLend@RepComma:0)!=0 then 2 when isnull(PreReceiveTotalDebit@RepComma:0)!=0 or isnull(PreReceiveTotalLend@RepComma:0)!=0 then (case when '@MEM:prerecvpaymarktoneedrecvpay'='true' then 2 else 4 end) end as ComType from tblCompanyIni where relationDocID='@ValueofDB:tblSalesOutStock_id',proc_deleteComIni,@IniId@ParamLink:@ComType,retCode,retVal)}</sql>
	</exec>
	<exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblSalesOutStock_id,retCode,retVal)}</sql>
	</exec>
	<exec condition="@SqlReturn:AlrAccAmt&gt;0"><!--本次结算金额大于0，删除自动产生的应收款-->
		<sql>delete from tblSaleReceive where id in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOutStock_id) and AutoBillMarker=1</sql>
		<sql>delete from tblSalesRecAccount where f_ref=(select top 1 f_ref from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and b.RefbillID=@ValueofDB:tblSalesOutStock_id and AutoBillMarker=1)</sql>
		<sql>delete from tblTrackBill where RelationID in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOutStock_id)</sql>
		<sql>delete from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesOutStock_id and (select AutoBillMarker from tblSaleReceive where id=tblSaleReceiveDet.f_ref)=1</sql>
	</exec>
</sql>
</define>
<!--=========手工删除凭证============-->
<define name="tblSalesOutStock_deleteAcc_hand">
	<sql type="condition"><!--如果此单据没有生成凭证，则不用删除凭证-->
		<condition><select>select BillNo from tblSalesOutStock where id=@ValueofDB:tblSalesOutStock_id and IsCreateAcc='0'</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">	
			<error>common.NotCreateAcc.Del.Error,@SqlReturn:BillNo</error>       
		</exec>
	</sql>
	<sql type="condition"><!--当前单据凭证所在期间已经月结，则不能删除此凭证-->
		<condition><select>select c.BillNo,b.statusId,a.CredTypeID,a.OrderNo from tblAccMain a,tblAccPeriod b,tblSalesOutStock c where a.RefBillID=@ValueofDB:tblSalesOutStock_id and c.id=@ValueofDB:tblSalesOutStock_id and a.CredYear=b.AccYear and a.Period=b.AccPeriod</select></condition>
		<exec condition="'@SqlReturn:statusId'!='null'&amp;&amp;'@SqlReturn:statusId'=='2'">	
			<error>common.AccPeriodSettle.error,@SqlReturn:BillNo,@SqlReturn:CredTypeID,@SqlReturn:OrderNo</error>       
		</exec>
	</sql>
	<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,delete,@ValueofDB:tblSalesOutStock_id,retCode,retVal)}</sql>
	<sql>update tblSalesOutStock set IsCreateAcc='0' where id=@ValueofDB:tblSalesOutStock_id</sql>
</define>

<!--===============================================以上代码：销售出库单===================================================================-->

<!--============================================================销售退货单============================================================-->
<define name="SalesReturnStock_Add">
	<!--================控制类操作===================-->
	<sql type="condition">
		<!--输入了付款金额，没有选择结算账户时给出提示-->
		<exec condition="@ValueofDB:tblSalesReturnStock_AccountAmount!=0 &amp;&amp; '@ValueofDB:tblSalesReturnStock_Account'.length==0 "> 
			<error>请选择结算账户</error>                  
		</exec>	
		<!--选择了结算账户，输入付款金额小于等于0时给出提示-->
		<exec condition="@ValueofDB:tblSalesReturnStock_AccountAmount&lt;=0 &amp;&amp; '@ValueofDB:tblSalesReturnStock_Account'.length &gt; 0 "> 
			<error>请输入大于0的付款金额</error>                  
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblSalesReturnStock_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblSalesReturnStock_Tax!=0)||@ValueofDB:tblSalesReturnStock_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>        
		</exec>
	</sql>	

	<sql type="condition">		
		<exec condition="'@ValueofDB:tblSalesReturnStock_SalesOutStockID'.length&gt;0"><!--如果引用单据，用主表的出库单ID更新明细表-->
			<sql>update tblSalesReturnStockDet set SalesOrderID=@ValueofDB:tblSalesReturnStock_SaleOrderID,SalesOutStockID=@ValueofDB:tblSalesReturnStock_SalesOutStockID where f_ref=@ValueofDB:tblSalesReturnStock_id and len(isnull(SalesOutStockID,''))=0</sql>
		</exec>
		<exec condition="true"><!--如果引用销售出库单，做如下控制-->
			<sql type="define">SalesReturnStock_QuoteSalesOut_validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择的商品的数量必须大于0-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblSalesReturnStockDet a,tblGoods b where isnull(a.Qty,0)&lt;=0 and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReturnStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>
	<sql type="condition"><!--判断所选择的商品的申请退货数量不能小于0-->
		<condition><select>select b.GoodsFullName as GoodsAQ from tblSalesReturnStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReturnStock_id and isnull(a.ApplyQty,0)&lt;0 and b.classCode=a.GoodsCode</select></condition>
		<exec condition="'@SqlReturn:GoodsAQ' != 'null'">			
			<error>common.AQty.negative.error,@SqlReturn:GoodsAQ</error>       
		</exec>
	</sql>
	<sql type="condition"><!--判断是否存单价小于0的商品-->
		<condition><select>select b.GoodsFullName as GoodsP from tblSalesReturnStockDet a,tblGoods b where isnull(a.Price,0)&lt;0 and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReturnStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsP' != 'null'">			
			<error>common.price.lessZero.error,@SqlReturn:GoodsP</error>       
		</exec>
	</sql>
	<sql type="condition"><!--非赠品，样品单价小于的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblSalesReturnStockDet a,tblGoods b where (isnull(a.Price,0)&lt;0) and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReturnStock_id and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>	
	<sql type="condition"><!--判断是否存在是赠品，样品但单价不等于0-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblSalesReturnStockDet a,tblGoods b where isnull(a.Price,0)!=0 and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReturnStock_id and a.PresentSampleType in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>        
		</exec>
	</sql>
	<sql type="condition"><!--生产日期大于保质期限时，给出提示-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblSalesReturnStockDet a,tblGoods b where len(a.ProDate)&gt;0 and len(a.Availably)&gt;0 and a.ProDate&gt;a.Availably and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReturnStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.proDateAfterAvailably.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>
	<sql type="condition"><!--启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblSalesReturnStockDet a left join tblgoods c on c.classCode=a.GoodsCode where c.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblSalesReturnStock_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>       
	    </exec>
	</sql>
	<sql type="condition"><!--如果启用了其他配置：销售退货单条码复合，做如下控制-->
		<exec condition="'@MEM:BarcodecheckedSalesReturn'=='true'">
			<sql type="define">SalesReturnStock_Barcodechecked_validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--细表的合计金额，和主表的总金额不相等时给出错误提示-->
		<condition><select>select dbo.getDigits('tblSalesReturnStockDet','TaxAmount',sum(TaxAmount)) as SumDetAmt from tblSalesReturnStockDet where  f_ref=@ValueofDB:tblSalesReturnStock_id</select></condition>
		<exec condition="@SqlReturn:SumDetAmt!=@ValueofDB:tblSalesReturnStock_TotalTaxAmount">			
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblSalesReturnStock_TotalTaxAmount,@SqlReturn:SumDetAmt</error>       
		</exec>
	</sql>
	<sql type="condition"><!--折扣不是0到100之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesReturnStockDet a where a.f_ref=@ValueofDB:tblSalesReturnStock_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>
	
	<!--========以下代码：外币控制暂不处理==============-->
	<!--帐户及现金提示-->
	<sql type="condition"> 
		<condition><select>select AccNumber,AccName,IsForCur,Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblSalesReturnStock_Account and SCompanyID=@ValueofDB:tblSalesReturnStock_SCompanyID</select></condition>	
		<!--币种不为空，付款帐户不为空时，选择的付款帐户核算的币种跟所选的币种不一致时提示-->			
		<exec condition="'@ValueofDB:tblSalesReturnStock_Currency'.length != 0 &amp;&amp; '@ValueofDB:Account' != '' &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  ) ">
				<error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>	
			
    <!--币种为空，付款帐户不为空时，选择的付款帐户存在核算外币时提示-->	  <!--选择的收款帐户不是该币种对应的帐户-->
		<exec condition="'@ValueofDB:tblSalesReturnStock_Currency'.length == 0 &amp;&amp; '@ValueofDB:Account' != '' &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL') ">
				<error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>	
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblSalesReturnStock_Currency'.length == 0 &amp;&amp; @ValueofDB:tblSalesReturnStock_CurrencyRate&gt;0 &amp;&amp;@ValueofDB:tblSalesReturnStock_CurrencyRate!=1)">		
     		<error>CurrencyRate.putErrors.error</error>       
	  </exec>
	</sql>
	<!--========以上代码：外币控制暂不处理==============-->


	<!--==========逻辑类操作==========-->
	<sql type="condition">
		<!--查询是否存在非赠品，样品，但单价为0的商品,如果有则更新这些单据的单价-->
		<condition><select>select b.GoodsFullName as GoodsNoSample from tblSalesReturnStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReturnStock_id and b.classCode=a.GoodsCode and isnull(a.Price,0)=0 and a.PresentSampleType not in ('1','2')</select></condition>
		<!--假如没有启用多仓库，用主表的仓库更新明细表-->
		<exec condition="'@MEM:ManyStockSales'=='false'">
			<sql>update tblSalesReturnStockDet set StockCode=@ValueofDB:tblSalesReturnStock_StockCode where f_ref=@ValueofDB:tblSalesReturnStock_id</sql>
		</exec>	
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			update tblSalesReturnStockDet set tblSalesReturnStockDet.Availably=a.Availably from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,tblGoods.Validity,ProDate),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,tblGoods.Validity,ProDate),21) else '' end as Availably from tblSalesReturnStock a join tblSalesReturnStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblSalesReturnStock_id and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0)a where tblSalesReturnStockDet.id=a.id
			</sql>
			<sql><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			update tblSalesReturnStockDet set tblSalesReturnStockDet.ProDate=a.ProDate from(select  b.id as id,case when tblGoods.AvailablyType='Day' then convert(varchar(10),dateadd(Day,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Month' then convert(varchar(10),dateadd(Month,(-1)*tblGoods.Validity,Availably),21) when tblGoods.AvailablyType='Year' then convert(varchar(10),dateadd(Year,(-1)*tblGoods.Validity,Availably),21) else '' end as ProDate from tblSalesReturnStock a join tblSalesReturnStockDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id=@ValueofDB:tblSalesReturnStock_id and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0)a where tblSalesReturnStockDet.id=a.id
			 </sql>
		</exec>
		<!--如果存在单价为0的商品，更新这些销售价-->
		<exec condition="'@SqlReturn:GoodsNoSample'!='null'">
			<sql type="define">SalesReturnStock_Price_update</sql>
		</exec>		
		<exec condition="true">
			<!--拿最近的入库价更新销售退货单的成本价-->
			<sql>update tblSalesReturnStockDet set CostPrice=round(isnull((select case when sum(InstoreQty)=0 then 0 else dbo.getDigits('tblStockDet','instorePrice',sum(InstoreAmount)/sum(InstoreQty)) end from tblStockDet a where a.goodsCode=tblSalesReturnStockDet.goodsCode and a.stockCode=tblSalesReturnStockDet.stockCode and a.ProDate=tblSalesReturnStockDet.ProDate and a.Availably=tblSalesReturnStockDet.Availably and a.Hue=tblSalesReturnStockDet.Hue and a.yearNO=tblSalesReturnStockDet.yearNO and a.BatchNo=tblSalesReturnStockDet.BatchNo and a.Inch=tblSalesReturnStockDet.Inch and ((len(tblSalesReturnStockDet.seq)=0 and len(a.seq)=0) or (len(tblSalesReturnStockDet.seq)&gt;0 and len(a.seq)&gt;0 and charindex(a.seq+'~',tblSalesReturnStockDet.seq)&gt;0)) and itemNo=isnull((select max(itemNo) from tblStockDet b where a.goodPropHash=b.goodPropHash and b.billDate&lt;=@ValueofDB:tblSalesReturnStock_BillDate and instorePrice&gt;0 and InstoreQty&gt;0),0)),0),@MEM:DigitsPrice) where f_ref=@ValueofDB:tblSalesReturnStock_id and CostPrice&lt;=0</sql>
			<!--更新没有成本价的商品 取预设进价-->
			<sql>update tblSalesReturnStockDet set CostPrice=isnull(tblGoods.PreBuyPrice,0) from tblGoods where tblGoods.classCode=tblSalesReturnStockDet.GoodsCode and f_ref=@ValueofDB:tblSalesReturnStock_id and CostPrice&lt;=0</sql>			
			<!--给明细表待收款金额赋初始值：含税金额=待收款金额,成本金额=数量*成本单价,未开票数=退货数，开票数=0-->
			<sql>update tblSalesReturnStockDet set NoInvoiceQty=Qty,InvoiceQty=0,NeedReceiveAmt=TaxAmount,CurNeedReceiveAmt=CurAmount,CostAmount=round(CostPrice*Qty,@MEM:DigitsAmount) where f_ref=@ValueofDB:tblSalesReturnStock_id</sql>
			<!--引用了销售出库单更新销售出库单退货数，实际出库数及相关的销售订单-->
			<sql type="procedure">{call proc_SalesReturnUpdateBillQty(@ValueofDB:tblSalesReturnStock_id,add,retCode,retVal)}</sql>
	
	        <!-- 更新销售退货单中 调价金额 调价后金额 已开票金额 未开票金额 -->
			<sql>update tblSalesReturnStock set AfterChangeAmt=TotalTaxAmount,CurAfterChangeAmt=CurTotalAmount,ChangeAmt=0 where id=@ValueofDB:tblSalesReturnStock_id </sql>
			<sql>update tblSalesReturnStockDet set AfterChangeAmt=tblSalesReturnStockDet.TaxAmount,CurAfterChangeAmt=tblSalesReturnStockDet.CurAmount, ChangeAmt=0 from tblSalesReturnStockDet where tblSalesReturnStockDet.f_ref=@ValueofDB:tblSalesReturnStock_id</sql>
			<sql>update tblSalesReturnStock set NoInvoiceAmount=AfterChangeAmt,InvoiceAmount=0 where id=@ValueofDB:tblSalesReturnStock_id </sql>
			<sql>update tblSalesReturnStockDet set NoInvoiceAmount=AfterChangeAmt, InvoiceAmount=0 from tblSalesReturnStockDet where tblSalesReturnStockDet.f_ref=@ValueofDB:tblSalesReturnStock_id</sql>
		</exec>
		<!--不引用单据更新累计付款金额，待付款金额(必须先更新了销售价，总金额后，才可以更新此字段)-->
		<exec condition="'@ValueofDB:tblSalesReturnStock_SalesOutStockID'.length==0">
			<sql>update tblSalesReturnStock set NeedPayAmt=TotalTaxAmount-AccountAmount,AlreadyPayAmt=AccountAmount,CurNeedPayAmt=CurTotalAmount-CurAccountAmount,CurAlreadyPayAmt=CurAccountAmount,CertificateNo='' where id=@ValueofDB:tblSalesReturnStock_id </sql>
		</exec>
		<!--引用出库单时更新累计付款金额，待付款金额-->
		<exec condition="'@ValueofDB:tblSalesReturnStock_SalesOutStockID'.length&gt;0">
			<sql>update tblSalesReturnStock set NeedPayAmt=(select (case when tblSalesReturnStock.TotalTaxAmount-tblSalesReturnStock.AccountAmount-NeedReturnAmt&lt;=0 then 0 else tblSalesReturnStock.TotalTaxAmount-tblSalesReturnStock.AccountAmount-NeedReturnAmt end) from tblSalesOutStock where id=@ValueofDB:tblSalesReturnStock_SalesOutStockID),AlreadyPayAmt=AccountAmount,CurNeedPayAmt=(select (case when tblSalesReturnStock.CurTotalAmount-tblSalesReturnStock.CurAccountAmount-CurNeedReturnAmt&lt;=0 then 0 else tblSalesReturnStock.CurTotalAmount-tblSalesReturnStock.CurAccountAmount-CurNeedReturnAmt end) from tblSalesOutStock where id=@ValueofDB:tblSalesReturnStock_SalesOutStockID),CurAlreadyPayAmt=CurAccountAmount,CertificateNo='' where id=@ValueofDB:tblSalesReturnStock_id </sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesReturnStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReturnStockDet.GoodsCode,@StockCode=tblSalesReturnStockDet.StockCode,@BillType=tblSalesReturnStock,@InstoreQty=tblSalesReturnStockDet.Qty,@OutstoreQty=0,@from=tblSalesReturnStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--不启用审核时，保存后就直接过账-->
		<exec condition="'@MEM:tblSalesReturnStock_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">SalesReturnStock_Add_One</sql>
		</exec>
	</sql>	
</define>

<!--==============销售退货单引用销售出库单的判断=================-->
<define name="SalesReturnStock_QuoteSalesOut_validate">
	<sql type="condition"><!--判断销售退货的单据日期在引用销售出单前，给出错误提示-->
		<condition><select>select a.BillNo,billDate as BuyInDate from tblSalesOutStock a,tblSalesReturnStockDet b where b.f_ref=@ValueofDB:tblSalesReturnStock_id and b.SalesOutStockID=a.id and a.BillDate&gt;@ValueofDB:tblSalesReturnStock_BillDate</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.QuoteDate.error,@SqlReturn:BillNo,@SqlReturn:BuyInDate</error>       
		</exec>
	</sql>
	<sql type="condition"><!--客户不同，给出错误提示-->
		<condition><select>select a.BillNo,c.ComFullName from tblSalesOutStock a,tblSalesReturnStockDet b,tblCompany c where b.f_ref=@ValueofDB:tblSalesReturnStock_id and b.SalesOutStockID=a.id and a.CompanyCode=c.classCode and a.CompanyCode!=@ValueofDB:tblSalesReturnStock_CompanyCode</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">			
			<error>common.clientQuote.error,@SqlReturn:BillNo,@SqlReturn:ComFullName</error>       
		</exec>
	</sql>
	<sql type="condition"><!--发票类型不同，给出错误提示-->
		<condition><select>select a.BillNo from tblSalesOutStock a,tblSalesReturnStockDet b where b.f_ref=@ValueofDB:tblSalesReturnStock_id and b.SalesOutStockID=a.id and a.InVoiceType!=@ValueofDB:tblSalesReturnStock_InVoiceType</select></condition>
		<exec condition="'@SqlReturn:BillNo'!='null'">						
			<error>common.InVoiceTypeQuote.error,@SqlReturn:BillNo</error>       
		</exec>
	</sql>
	<sql type="condition"><!--税率不同，给出错误提示-->
		<condition><select>select a.BillNo as BillNoT,dbo.getDigits('tblSalesOutStock','Tax',a.Tax )as QTax from tblSalesOutStock a,tblSalesReturnStockDet b where b.f_ref=@ValueofDB:tblSalesReturnStock_id and b.SalesOutStockID=a.id and a.Tax!=@ValueofDB:tblSalesReturnStock_Tax</select></condition>
		<exec condition="'@SqlReturn:BillNoT'!='null'">						
			<error>common.TaxQuote.error,@SqlReturn:BillNoT,@SqlReturn:QTax</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货数量大于实际入库数量，给出错误提示-->
		<condition><select>select l.BillNo,k.GoodsFullName from tblSalesReturnStockDet a,tblGoods k,tblSalesOutStock l where f_ref=@ValueofDB:tblSalesReturnStock_id and LEN(SalesOutStockID)&gt;0 and a.SalesOutStockID=l.id and a.GoodsCode=k.classCode group by SalesOutStockID,l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,k.GoodsFullName
having SUM(Qty)&gt;(select sum(FactOutQty) from tblSalesOutStockDet b where b.f_ref=a.SalesOutStockID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO and a.ProDate=b.ProDate and a.Availably=b.Availably)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName'!='null'">			
			<error>common.ReturnOutQtyQuote.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName</error>       
		</exec>
	</sql>
</define>
<!--==============启用条码复合的判断===========================-->
<define name="SalesReturnStock_Barcodechecked_validate">
	<sql type="condition">
		<condition><select>select b.GoodsFullName as CheckGoods from tblSalesReturnStockDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReturnStock_id and a.goodsCode=b.classCode and b.BarCode!=a.CheckBarCode</select></condition>	    	
		<exec condition="'@SqlReturn:CheckGoods' != 'null'">					
			<error>CheckBarCode.diffent.error,@SqlReturn:CheckGoods</error>       
		</exec>
	</sql>
</define>
<!--==============更新非赠品，样品的销售价======================-->
<define name="SalesReturnStock_Price_update">
	<!--更新没有销售价的商品,取此客户此商品在当前单据之前的最近售价-->
	<sql>update tblSalesReturnStockDet set price=round(isnull((select dbo.getDigits('tblStockDet','SalesPrice',case when sum(SalesQty)=0 then 0 else sum(SalesAmount)/sum(SalesQty) end) from tblStockDet a where a.goodsCode=tblSalesReturnStockDet.goodsCode and a.stockCode=tblSalesReturnStockDet.stockCode and a.ProDate=tblSalesReturnStockDet.ProDate and a.Availably=tblSalesReturnStockDet.Availably and a.Hue=tblSalesReturnStockDet.Hue and a.yearNO=tblSalesReturnStockDet.yearNO and a.BatchNo=tblSalesReturnStockDet.BatchNo and a.Inch=tblSalesReturnStockDet.Inch and ((len(tblSalesReturnStockDet.seq)=0 and len(a.seq)=0) or (len(tblSalesReturnStockDet.seq)&gt;0 and len(a.seq)&gt;0 and charindex(a.seq+'~',tblSalesReturnStockDet.seq)&gt;0)) and itemNo=isnull((select max(itemNo) from tblStockDet b where a.goodPropHash=b.goodPropHash and b.billDate&lt;=@ValueofDB:tblSalesReturnStock_BillDate and BillType in ('tblSalesOutStock','tblSalesReplace') and b.OutstoreQty!=0 and b.companyCode=@ValueofDB:tblSalesReturnStock_CompanyCode and SalesPrice&gt;0),0)),0),@MEM:DigitsPrice) where f_ref=@ValueofDB:tblSalesReturnStock_id and isnull(Price,0)=0 and tblSalesReturnStockDet.PresentSampleType not in ('1','2')</sql>
	<!--更新没有销售价的商品,此商品在当前单据之前的最近售价-->
	<sql>update tblSalesReturnStockDet set price=round(isnull((select dbo.getDigits('tblStockDet','SalesPrice',case when sum(SalesQty)=0 then 0 else sum(SalesAmount)/sum(SalesQty) end) from tblStockDet a where a.goodsCode=tblSalesReturnStockDet.goodsCode and a.stockCode=tblSalesReturnStockDet.stockCode and a.ProDate=tblSalesReturnStockDet.ProDate and a.Availably=tblSalesReturnStockDet.Availably and a.Hue=tblSalesReturnStockDet.Hue and a.yearNO=tblSalesReturnStockDet.yearNO and a.BatchNo=tblSalesReturnStockDet.BatchNo and a.Inch=tblSalesReturnStockDet.Inch and ((len(tblSalesReturnStockDet.seq)=0 and len(a.seq)=0) or (len(tblSalesReturnStockDet.seq)&gt;0 and len(a.seq)&gt;0 and charindex(a.seq+'~',tblSalesReturnStockDet.seq)&gt;0)) and itemNo=isnull((select max(itemNo) from tblStockDet b where a.goodPropHash=b.goodPropHash and b.billDate&lt;=@ValueofDB:tblSalesReturnStock_BillDate and BillType in ('tblSalesOutStock','tblSalesReplace') and b.OutstoreQty!=0 and SalesPrice&gt;0),0)),0),@MEM:DigitsPrice) where f_ref=@ValueofDB:tblSalesReturnStock_id and isnull(Price,0)=0 and tblSalesReturnStockDet.PresentSampleType not in ('1','2')</sql>
	<!--取此客户在客户表中设置的预设售价对应商品的价格-->
	<sql>update tblSalesReturnStockDet set price=isnull((select CASE a.ComSalesType WHEN 'ProSalesPrice' THEN c.ProSalesPrice WHEN 'ProSalesPrice2' THEN c.ProSalesPrice2 WHEN 'ProSalesPrice3' THEN c.ProSalesPrice3 WHEN 'ProSalesPrice4' THEN c.ProSalesPrice4 WHEN 'ProjectPrice' THEN c.ProjectPrice WHEN 'ProSalesPrice5' THEN c.ProSalesPrice5 WHEN 'ProSalesPrice6' THEN c.ProSalesPrice6 WHEN 'ProSalesPrice7' THEN c.ProSalesPrice7 WHEN 'ProSalesPrice8' THEN c.ProSalesPrice8 WHEN 'ProSalesPrice9' THEN c.ProSalesPrice9 ELSE c.FacePrice END from tblCompany a,tblGoods c where a.classCode=@ValueofDB:tblSalesReturnStock_CompanyCode and c.classCode=tblSalesReturnStockDet.goodsCode),0) where f_ref=@ValueofDB:tblSalesReturnStock_id and isnull(Price,0)=0 and tblSalesReturnStockDet.PresentSampleType not in ('1','2')</sql>
	<!--取商品表中预设售价组中第一组的预设售价-->
	<sql>update tblSalesReturnStockDet set price=isnull((SELECT TOP 1 Price FROM (select a.ProSalesPrice Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice2 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice3 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice4 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProjectPrice Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice5 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice6 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALl select a.ProSalesPrice7 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice8 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.ProSalesPrice9 Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode UNION ALL select a.FacePrice Price from tblGoods a where a.classCode=tblSalesReturnStockDet.goodsCode) a),0) where f_ref=@ValueofDB:tblSalesReturnStock_id and isnull(Price,0)=0 and tblSalesReturnStockDet.PresentSampleType not in ('1','2')</sql>
	<!--更新明细表总金额-->	
	<sql>update tblSalesReturnStockDet set Amount=round(Qty*Price,@MEM:DigitsAmount),DisPrice=round(Discount*Price/100,@MEM:DigitsPrice),DisBackAmt=round(Qty*Discount*Price/100,@MEM:DigitsAmount),DisAmount=round(Qty*(100-Discount)*Price/100,@MEM:DigitsAmount),TaxPrice=round(Discount*Price*(100+@ValueofDB:tblSalesReturnStock_Tax)/10000,@MEM:DigitsPrice),CoTaxAmt=round(Qty*Price*Discount*@ValueofDB:tblSalesReturnStock_Tax/10000,@MEM:DigitsAmount),TaxAmount=round(Qty*Discount*Price*(100+@ValueofDB:tblSalesReturnStock_Tax)/10000,@MEM:DigitsAmount),CurPrice=round(Discount*Price*(100+@ValueofDB:tblSalesReturnStock_Tax)/10000/@ValueofDB:tblSalesReturnStock_CurrencyRate,@MEM:DigitsAmount),CurAmount=round(Qty*Discount*Price*(100+@ValueofDB:tblSalesReturnStock_Tax)/10000/@ValueofDB:tblSalesReturnStock_CurrencyRate,@MEM:DigitsAmount),UnitPrice=case isnull(UnitQty,0) when 0 then 0 else round(Qty*isnull(Price,0)/UnitQty,@MEM:DigitsPrice) end where Price!=0 and f_ref=@ValueofDB:tblSalesReturnStock_id</sql>
	<!--更新主表总金额-->
	<sql>update tblSalesReturnStock set TotalAmount=b.detTotalAmount,DisAmount=b.detDisAmount,TotalTaxAmount=b.detTaxAmount,TotalCoTaxAmt=b.detTotalCoTaxAmt,CurTotalAmount=b.detCurAmount from (select sum(CoTaxAmt) as detTotalCoTaxAmt,sum(TaxAmount) as detTaxAmount,sum(DisBackAmt) as detTotalAmount,sum(DisAmount) as detDisAmount,sum(CurAmount) as detCurAmount from tblSalesReturnStockDet where f_ref=@ValueofDB:tblSalesReturnStock_id) b where tblSalesReturnStock.id=@ValueofDB:tblSalesReturnStock_id</sql>
</define>
<!--==================销售退货单过账操作===================-->
<define name="SalesReturnStock_Add_One">
	<sql type="condition">
		<!--回填被引用的订单的退货数量-->
		<exec condition="true">
			<sql type="procedure">{call proc_ReturnBackOrder(@ValueofDB:id,add,tblSalesReturnStock,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesReturnStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReturnStockDet.GoodsCode,@StockCode=tblSalesReturnStockDet.StockCode,@BillType=tblSalesReturnStock,@InstoreQty=-1*tblSalesReturnStockDet.Qty,@OutstoreQty=0,@from=tblSalesReturnStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<exec condition="true">
			<!--影响库存，更新出入库明细表-->
			<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblSalesReturnStock_Period,@PeriodYear=@ValueofDB:tblSalesReturnStock_PeriodYear,@PeriodMonth=@ValueofDB:tblSalesReturnStock_PeriodMonth,@GoodsCode=tblSalesReturnStockDet.GoodsCode,@StockCode=tblSalesReturnStockDet.StockCode,@BillID=@ValueofDB:tblSalesReturnStock_id,@BillType=tblSalesReturnStock,@BillDate=@ValueofDB:tblSalesReturnStock_BillDate,@BillNo=@ValueofDB:tblSalesReturnStock_BillNo,@InstoreQty=tblSalesReturnStockDet.Qty,@InstorePrice=tblSalesReturnStockDet.CostPrice,@InstoreAmount=tblSalesReturnStockDet.CostAmount,@createBy=@ValueofDB:tblSalesReturnStock_createBy,@lastUpdateBy=@ValueofDB:tblSalesReturnStock_lastUpdateBy,@createTime=@ValueofDB:tblSalesReturnStock_finishTime,@lastUpdateTime=@ValueofDB:tblSalesReturnStock_lastUpdateTime,@SCompanyID=@ValueofDB:tblSalesReturnStock_SCompanyID,@MRemark=@ValueofDB:tblSalesReturnStock_Remark,@DRemark=tblSalesReturnStockDet.Remark,@SourceID=tblSalesReturnStockDet.id,@CompanyCode=@ValueofDB:tblSalesReturnStock_CompanyCode,@EmployeeID=@ValueofDB:tblSalesReturnStock_EmployeeID,@DepartmentCode=@ValueofDB:tblSalesReturnStock_DepartmentCode,@SalesPrice=tblSalesReturnStockDet.TaxPrice,@SalesAmount=(-1)*tblSalesReturnStockDet.Qty*(tblSalesReturnStockDet.TaxPrice),@SalesQty=(-1)*tblSalesReturnStockDet.Qty,@Amount=(-1)*tblSalesReturnStockDet.Qty*(tblSalesReturnStockDet.DisPrice),@Price=tblSalesReturnStockDet.DisPrice,@TrackNo=tblSalesReturnStockDet.TrackNo,@AccountingPrice=tblSalesReturnStockDet.AccountingPrice,@PresentSampleType=tblSalesReturnStockDet.PresentSampleType,@from=tblSalesReturnStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
			<!--入库时进行序列号重复判断-->
			<sql type="define">validateSameSeq</sql>
		</exec>

		<!--修改后用户可能会把数量改小，所以需要进行负库存判断-->
		<exec condition="'@Sess:BillOper' =='update'">	
			<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
		</exec>
		<!--更新销售出库单的退货金额及付款金额-->
		<exec condition="true">	
			<sql type="procedure">{call proc_SalesReturnRecAmort(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		
		<!--更新未收款数量-->
		<exec condition="true">				  
			<sql>update tblSalesReturnStockDet Set NotPayQty=Qty,PayQty=0 where f_ref=@ValueofDB:id</sql>	
		</exec>
		
	</sql>	
	<!--========产生凭证，影响科目余额，产生往来===========-->
	<sql type="condition">
		<!--发票类型（InVoiceType）分为： 1、普通发票 2、增值税发票 3、收据-->
		<!--系统变量（accSetting）分为：  1、一般纳税人 2、小规模纳税人  3、收据-->
		<condition><select>select (case @MEM:tblAccMain_IsStatart when 0 then '-1' else '0' end) as WFNode,(case @MEM:tblAccMain_IsStatart when 0 then 'finish' else 'notApprove' end) as WFName,TotalTaxAmount as TotalTaxAmt,CurTotalAmount as CurTotalAmount,TotalAmount as TotalAmt,NeedPayAmt as NPayAmt,CurNeedPayAmt as CNPayAmt,TotalTaxAmount-TotalAmount as TaxAmt,0 as curTaxAmt from tblSalesReturnStock where id=@ValueofDB:tblSalesReturnStock_id</select>
		</condition>

		<exec condition="'@MEM:autoGenerateAcc'=='true'&amp;&amp;(@SqlReturn:NPayAmt!=0||@SqlReturn:TotalTaxAmt&gt;0)"><sql type="certificate">tblSalesReturnStock</sql></exec>

		<!--=======产生往来数据======-->
		<!--单据含税金额大于0，借：应收账款 负总金额  往来单位明细 （1应付 2应收 3预付 4预收）-->
		<exec condition="@SqlReturn:TotalTaxAmt&gt;0">
			<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblSalesReturnStock_id,@ValueofDB:tblSalesReturnStock_CompanyCode,2,@ValueofDB:tblSalesReturnStock_BillDate,Period=@ValueofDB:tblSalesReturnStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReturnStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReturnStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=-(@SqlReturn:TotalTaxAmt)@ParamNum:@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReturnStock_id@SPFieldLink:createBy=@ValueofDB:tblSalesReturnStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReturnStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReturnStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReturnStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReturnStock_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesReturnStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReturnStock_CurrencyRate@SPFieldLink:FcRecTotalDebit=-(@SqlReturn:CurTotalAmount)@ParamNum:@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:BillType=tblSalesReturnStock@SPFieldLink:BillNo=@ValueofDB:tblSalesReturnStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReturnStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReturnStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesReturnStock_DisAmount@SPFieldLink:Remark=@ValueofDB:tblSalesReturnStock_Remark,retCode,retVal)}</sql>
		</exec>
		<!--付款金额大于0，贷：应收账款 负付款金额-->
		<exec condition="@ValueofDB:tblSalesReturnStock_AccountAmount&gt;0">
			<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblSalesReturnStock_id,@ValueofDB:tblSalesReturnStock_CompanyCode,2,@ValueofDB:tblSalesReturnStock_BillDate,Period=@ValueofDB:tblSalesReturnStock_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReturnStock_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReturnStock_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@ParamNum:@SPFieldLink:ReceiveTotalLend=-@ValueofDB:tblSalesReturnStock_AccountAmount@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReturnStock_id@SPFieldLink:createBy=@ValueofDB:tblSalesReturnStock_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReturnStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReturnStock_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReturnStock_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReturnStock_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesReturnStock_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReturnStock_CurrencyRate@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:FcRecTotalCredit=-1*(@ValueofDB:tblSalesReturnStock_CurAccountAmount)@ParamNum:@SPFieldLink:BillType=tblSalesReturnStock@SPFieldLink:BillNo=@ValueofDB:tblSalesReturnStock_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReturnStock_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReturnStock_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesReturnStock_DisAmount,retCode,retVal)}</sql>
		</exec>
		<!--如果付款金额大于0，生成销售收款单-->
		<exec condition="@ValueofDB:tblSalesReturnStock_AccountAmount&gt; 0">
			<sql type="define">SalesReturnStock_Add_CreateReceBill</sql>
		</exec>
	</sql>
</define>


<!--=========如果付款金额大于0，生成销售收款单==========-->
<define name="SalesReturnStock_Add_CreateReceBill">
	<sql type="condition">
		<condition><select>select TotalTaxAmount as TotalTaxAmt,CurTotalAmount as CurTotalAmount,NeedPayAmt as NeedPay,(case when Account like '1001%' then 1 else 3 end) as SettleType from tblSalesReturnStock where id=@ValueofDB:tblSalesReturnStock_id</select></condition>

		<exec condition="true">
			<sql>insert into tblSaleReceive (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,SettleType,AcceptTypeID,ExeBalAmt,FactIncome,AccAmt,Currency,CurrencyRate,BillFcAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblSalesReturnStock_id,@ValueofDB:tblSalesReturnStock_BillDate,@CODE:[tblSaleReceive_BillNo],@ValueofDB:tblSalesReturnStock_CompanyCode,@ValueofDB:tblSalesReturnStock_DepartmentCode,@ValueofDB:tblSalesReturnStock_EmployeeID,@SqlReturn:SettleType,'ReturnPay',@ValueofDB:tblSalesReturnStock_AccountAmount,@ValueofDB:tblSalesReturnStock_AccountAmount,@ValueofDB:tblSalesReturnStock_AccountAmount,@ValueofDB:tblSalesReturnStock_Currency,@ValueofDB:tblSalesReturnStock_CurrencyRate,@ValueofDB:tblSalesReturnStock_CurAccountAmount,@ValueofDB:tblSalesReturnStock_PeriodYear,@ValueofDB:tblSalesReturnStock_PeriodMonth,@ValueofDB:tblSalesReturnStock_Period,@ValueofDB:tblSalesReturnStock_createBy,@ValueofDB:tblSalesReturnStock_createTime,@ValueofDB:tblSalesReturnStock_lastUpdateBy,@ValueofDB:tblSalesReturnStock_lastUpdateTime,@ValueofDB:tblSalesReturnStock_SCompanyID,1,'finish','-1','',@ValueofDB:tblSalesReturnStock_TrackNo)</sql>
			<sql>insert into tblSaleReceivedet (id,f_ref,BillAmt,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,SalesOrderNo,SalesOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,ReceiveBillType) values ('1'+@ValueofDB:tblSalesReturnStock_id,'0'+@ValueofDB:tblSalesReturnStock_id,@SqlReturn:TotalTaxAmt,@SqlReturn:CurTotalAmount,(case when cast(@SqlReturn:NeedPay as numeric(18,8))&gt;=0.0 then @ValueofDB:tblSalesReturnStock_AccountAmount else @SqlReturn:TotalTaxAmt end),(case when cast(@SqlReturn:NeedPay as numeric(18,8))&gt;=0.0 then @ValueofDB:tblSalesReturnStock_CurAccountAmount else @SqlReturn:CurTotalAmount end)
			,@ValueofDB:tblSalesReturnStock_Currency,@ValueofDB:tblSalesReturnStock_CurrencyRate,0,@SqlReturn:TotalTaxAmt,0,@SqlReturn:CurTotalAmount,@ValueofDB:tblSalesReturnStock_BillNo,@ValueofDB:tblSalesReturnStock_SaleOrderNo,@ValueofDB:tblSalesReturnStock_SaleOrderID,0,@ValueofDB:tblSalesReturnStock_SCompanyID,0,@ValueofDB:tblSalesReturnStock_id,'tblSalesReturnStock')</sql>
		</exec>
		<!--如果启用了多账户，向多账户明细表中插入数据-->
		<exec condition="true">
			<sql>insert into tblReceiveAccountDet (id,f_ref,SettleType,Amount,ExeBalFcAmt,Account,SCompanyID) values ( '1'+@ValueofDB:tblSalesReturnStock_id,'0'+@ValueofDB:tblSalesReturnStock_id,@SqlReturn:SettleType,@ValueofDB:tblSalesReturnStock_AccountAmount,@ValueofDB:tblSalesReturnStock_CurAccountAmount,@ValueofDB:tblSalesReturnStock_Account,@ValueofDB:tblSalesReturnStock_SCompanyID)</sql>
		</exec>
		<!--自动生成的单据需更新单据编号连续-->
		<exec condition="'@MEM:BillNoSequence'=='true'">  
			<sql>update tblCodeGenerate set curValue=curValue+1 where code='SE'</sql>
		</exec>
		<!--向追踪单号表中插入数据-->
		<exec condition="'@MEM:TrackNo'=='true'">  
			<sql>insert into tblTrackBill(id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID) select  substring(replace(newid(),'-',''),1,30),id,BillNo,'tblSaleReceive',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblSaleReceive where id='0'+@ValueofDB:tblSalesReturnStock_id</sql>
		</exec>
	</sql>
</define>
<!--=========销售退货单删除操作==========-->
<define name="SalesReturnStock_Delete">
	<sql type="condition">
		<!--引用了销售出库单更新销售出库单退货数，实际出库数及相关的销售订单-->
		<exec condition="true">	
			<sql type="procedure">{call proc_SalesReturnUpdateBillQty(@ValueofDB:tblSalesReturnStock_id,delete,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesReturnStock_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReturnStockDet.GoodsCode,@StockCode=tblSalesReturnStockDet.StockCode,@BillType=tblSalesReturnStock,@InstoreQty=-1*tblSalesReturnStockDet.Qty,@OutstoreQty=0,@from=tblSalesReturnStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--启用审核后能修改或者删除的说明此单没有审核，不必调用此define，点击反审核时执行此操作. 不启用审核流，执行所有控制及过账操作-->
		<exec condition="'@MEM:tblSalesReturnStock_IsStatart' == '0' &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">SalesReturnStock_Delete_One</sql>
		</exec>
	</sql>
	<sql type="condition">
	    <!-- 存在对应销售开票单,不允许修改或删除 -->
	    <condition>
	        <select>
				SELECT a.id as ExistID,b.BillNo AS ExistBill
				FROM tblSalesInfoDet a JOIN tblSalesInvoiceInfo b ON a.f_ref=b.id
				WHERE RefBillID = @ValueofDB:tblSalesReturnStock_id 
	        </select>
	    </condition>
		<exec condition="'@SqlReturn:ExistID'!='null'">	
		    <error>salesreturnstock.existsalesinvoicebill.error,@SqlReturn:ExistBill</error>   
		</exec>
	</sql>
</define>

<define name="SalesReturnStock_Delete_One">
		<!--回填被引用的订单的退货数量-->
<sql type="condition">
		<exec condition="true">
			<sql type="procedure">{call proc_ReturnBackOrder(@ValueofDB:id,delete,tblSalesReturnStock,retCode,retVal)}</sql>
		</exec>
</sql>	
<!--===判断如果此单据有如下关联，不允许删除====-->

<sql type="condition"><!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
	<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblSalesReturnStock_id and  workFlowNodeName='finish'</select></condition>
	<exec condition="'@SqlReturn:OrderNo'!='null'">	
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
	</exec>
</sql>
<sql type="condition"><!--存在不是自动产生的销售收款单，不允许此操作-->
	<condition><select>select a.BillNo as ReBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and a.AutoBillMarker=0 and b.RefbillID=@ValueofDB:tblSalesReturnStock_id</select></condition>
	<exec condition="'@SqlReturn:ReBillNo' != 'null'">	 					
		<error>DelBill.ReBillNo.error,@SqlReturn:ReBillNo</error>       
	</exec>
</sql>

<!--===========逻辑操作类======-->
<sql type="condition">
	<condition><select>select SaleOrderID,SalesOutStockID,AccountAmount,SaleOrderID,CurAccountAmount from tblSalesReturnStock where id=@ValueofDB:tblSalesReturnStock_id</select></condition>
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblSalesReturnStock_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReturnStockDet.GoodsCode,@StockCode=tblSalesReturnStockDet.StockCode,@BillType=tblSalesReturnStock,@InstoreQty=tblSalesReturnStockDet.Qty,@OutstoreQty=0,@from=tblSalesReturnStockDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<!--删除出入库明细-->
	<exec condition="true">
		<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblSalesReturnStock_id,tblSalesReturnStock,1,retCode,retVal)}</sql>		
	</exec> 
	<!--删除，反审核进行负库存判断，如果是修改操作，必须要修改后进行负库存判断-->
	<exec condition="'@Sess:BillOper' !='update'">	
		<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
	</exec>
	<!--更新销售出库单的退货金额及付款金额-->
	<exec condition="true">	
		<sql type="procedure">{call proc_SalesReturnRecAmort(@ValueofDB:id,delete,retCode,retVal)}</sql>
	</exec>

	<!-- 重算关联项目退货金额 ，项目收款
	<exec condition="'@SqlReturn:ItemName'!='null' &amp;&amp; '@SqlReturn:ItemName'!=''">
		<sql type="procedure">{call proc_Oaiteminfo_Amount_Account(@ValueofDB:tblSalesReturnStock_id,@SqlReturn:ItemName,3,retCode,retVal)}</sql>
	</exec> -->
	<!--删除本单据的多条往来记录（1应付 2应收 3预付 4预收-->
	<exec condition="true">
		<sql type="procedure">{call proc_iterateExeProc(select id as IniId@SPFieldLink:2 as ComType from tblCompanyIni where relationDocID='@ValueofDB:tblSalesReturnStock_id',proc_deleteComIni,@IniId@ParamLink:@ComType,retCode,retVal)}</sql>
	</exec>
  <exec condition=" '@MEM:autoGenerateAcc'=='true'"><!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblSalesReturnStock_id,retCode,retVal)}</sql>
	</exec>
	<!--本次结算金额大于0，删除收款单信息-->
	<exec condition="@SqlReturn:AccountAmount&gt;0">
		<sql>delete from tblSaleReceive where id in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReturnStock_id)</sql>
		<sql>delete from tblSalesRecAccount where f_ref in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReturnStock_id)</sql>
		<sql>delete from tblTrackBill where RelationID in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReturnStock_id)</sql>
		<sql>delete from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReturnStock_id</sql>
	</exec>
</sql>
</define>
<!--=====================================================以上代码：销售退货单================================================-->

	
<!--=====================================================销售开票==============================================================-->
<define name="tblSalesInvoiceInfo_add">
	<sql type="condition"><!-- 客户必须与被关联单据的客户相同--> 	
		<condition><select>select tbid.CompanyCode AS InvalidCompanyCode from tblSalesInfoDet tbid LEFT JOIN tblSalesOutStock tbis ON tbid.RefBillID=tbis.id LEFT JOIN tblSalesReturnStock tbos ON tbid.RefBillID=tbos.id left join tblSalesReplace tbr on tbid.RefBillID=tbr.id left join tblSalesOrder tbo on tbid.RefBillID=tbo.id where isnull(tbid.CompanyCode,0)!=isnull(tbis.CompanyCode,0) AND isnull(tbid.CompanyCode,0)!=isnull(tbos.CompanyCode,0) and isnull(tbid.CompanyCode,0)!=isnull(tbr.CompanyCode,0) and isnull(tbid.CompanyCode,0)!=isnull(tbo.CompanyCode,0) and tbid.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</select></condition>
		<exec condition="'@SqlReturn:InvalidCompanyCode' != 'null'">
			<error>tblSalesInvoiceInfo.companycodemustbesame.error</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--销售开票明细 关联单据号 与关联ID 不对应提示 -->
		<condition><select>select 'errorBillNo' as errorBillNo from tblSalesInfoDet where f_ref=@ValueofDB:tblSalesInvoiceInfo_id and RefBillNo NOT IN (SELECT billno FROM ViewSalesInvoiceInfoSelectBillNo WHERE id=tblSalesInfoDet.RefBillID) and len(RefBillNo) &gt;0</select></condition>
		<exec condition="'@SqlReturn:errorBillNo'=='errorBillNo'">
			<error>tblSalesInfoDet.RefBillNo.error</error>       
		</exec>
	</sql>
	<sql type="condition"><!-- 同一张采购入库单不可以按商品开票又按单开票-->
		<condition><select>select a.RefBillNo as RefBillNo,a.SourceID  from (select tblSalesInfoDet.RefBillNo as RefBillNo,SourceID,RefBillID from tblSalesInfoDet left join tblSalesInVoiceInfo on tblSalesInVoiceInfo.id = tblSalesInfoDet.f_ref where RefBillID in(select RefBillID from tblSalesInfoDet where f_ref=@ValueofDB:tblSalesInvoiceInfo_id) and len(tblSalesInfoDet.SourceID)&gt;0 and tblSalesInVoiceInfo.workFlowNodeName='finish') a join (select SourceID,RefBillID from tblSalesInfoDet left join tblSalesInVoiceInfo on tblSalesInVoiceInfo.id = tblSalesInfoDet.f_ref where RefBillID in(select RefBillID from tblSalesInfoDet where f_ref=@ValueofDB:tblSalesInvoiceInfo_id) and len(tblSalesInfoDet.SourceID)=0 and tblSalesInVoiceInfo.workFlowNodeName='finish') b on a.RefBillID=b.RefBillID</select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!= 'null'">
			<error>tblBuyInfoDet.SourceID12.error,@SqlReturn:RefBillNo</error>       
		</exec>
	</sql>
	<sql type="condition"><!-- 判断供应商、关联单据号是否匹配--> 	
		<condition><select>select tblSalesInfoDet.RefBillNo RefBillNo,tblCompany.ComFullName ComFullName,tblSalesInfoDet.CompanyCode as CompanyCode from tblSalesInfoDet left join ViewSalesInvoiceInfoSelectBillNo as tblSalesOutStock on tblSalesOutStock.id = tblSalesInfoDet.RefBillID left join tblCompany on tblCompany.classCode=tblSalesInfoDet.CompanyCode where tblSalesOutStock.CompanyCode &lt;&gt; tblSalesInfoDet.CompanyCode and  tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and len(tblSalesInfoDet.RefBillNo)&gt;0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null' &amp;&amp; '@SqlReturn:CompanyCode' != 'null'">
			<error>SalesInfo.BillNo.error,@SqlReturn:RefBillNo,@SqlReturn:ComFullName</error>       
		</exec>
	</sql>	
	<sql type="condition"><!-- 关联单据号、商品明细信息是否匹配--> 	
		<condition><select>select tblSalesInfoDet.RefBillNo RefBillNo,GoodsFullName,tblSalesInfoDet.GoodsCode as GoodsCode from tblSalesInfoDet left join viewSalesInvoiceSelectGoods on viewSalesInvoiceSelectGoods.DetId = tblSalesInfoDet.SourceID where viewSalesInvoiceSelectGoods.id &lt;&gt;tblSalesInfoDet.RefBillID and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and len(tblSalesInfoDet.RefBillNo)&gt;0</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null' &amp;&amp; '@SqlReturn:GoodsCode' != 'null'">
			<error>SalesInfo.GoodsCode.error,@SqlReturn:GoodsFullName,@SqlReturn:RefBillNo</error>       
		</exec>
	</sql>		
	<sql type="condition"> 	
		<condition><select>select ExeBalAmt as InvoiceAmount from tblSalesInfoDet where ExeBalAmt=0 and f_ref=@ValueofDB:tblSalesInVoiceInfo_id</select></condition>
		<exec condition="'@SqlReturn:InvoiceAmount'==0">
			<error>InvoiceAmount.negative.error</error>       
		</exec>
	</sql>
	<sql type="condition"><!--不启用‘启用商品开票’不能重复添加销售出库单--> 	
		<condition><select>select count(tblSalesInfoDet.RefBillNo) as RefBillNo,SourceID from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by tblSalesInfoDet.RefBillID,SourceID,tblSalesInfoDet.CompanyCode order by RefBillNo desc</select></condition>
		<exec condition="@SqlReturn:RefBillNo&gt;=2&amp;&amp;'@SqlReturn:SourceID'.length=='0'">
			<error>tblBuyInfoDet.SourceIDcum.error</error>       
		</exec>
	</sql>
	<sql type="condition"><!--主表总金额与明细表不相等-->
		<condition><select>select dbo.getDigits('tblSalesInfoDet','ExeBalAmt',sum(tblSalesInfoDet.ExeBalAmt)) as SumDetAmt,dbo.getDigits('tblSalesInfoDet','ExeBalAmt',(cast(@ValueofDB:tblSalesInvoiceInfo_InvoiceAmount as numeric(18,8)))) as sumMainAmt from tblSalesInfoDet where  tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</select></condition>
		<exec condition="'@SqlReturn:SumDetAmt'!='@SqlReturn:sumMainAmt'&amp;&amp;'@SqlReturn:SumDetAmt'!=''">			
			<error>common.InvoiceAmt.NotEqual.error,@SqlReturn:sumMainAmt,@SqlReturn:SumDetAmt</error>       
		</exec>
	</sql>
	<sql type="condition"><!--添加采购开票管理时不能重复添加采购入库单明细--> 	
		<condition><select>select b.SourceIDcum as SourceIDcum from (select Count(SourceID) as SourceIDcum from tblSalesInfoDet where f_ref=@ValueofDB:tblSalesInvoiceInfo_id and len(SourceID) &gt;0 group by tblSalesInfoDet.SourceID) b where b.SourceIDcum&gt;1</select></condition>
		<exec condition="@SqlReturn:SourceIDcum!=null">
			<error>tblBuyInfoDet.SourceIDcum.error</error>       
		</exec>
	</sql>
	<sql type="condition"><!-- 对于销售退货单, 开票金额必须小于0 --> 	
		<condition><select>select ExeBalAmt as InvoiceAmountForSaleReturn from tblSalesInfoDet where ExeBalAmt &gt; 0 and f_ref=@ValueofDB:tblSalesInvoiceInfo_id and RefBillID in (select id from tblSalesReturnStock) </select></condition>
		<exec condition="'@SqlReturn:InvoiceAmountForSaleReturn'!='null'">
			<error>tblSalesInvoiceInfo.tblSalesReturnStock.InvoiceAmountMoreThanZero</error>       
		</exec>
	</sql>
	<sql type="condition"><!-- 对于销售出库单, 开票金额必须大于0 --> 	
		<condition><select>select ExeBalAmt as InvoiceAmountForSaleOutStock from tblSalesInfoDet where ExeBalAmt &lt; 0 and f_ref=@ValueofDB:tblSalesInvoiceInfo_id and RefBillID in (select id from tblSalesOutStock) </select></condition>
		<exec condition="'@SqlReturn:InvoiceAmountForSaleOutStock'!='null'">
			<error>tblSalesInvoiceInfo.tblSalesOutStock.InvoiceAmountLessThanZero</error>       
		</exec>
	</sql>
	<sql type="condition"><!--本次开票金额必须与单据金额正负一致-->
		<condition><select>select RefBillNo from tblSalesInfoDet where f_ref=@ValueofDB:id and (NeedReturnAmt&gt;0 and ExeBalAmt&lt;0)or(NeedReturnAmt&lt;0 and ExeBalAmt&gt;0)</select></condition>
		<exec condition="'@SqlReturn:RefBillNo' != 'null'">			
			<error>@SqlReturn:RefBillNo 的本次开票金额必须与未开票金额正负一致</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--单据开票合计金额超过入库单调价后金额,提示是否继续-->
		<condition><select>select a.RefBillNo as RefBillNo,dbo.getDigits('tblSalesInfoDet','ExeBalAmt',ViewSalesInvoiceInfoSelectBillNo.AfterChangeAmt) as TotalTaxAmount from (select sum(ExeBalAmt) as sum,RefBillID,RefBillNo from tblSalesInfoDet left join tblSalesInVoiceInfo on tblSalesInVoiceInfo.id = tblSalesInfoDet.f_ref where RefBillID in(select RefBillID from tblSalesInfoDet where f_ref=@ValueofDB:tblSalesInvoiceInfo_id) and tblSalesInVoiceInfo.workFlowNodeName='finish' group by RefBillID,RefBillNo) a left join ViewSalesInvoiceInfoSelectBillNo on ViewSalesInvoiceInfoSelectBillNo.id=a.RefBillID where abs(a.sum) &gt; abs(ViewSalesInvoiceInfoSelectBillNo.AfterChangeAmt) </select></condition>
		<exec condition="'@SqlReturn:RefBillNo'!='null'">			
			<confirm yesDefine="tblSalesInvoiceInfo_Add_AccBefore" noDefine="">common.PreferBackAmount.confirm,@SqlReturn:RefBillNo,@SqlReturn:TotalTaxAmount</confirm>
		</exec>
	</sql>
	<sql type="condition"><!--不启用审核流也不需要发票操作-->
		<exec condition="'@MEM:tblSalesInvoiceInfo_IsStatart' == '0'">
			<sql type="define">tblSalesInvoiceInfo_add_One</sql>
		</exec>
	</sql>
</define>
<define name="tblSalesInvoiceInfo_Add_AccBefore">
	<sql type="condition">
		<exec condition="'@MEM:tblSalesInvoiceInfo_IsStatart' == '0'">
			<sql type="define">tblSalesInvoiceInfo_add_One</sql>
		</exec>
	</sql>
</define>

<define name="tblSalesInvoiceInfo_add_One">
	<sql type="condition">
		<!--按销售订单开票，更新销售订单主表的开票金额，未开票金额-->
		<exec condition="'@MEM:SalesInvoice'=='OrderBill'">
			<sql>update tblSalesOrder set tblSalesOrder.NoInvoiceAmount=tblSalesOrder.NoInvoiceAmount-tblSalesInfoDet.ExeBalAmt,tblSalesOrder.InvoiceAmount=tblSalesOrder.InvoiceAmount+tblSalesInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by RefBillNo) as tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesOrder.BillNo</sql>
			<!--回填销售出库单开票状态-->
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrder.NoInvoiceAmount&lt;=0 and tblSalesOrder.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrder.NoInvoiceAmount&gt;0 and tblSalesOrder.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOrder.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票,更新销售订单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:SalesInvoice'=='OrderBill'">
			<sql>update tblSalesOrderDet set tblSalesOrderDet.NoInvoiceAmount=tblSalesOrderDet.NoInvoiceAmount-isnull(tblSalesInfoDet.ExeBalAmt,0),tblSalesOrderDet.InvoiceAmount=tblSalesOrderDet.InvoiceAmount+tblSalesInfoDet.ExeBalAmt FROM tblSalesInfoDet WHERE tblSalesInfoDet.SourceID = tblSalesOrderDet.id AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
			<!--回填销售出库单明细开票状态-->
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrderDet.NoInvoiceAmount&lt;=0 and tblSalesOrderDet.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrderDet.NoInvoiceAmount&gt;0 and tblSalesOrderDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOrderDet.InvoiceAmount=0</sql>
		</exec>
		<!--按销售出库开票，更新销售出库单的开票金额，未开票金额-->
		<exec condition="'@MEM:SalesInvoice'=='OutBill'">
			<sql>update tblSalesOutStock set tblSalesOutStock.NoInvoiceAmount=tblSalesOutStock.NoInvoiceAmount-tblSalesInfoDet.ExeBalAmt,tblSalesOutStock.InvoiceAmount=tblSalesOutStock.InvoiceAmount+tblSalesInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by RefBillNo) as tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesOutStock.BillNo</sql>
			<!--回填销售出库单开票状态-->
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStock.NoInvoiceAmount&lt;=0 and tblSalesOutStock.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStock.NoInvoiceAmount&gt;0 and tblSalesOutStock.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOutStock.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票，更新销售出库单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:SalesInvoice'=='OutBill'">
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.NoInvoiceAmount=tblSalesOutStockDet.NoInvoiceAmount-isnull(tblSalesInfoDet.ExeBalAmt,0),tblSalesOutStockDet.InvoiceAmount=tblSalesOutStockDet.InvoiceAmount+tblSalesInfoDet.ExeBalAmt FROM tblSalesInfoDet WHERE tblSalesInfoDet.SourceID = tblSalesOutStockDet.id AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
			<!--回填销售出库单明细开票状态-->
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStockDet.NoInvoiceAmount&lt;=0 and tblSalesOutStockDet.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStockDet.NoInvoiceAmount&gt;0 and tblSalesOutStockDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOutStockDet.InvoiceAmount=0</sql>
		</exec>

		<exec condition="true">
			<!-- 修改销售退货单的开票金额，未开票金额-->
			<sql> update tblSalesReturnStock set tblSalesReturnStock.NoInvoiceAmount=tblSalesReturnStock.NoInvoiceAmount-(-a.ExeBalAmt),tblSalesReturnStock.InvoiceAmount=tblSalesReturnStock.InvoiceAmount+(-a.ExeBalAmt) from (select isnull(sum(tblSalesInfoDet.ExeBalAmt),0) as ExeBalAmt,tblSalesInfoDet.RefBillNo,tblSalesInfoDet.f_ref as f_ref from tblSalesInfoDet left join tblSalesReturnStock on tblSalesInfoDet.RefBillNo = tblSalesReturnStock.BillNo where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by tblSalesInfoDet.RefBillNo,f_ref) a WHERE a.RefBillNo = tblSalesReturnStock.BillNo AND a.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
	    <!-- 修改销售换货单的开票金额，为开票金额-->
	   	<sql>update tblSalesReplace set tblSalesReplace.NoInvoiceAmount=tblSalesReplace.NoInvoiceAmount-tblSalesInfoDet.ExeBalAmt,tblSalesReplace.InvoiceAmount=tblSalesReplace.InvoiceAmount+tblSalesInfoDet.ExeBalAmt from tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesReplace.BillNo AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
		</exec>
	</sql>
</define>
	
	<define name="tblSalesInvoiceInfo_delete">
		<sql type="condition">
			<exec condition="'@MEM:tblSalesInvoiceInfo_IsStatart' == '0'">
				<sql type="define">tblSalesInvoiceInfo_delete_One</sql>
			</exec>
		</sql>
	</define>
	
<define name="tblSalesInvoiceInfo_delete_One">
	<sql type="condition">
	<!--按销售订单开票，更新销售订单主表的开票金额，未开票金额-->
		<exec condition="'@MEM:SalesInvoice'=='OrderBill'">
			<sql>update tblSalesOrder set tblSalesOrder.NoInvoiceAmount=tblSalesOrder.NoInvoiceAmount+tblSalesInfoDet.ExeBalAmt,tblSalesOrder.InvoiceAmount=tblSalesOrder.InvoiceAmount-tblSalesInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by RefBillNo) as tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesOrder.BillNo</sql>
			<!--回填销售出库单开票状态-->
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrder.NoInvoiceAmount&lt;=0 and tblSalesOrder.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrder.NoInvoiceAmount&gt;0 and tblSalesOrder.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblSalesOrder set tblSalesOrder.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOrder.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票,更新销售订单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:SalesInvoice'=='OrderBill'">
			<sql>update tblSalesOrderDet set tblSalesOrderDet.NoInvoiceAmount=tblSalesOrderDet.NoInvoiceAmount+isnull(tblSalesInfoDet.ExeBalAmt,0),tblSalesOrderDet.InvoiceAmount=tblSalesOrderDet.InvoiceAmount-tblSalesInfoDet.ExeBalAmt FROM tblSalesInfoDet WHERE tblSalesInfoDet.SourceID = tblSalesOrderDet.id AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
			<!--回填销售出库单明细开票状态-->
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrderDet.NoInvoiceAmount&lt;=0 and tblSalesOrderDet.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOrderDet.NoInvoiceAmount&gt;0 and tblSalesOrderDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblSalesOrderDet set tblSalesOrderDet.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOrderDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOrderDet.InvoiceAmount=0</sql>
		</exec>
		<!--按销售出库开票，更新销售出库单的开票金额，未开票金额-->
		<exec condition="'@MEM:SalesInvoice'=='OutBill'">
			<sql>update tblSalesOutStock set tblSalesOutStock.NoInvoiceAmount=tblSalesOutStock.NoInvoiceAmount+tblSalesInfoDet.ExeBalAmt,tblSalesOutStock.InvoiceAmount=tblSalesOutStock.InvoiceAmount-tblSalesInfoDet.ExeBalAmt from (select RefBillNo,sum(ExeBalAmt) as ExeBalAmt from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by RefBillNo) as tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesOutStock.BillNo</sql>
			<!--回填销售出库单开票状态-->
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStock.NoInvoiceAmount&lt;=0 and tblSalesOutStock.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStock.NoInvoiceAmount&gt;0 and tblSalesOutStock.InvoiceAmount&lt;&gt;0</sql>
			<sql>update tblSalesOutStock set tblSalesOutStock.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOutStock.InvoiceAmount=0</sql>
		</exec>
		<!--启用按商品开票，更新销售出库单明细的开票金额，未开票金额-->
		<exec condition="@MEM:GoodsInvoice==true&amp;&amp;'@MEM:BuyInvoice'=='InBill'">
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.NoInvoiceAmount=tblSalesOutStockDet.NoInvoiceAmount+isnull(tblSalesInfoDet.ExeBalAmt,0),tblSalesOutStockDet.InvoiceAmount=tblSalesOutStockDet.InvoiceAmount-tblSalesInfoDet.ExeBalAmt FROM tblSalesInfoDet WHERE tblSalesInfoDet.SourceID = tblSalesOutStockDet.id AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
			<!--回填销售出库单明细开票状态-->
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='Finish' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStockDet.NoInvoiceAmount&lt;=0 and tblSalesOutStockDet.InvoiceAmount&gt;0</sql>
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='True' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id AND tblSalesOutStockDet.NoInvoiceAmount&gt;0 and tblSalesOutStockDet.InvoiceAmount&lt;&gt;0</sql>							
			<sql>update tblSalesOutStockDet set tblSalesOutStockDet.InvoiceStatus='False' from tblSalesInfoDet where tblSalesInfoDet.SourceID = tblSalesOutStockDet.id and tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id and tblSalesOutStockDet.InvoiceAmount=0</sql>
		</exec>

		<exec condition="true">
			<!-- 修改销售退货单的开票金额，未开票金额-->
			<sql> update tblSalesReturnStock set tblSalesReturnStock.NoInvoiceAmount=tblSalesReturnStock.NoInvoiceAmount+(-a.ExeBalAmt),tblSalesReturnStock.InvoiceAmount=tblSalesReturnStock.InvoiceAmount-(-a.ExeBalAmt) from (select isnull(sum(tblSalesInfoDet.ExeBalAmt),0) as ExeBalAmt,tblSalesInfoDet.RefBillNo,tblSalesInfoDet.f_ref as f_ref from tblSalesInfoDet left join tblSalesReturnStock on tblSalesInfoDet.RefBillNo = tblSalesReturnStock.BillNo where tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id group by tblSalesInfoDet.RefBillNo,f_ref) a WHERE a.RefBillNo = tblSalesReturnStock.BillNo AND a.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
	    <!-- 修改销售换货单的开票金额，为开票金额-->
	   	<sql>update tblSalesReplace set tblSalesReplace.NoInvoiceAmount=tblSalesReplace.NoInvoiceAmount+tblSalesInfoDet.ExeBalAmt,tblSalesReplace.InvoiceAmount=tblSalesReplace.InvoiceAmount-tblSalesInfoDet.ExeBalAmt from tblSalesInfoDet WHERE tblSalesInfoDet.RefBillNo = tblSalesReplace.BillNo AND tblSalesInfoDet.f_ref=@ValueofDB:tblSalesInvoiceInfo_id</sql>
		</exec>
	</sql>
</define>
<!-- =================================================== 销售单开票 ======================================================= -->
	
	<!--销售单运费管理添加前，如果关联单据已登记过，则出错误提示信息-->
	<define name="tblSalesFreight_Add_bef">
         <sql type="condition"> 	
		 <condition>
		 <select>select count(*) OpenCount from tblSalesFreight where RefBillID = @ValueofDB:RefBillID</select>
		 <select>select BillNo from tblSalesOutStock where id = @ValueofDB:RefBillID</select>
		 <select>select AccName from tblAccTypeInfo where accnumber=660105</select>
		 </condition>
		 <exec condition="@SqlReturn:OpenCount &gt; 0">
			  <error>ReturnBill.BillNo.error,@SqlReturn:BillNo</error>       
		</exec>
		<exec condition="@ValueofDB:Amount&lt;=0">
		<error>InputType.Bill.error,@SqlReturn:AccName</error>       
		</exec>
		<exec condition="'@ValueofDB:RefBillNo'.length==0">
		<error>tblPay.BillNO.error</error>       
		</exec>
		</sql>
	</define>
	
	<!--销售运输费用管理-->
	<define name="tblSalesFreight_Add">
	<!--根据情况调用另外一个define操作-->	
		<sql type="condition">
		<exec condition="true"><!--更新运费状态-->
		<sql>update tblSalesOutStock set IsFreight='True' where id=@ValueofDB:RefBillID</sql>
		</exec>
		<exec condition="'@ValueofDB:tblSalesFreight_Amount' !=0 &amp;&amp; '@ValueofDB:tblSalesFreight_SubCode'.length==0 &amp;&amp;@ValueofDB:freightType==2"> 
		<error>tblReturnPay.PayBankID.error</error>       
		</exec>
		<exec condition="'@ValueofDB:tblSalesFreight_Amount' !=0 &amp;&amp; '@ValueofDB:tblSalesFreight_SubCode'.length==0 &amp;&amp;@ValueofDB:freightType==3"> 
		<error>tblReturnPay.PayBankID.error</error>       
		</exec>
		<!--不启用审核流-->
		<exec condition="'@MEM:tblSalesFreight_IsStatart' == '0'">
		<sql type="define">tblSalesFreight_Add_One</sql>
		</exec>
		</sql>	
	</define>
	
	<define name="tblSalesFreight_Add_One">
		<!--拿到最大凭证号-->
		<sql type="condition">
		<condition>
		   <select>select isnull(max(OrderNo),0) maxOrderNo from tblAccMain  where SCompanyID=@Sess:SCompanyID and period=(select AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblSalesFreight_BillDate) and AccYear=Year(@ValueofDB:tblSalesFreight_BillDate) and SCompanyID=@Sess:SCompanyID)</select>
             <select>select AccYear,AccMonth,AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblSalesFreight_BillDate) and AccYear=Year(@ValueofDB:tblSalesFreight_BillDate) and SCompanyID=@Sess:SCompanyID</select>
			   <select>select ';'+CreateBy+';' as checkPersons from tblSalesFreight where id=@ValueofDB:tblSalesFreight_id</select>
		</condition>
<exec condition="true">
		<sql> update tblSalesFreight set Period=@SqlReturn:AccPeriod,PeriodYear=@SqlReturn:AccYear,PeriodMonth=@SqlReturn:AccMonth where id=@ValueofDB:tblSalesFreight_id</sql>	
		 </exec>	
		<exec condition="@ValueofDB:freightType==3">
		   <sql type="procedure"> <!--插入凭证记录（主表）代付-->
		      {call proc_insert(tblAccMain,id=@ValueofDB:tblSalesFreight_id@SPFieldLink:OrderNo=@SqlReturn:maxOrderNo+1@ParamNum:@SPFieldLink:CredTypeID=@MEM:AccNumberType@SPFieldLink:BillDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:CredYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:CredMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:Period=@SqlReturn:AccPeriod@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:RefBillNo=@ValueofDB:tblSalesFreight_RefBillNo@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesFreight_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:workFlowNodeName=notApprove@SPFieldLink:workFlowNode=0@SPFieldLink:checkPersons=@SqlReturn:checkPersons@SPFieldLink:AutoBillMarker=1,retCode,retVal)}
		   </sql>
		
		     <sql type="procedure">
                <!-- 插入凭证记录 借：应收帐款 科目代码：1122 -->
                {call proc_insert(tblAccDetail,id=1@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:CompanyCode=@ValueofDB:tblSalesFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:AccCode=1122@SPFieldLink:DebitAmount=@ValueofDB:tblSalesFreight_Amount@SPFieldLink:LendAmount=0@ParamNum:@SPFieldLink:PeriodYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesFreight_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=@ValueofDB:tblSalesFreight_CurAmount@SPFieldLink:LendCurrencyAmount=0@ParamNum:@SPFieldLink:f_ref=@ValueofDB:tblSalesFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
              <!--不含增值税情况下:    借: 应收帐款1122 贷: 现金或银行账户 SubCode 销售费用-运输费 660105 -->
              <sql type="procedure">
                <!-- 插入凭证第二条记录 科目代码：660105 -->
                {call proc_insert(tblAccDetail,id=2@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:CompanyCode=@ValueofDB:tblSalesFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:AccCode=@ValueofDB:tblSalesFreight_SubCode@SPFieldLink:DebitAmount=0@ParamNum:@SPFieldLink:LendAmount=@ValueofDB:tblSalesFreight_Amount@SPFieldLink:PeriodYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=0@ParamNum:@SPFieldLink:LendCurrencyAmount=@ValueofDB:tblSalesFreight_CurAmount@SPFieldLink:f_ref=@ValueofDB:tblSalesFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 往来单位明细 （1应付 2应收 3预付 4预收）-->
                {call proc_insertComIni(0@ValueofDB:tblSalesFreight_id,@ValueofDB:tblSalesFreight_CompanyCode,2,@ValueofDB:tblSalesFreight_BillDate,Period=@SqlReturn:AccPeriod@SPFieldLink:PeriodYear=@SqlReturn:AccYear@SPFieldLink:PeriodMonth=@SqlReturn:AccMonth@SPFieldLink:ReceiveTotalDebit=@ValueofDB:tblSalesFreight_Amount@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblSalesFreight_id@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesFreight_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:CurrencyTypeID=@ValueofDB:tblSalesFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesFreight_CurrencyRate@SPFieldLink:FcRecTotalDebit=@ValueofDB:tblSalesFreight_CurAmount@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:BillType=tblSalesFreight@SPFieldLink:BillNo=@ValueofDB:tblSalesFreight_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode,retCode,retVal)}
              </sql>
			  </exec>
			  
		<exec condition="@ValueofDB:freightType==2">
		   <sql type="procedure"> <!--插入凭证记录（主表）现付-->
		      {call proc_insert(tblAccMain,id=@ValueofDB:tblSalesFreight_id@SPFieldLink:OrderNo=@SqlReturn:maxOrderNo+1@ParamNum:@SPFieldLink:CredTypeID=@MEM:AccNumberType@SPFieldLink:BillDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:CredYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:CredMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:Period=@SqlReturn:AccPeriod@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:RefBillNo=@ValueofDB:tblSalesFreight_RefBillNo@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesFreight_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:workFlowNodeName=notApprove@SPFieldLink:workFlowNode=0@SPFieldLink:checkPersons=@SqlReturn:checkPersons@SPFieldLink:AutoBillMarker=1,retCode,retVal)}
		   </sql>
		
		     <sql type="procedure">
                <!-- 插入凭证记录 借：销售费用-运输费 科目代码：660105 -->
                {call proc_insert(tblAccDetail,id=1@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:CompanyCode=@ValueofDB:tblSalesFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:AccCode=660105@SPFieldLink:DebitAmount=@ValueofDB:tblSalesFreight_Amount@SPFieldLink:LendAmount=0@ParamNum:@SPFieldLink:PeriodYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=@ValueofDB:tblSalesFreight_CurAmount@SPFieldLink:LendCurrencyAmount=0@ParamNum:@SPFieldLink:f_ref=@ValueofDB:tblSalesFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
              <!--不含增值税情况下:    借:销售费用-运输费 660105 贷: 现金或银行账户 SubCode -->
              <sql type="procedure">
                <!-- 插入凭证第二条记录 科目代码：现金或银行账户 SubCode -->
                {call proc_insert(tblAccDetail,id=2@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblSalesFreight_id@SPFieldLink:RefBillType=tblSalesFreight@SPFieldLink:CompanyCode=@ValueofDB:tblSalesFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblSalesFreight_EmployeeID@SPFieldLink:AccCode=@ValueofDB:tblSalesFreight_SubCode@SPFieldLink:DebitAmount=0@ParamNum:@SPFieldLink:LendAmount=@ValueofDB:tblSalesFreight_Amount@SPFieldLink:PeriodYear=Year('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblSalesFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblSalesFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblSalesFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblSalesFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblSalesFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=0@ParamNum:@SPFieldLink:LendCurrencyAmount=@ValueofDB:tblSalesFreight_CurAmount@SPFieldLink:f_ref=@ValueofDB:tblSalesFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
			  </exec>
			  
			  <exec condition="@ValueofDB:freightType!=1"> 
<!--检查凭证的合理性 代付或现付-->
              <sql>update tblAccDetail set DebitCurrencyAmount=0,LendCurrencyAmount=0,CurrencyRate=0
where len(isnull(Currency,''))=0 and RefBillid=@ValueofDB:tblSalesFreight_id</sql>
			   <sql>delete from tblAccDetail where DebitAmount = 0 and LendAmount = 0  and RefBillid=@ValueofDB:tblSalesFreight_id</sql>	
			   <sql>delete from tblAccMain where id not in (select f_ref from tblAccDetail where RefBillID=@ValueofDB:tblSalesFreight_id)  and RefBillid=@ValueofDB:tblSalesFreight_id</sql>
			   </exec>	
<!--根据情况调用另外一个define操作-->	
<!--不启用审核流-->
<exec condition="'@MEM:tblAccMain_IsStatart' == '0'&amp;&amp;@ValueofDB:freightType!=1">
<sql type="define">tblSalesFreight_Add_Balance</sql>
</exec>
</sql>
</define>


<define name="tblSalesFreight_Add_Balance">
          <sql type="condition">
            <condition>
              <select>select AccYear,AccMonth,AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblSalesFreight_BillDate) and AccYear=Year(@ValueofDB:tblSalesFreight_BillDate) and SCompanyID=@Sess:SCompanyID</select>
            </condition>
            <!--更新相关的科目余额表信息:科目平衡表、往来科目余额表、部门科目余额表、员工科目余额表-->
			  <exec condition="@ValueofDB:freightType==2"> 
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  科目代码：1122-->
                {call proc_updateAccBalance(660105,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,@ValueofDB:tblSalesFreight_Amount,0,@ValueofDB:tblSalesFreight_CurAmount,0,@ValueofDB:tblSalesFreight_SCompanyID,@ValueofDB:tblSalesFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改库存商品科目余额  销售费用-运输费 660105 -->
                {call proc_updateAccBalance(@ValueofDB:tblSalesFreight_SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,@ValueofDB:tblSalesFreight_Amount,0,@ValueofDB:tblSalesFreight_CurAmount,@ValueofDB:tblSalesFreight_SCompanyID,@ValueofDB:tblSalesFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
            <exec condition="@ValueofDB:freightType==3">
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  科目代码：1122-->
                {call proc_updateAccBalance(1122,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,@ValueofDB:tblSalesFreight_Amount,0,@ValueofDB:tblSalesFreight_CurAmount,0,@ValueofDB:tblSalesFreight_SCompanyID,@ValueofDB:tblSalesFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改库存商品科目余额  现金或银行账户 -->
                {call proc_updateAccBalance(@ValueofDB:tblSalesFreight_SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,@ValueofDB:tblSalesFreight_Amount,0,@ValueofDB:tblSalesFreight_CurAmount,@ValueofDB:tblSalesFreight_SCompanyID,@ValueofDB:tblSalesFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
		</sql>
</define>

	<!--销售运输费用管理删除-->
	<define name="tblSalesFreight_Delete">
	<!--根据情况调用另外一个define操作-->	
		<sql type="condition">
		<condition>
		<select>select CredTypeID,OrderNo,workFlowNodeName from tblAccMain where RefBillID=@ValueofDB:tblSalesFreight_id</select>	
		<select>select RefBillID,freightType from tblSalesFreight where id=@ValueofDB:tblSalesFreight_id</select>
		</condition>
		<exec condition="true"><!--更新运费状态-->
		<sql>update tblSalesOutStock set IsFreight='False' where id=@SqlReturn:RefBillID</sql>
		</exec> 
		<!--如果存在生成的凭证已被审核，需将对应凭证反审核后才可以进行本单据的反审核操作-->
        <exec condition="'@MEM:tblAccMain_IsStatart' == '1' &amp;&amp; 
'@SqlReturn:workFlowNodeName' != 'notApprove' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'null' &amp;&amp; '@SqlReturn:workFlowNodeName'.length != 0">	 					
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
		<!--不启用审核流-->
		<exec condition="'@MEM:tblSalesFreight_IsStatart' == '0'">
		<sql type="define">tblSalesFreight_Delete_One</sql>
		</exec>
		</sql>	
	</define>


<define name="tblSalesFreight_Delete_One">
	<sql type="condition">
	<condition>
 	<select>select CredTypeID,OrderNo,workFlowNodeName from tblAccMain where RefBillID=@ValueofDB:tblSalesFreight_id</select>
	<select>select RefBillID,freightType from tblSalesFreight where id=@ValueofDB:tblSalesFreight_id</select>
		  </condition>
		   <!--如果存在生成的凭证已被审核，需将对应凭证反审核后才可以进行本单据的反审核操作-->
        <exec condition="'@MEM:tblAccMain_IsStatart' == '1' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'notApprove' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'null' &amp;&amp; '@SqlReturn:workFlowNodeName'.length != 0">	 					
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
	  <exec condition="@SqlReturn:freightType!=1 || @SqlReturn:freightType!=4">
	  <sql>delete from tblAccDetail where RefBillID=@ValueofDB:tblSalesFreight_id</sql>
	  <sql>delete from tblAccMain where RefBillID=@ValueofDB:tblSalesFreight_id</sql>
	  </exec>
	  <exec condition="@SqlReturn:freightType==3">
	  <sql type="procedure"><!-- 删除往来明细:修改类型（1应付 2应收 3预付 4预收） -->
		{call proc_deleteComIni (0@ValueofDB:tblSalesFreight_id,2,retCode,retVal)}
		</sql>
	  </exec>
<!--不启用审核流-->
	<exec condition="'@MEM:tblAccMain_IsStatart' == '0'">
	<sql type="define">tblSalesFreight_Delete_Balance</sql>
	</exec>
</sql>		
</define>


<define name="tblSalesFreight_Delete_Balance">
         <sql type="condition">
            <condition>
		  <select>select RefBillID,Amount,SCompanyID,SubCode,CurrencyTypeID,freightType,PeriodYear as AccYear,PeriodMonth as AccMonth,Period as AccPeriod from tblSalesFreight where id=@ValueofDB:tblSalesFreight_id</select>
            </condition>
            <!--更新相关的科目余额表信息:科目平衡表、往来科目余额表、部门科目余额表、员工科目余额表-->
            <exec condition="@SqlReturn:freightType==3">
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  科目代码：1122-->
                {call proc_updateAccBalance(1122,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,-@SqlReturn:Amount,0,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改科目余额 现金或银行账户 -->
                {call proc_updateAccBalance(@SqlReturn:SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,-@SqlReturn:Amount,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
			            <exec condition="@SqlReturn:freightType==2">
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  销售费用-运输费 660105-->
                {call proc_updateAccBalance(660105,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,-@SqlReturn:Amount,0,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改科目余额  现金或银行账户 -->
                {call proc_updateAccBalance(@SqlReturn:SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,-@SqlReturn:Amount,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
		</sql>
</define>


<!--销售单运费管理添加前，如果关联单据已登记过，则出错误提示信息-->
	<define name="tblInvoiceFreight_Add_bef">
         <sql type="condition"> 	
		 <condition>
		 <select>select AccName from tblAccTypeInfo where accnumber=660105</select>
		 </condition>
		<exec condition="@ValueofDB:Amount&lt;=0">
		<error>InputType.Bill.error,@SqlReturn:AccName</error>       
		</exec>
		<!--<exec condition="'@ValueofDB:RefBillNo'.length==0">
		<error>tblPay.BillNO.error</error>       
		</exec>-->
		</sql>
	</define>
	
	<!--销售运输费用管理-->
	<define name="tblInvoiceFreight_Add">
	<!--根据情况调用另外一个define操作-->	
		<sql type="condition">
		<!--<exec condition="true">更新运费状态
		<sql>update tblSalesInvoiceInfo set IsInvoice=1 where id=@ValueofDB:RefBillID</sql>
		</exec>-->
		<exec condition="'@ValueofDB:tblInvoiceFreight_Amount' !=0 &amp;&amp; '@ValueofDB:tblInvoiceFreight_SubCode'.length==0 &amp;&amp;@ValueofDB:tblInvoiceFreight_FreightPayType ==1"> 
		<error>tblReturnPay.PayBankID.error</error>       
		</exec>
		<!--不启用审核流-->
		<exec condition="'@MEM:tblInvoiceFreight_IsStatart' == '0'">
		<sql type="define">tblInvoiceFreight_Add_One</sql>
		</exec>
		</sql>	
	</define>
	
	<define name="tblInvoiceFreight_Add_One">
		<!--拿到最大凭证号-->
		<sql type="condition">
		<condition>
		   <select>select isnull(max(OrderNo),0) maxOrderNo from tblAccMain  where SCompanyID=@Sess:SCompanyID and period=(select AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblInvoiceFreight_BillDate) and AccYear=Year(@ValueofDB:tblInvoiceFreight_BillDate) and SCompanyID=@Sess:SCompanyID)</select>
             <select>select AccYear,AccMonth,AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblInvoiceFreight_BillDate) and AccYear=Year(@ValueofDB:tblInvoiceFreight_BillDate) and SCompanyID=@Sess:SCompanyID</select>
			 <select>select ';'+CreateBy+';' as checkPersons from tblInvoiceFreight where id=@ValueofDB:tblInvoiceFreight_id</select>
		</condition>
	<exec condition="true">
	<sql> update tblInvoiceFreight set Period=@SqlReturn:AccPeriod,PeriodYear=@SqlReturn:AccYear,PeriodMonth=@SqlReturn:AccMonth where id=@ValueofDB:tblInvoiceFreight_id</sql>	
		 </exec>	
		<exec condition="@ValueofDB:tblInvoiceFreight_FreightPayType ==1">
		   <sql type="procedure"> <!--插入凭证记录（主表）现付-->
		      {call proc_insert(tblAccMain,id=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:OrderNo=@SqlReturn:maxOrderNo+1@ParamNum:@SPFieldLink:CredTypeID=@MEM:AccNumberType@SPFieldLink:BillDate=@ValueofDB:tblInvoiceFreight_BillDate@SPFieldLink:RefBillID=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:CredYear=Year('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:CredMonth=Month('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:Period=@SqlReturn:AccPeriod@SPFieldLink:RefBillType=tblInvoiceFreight@SPFieldLink:RefBillNo=@ValueofDB:tblInvoiceFreight_BillNo@SPFieldLink:DepartmentCode=@ValueofDB:tblInvoiceFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblInvoiceFreight_EmployeeID@SPFieldLink:createBy=@ValueofDB:tblInvoiceFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblInvoiceFreight_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblInvoiceFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblInvoiceFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblInvoiceFreight_SCompanyID@SPFieldLink:workFlowNodeName=notApprove@SPFieldLink:workFlowNode=0@SPFieldLink:checkPersons=@SqlReturn:checkPersons@SPFieldLink:AutoBillMarker=1,retCode,retVal)}
		   </sql>
		
		     <sql type="procedure">
                <!-- 插入凭证记录 借：销售费用-运输费 科目代码：660105 -->
                {call proc_insert(tblAccDetail,id=1@ValueofDB:tblInvoiceFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:RefBillType=tblInvoiceFreight@SPFieldLink:CompanyCode=@ValueofDB:tblInvoiceFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblInvoiceFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblInvoiceFreight_EmployeeID@SPFieldLink:AccCode=660105@SPFieldLink:DebitAmount=@ValueofDB:tblInvoiceFreight_Amount@SPFieldLink:LendAmount=0@ParamNum:@SPFieldLink:PeriodYear=Year('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblInvoiceFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblInvoiceFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblInvoiceFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblInvoiceFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblInvoiceFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblInvoiceFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblInvoiceFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=@ValueofDB:tblInvoiceFreight_CurAmount@SPFieldLink:LendCurrencyAmount=0@ParamNum:@SPFieldLink:f_ref=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
              <!--不含增值税情况下:    借:销售费用-运输费 660105 贷: 现金或银行账户 SubCode -->
              <sql type="procedure">
                <!-- 插入凭证第二条记录 科目代码：现金或银行账户 SubCode -->
                {call proc_insert(tblAccDetail,id=2@ValueofDB:tblInvoiceFreight_id@SPFieldLink:RefBillID=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:RefBillType=tblInvoiceFreight@SPFieldLink:CompanyCode=@ValueofDB:tblInvoiceFreight_CompanyCode@SPFieldLink:DepartmentCode=@ValueofDB:tblInvoiceFreight_DepartmentCode@SPFieldLink:EmployeeID=@ValueofDB:tblInvoiceFreight_EmployeeID@SPFieldLink:AccCode=@ValueofDB:tblInvoiceFreight_SubCode@SPFieldLink:DebitAmount=0@ParamNum:@SPFieldLink:LendAmount=@ValueofDB:tblInvoiceFreight_Amount@SPFieldLink:PeriodYear=Year('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:PeriodMonth=Month('@ValueofDB:tblInvoiceFreight_BillDate')@ParamNum:@SPFieldLink:AccDate=@ValueofDB:tblInvoiceFreight_BillDate@SPFieldLink:createBy=@ValueofDB:tblInvoiceFreight_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesOutStock_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblInvoiceFreight_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:ttblInvoiceFreight_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblInvoiceFreight_SCompanyID@SPFieldLink:Currency=@ValueofDB:tblInvoiceFreight_CurrencyTypeID@SPFieldLink:CurrencyRate=@ValueofDB:tblInvoiceFreight_CurrencyRate@SPFieldLink:DebitCurrencyAmount=0@ParamNum:@SPFieldLink:LendCurrencyAmount=@ValueofDB:tblInvoiceFreight_CurAmount@SPFieldLink:f_ref=@ValueofDB:tblInvoiceFreight_id@SPFieldLink:ProjectCode=@ValueofDB:ProjectCode,retCode,retVal)}
              </sql>
			  </exec>
			  
			  <exec condition="true"> 
<!--检查凭证的合理性 代付或现付-->
              <sql>update tblAccDetail set DebitCurrencyAmount=0,LendCurrencyAmount=0,CurrencyRate=0
where len(isnull(Currency,''))=0 and RefBillid=@ValueofDB:tblInvoiceFreight_id</sql>
			   <sql>delete from tblAccDetail where DebitAmount = 0 and LendAmount = 0   and RefBillid=@ValueofDB:tblInvoiceFreight_id</sql>	
			   <sql>delete from tblAccMain where id not in (select f_ref from tblAccDetail where RefBillID=@ValueofDB:tblInvoiceFreight_id)   and RefBillid=@ValueofDB:tblInvoiceFreight_id</sql>
			   </exec>	
<!--根据情况调用另外一个define操作-->	
<!--不启用审核流-->
<exec condition="'@MEM:tblAccMain_IsStatart' == '0'">
<sql type="define">tblInvoiceFreight_Add_Balance</sql>
</exec>
</sql>
</define>


<define name="tblInvoiceFreight_Add_Balance">
          <sql type="condition">
            <condition>
              <select>
                select AccYear,AccMonth,AccPeriod from tblAccPeriod where AccMonth = Month(@ValueofDB:tblSalesOutStock_BillDate) and AccYear=Year(@ValueofDB:tblSalesOutStock_BillDate) and SCompanyID=@Sess:SCompanyID
              </select>
            </condition>
            <!--更新相关的科目余额表信息:科目平衡表、往来科目余额表、部门科目余额表、员工科目余额表-->
		<exec condition="@ValueofDB:tblInvoiceFreight_FreightPayType ==1">
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  科目代码：1122-->
                {call proc_updateAccBalance(660105,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,@ValueofDB:tblInvoiceFreight_Amount,0,0,0,@ValueofDB:tblInvoiceFreight_SCompanyID,@ValueofDB:tblInvoiceFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改库存商品科目余额  销售费用-运输费 660105 -->
                {call proc_updateAccBalance(@ValueofDB:tblInvoiceFreight_SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,@ValueofDB:tblInvoiceFreight_Amount,0,0,@ValueofDB:tblInvoiceFreight_SCompanyID,@ValueofDB:tblInvoiceFreight_CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
		</sql>
</define>

	<!--销售运输费用管理删除-->
	<define name="tblInvoiceFreight_Delete">
	<!--根据情况调用另外一个define操作-->	
		<sql type="condition">
		<condition>
		<select>select CredTypeID,OrderNo,workFlowNodeName from tblAccMain where RefBillID=@ValueofDB:tblInvoiceFreight_id</select>
		<select>select RefBillID from tblInvoiceFreight where id=@ValueofDB:tblInvoiceFreight_id</select>
		</condition>
		<!--<exec condition="true">更新运费状态
		<sql>update tblSalesInvoiceInfo set IsInvoice=0 where id=@SqlReturn:RefBillID</sql>
		</exec> -->
		<!--如果存在生成的凭证已被审核，需将对应凭证反审核后才可以进行本单据的反审核操作-->
        <exec condition="'@MEM:tblAccMain_IsStatart' == '1' &amp;&amp; 
'@SqlReturn:workFlowNodeName' != 'notApprove' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'null' &amp;&amp; '@SqlReturn:workFlowNodeName'.length != 0">	 					
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
		<!--不启用审核流-->
		<exec condition="'@MEM:tblInvoiceFreight_IsStatart' == '0'">
		<sql type="define">tblInvoiceFreight_Delete_One</sql>
		</exec>
		</sql>	
	</define>


<define name="tblInvoiceFreight_Delete_One">
	<sql type="condition">
	<condition>
 	<select>select CredTypeID,OrderNo,workFlowNodeName from tblAccMain where RefBillID=@ValueofDB:tblInvoiceFreight_id</select>
	<select>select RefBillID,FreightPayType from tblInvoiceFreight where id=@ValueofDB:tblInvoiceFreight_id</select>
		  </condition>
		   <!--如果存在生成的凭证已被审核，需将对应凭证反审核后才可以进行本单据的反审核操作-->
        <exec condition="'@MEM:tblAccMain_IsStatart' == '1' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'notApprove' &amp;&amp; '@SqlReturn:workFlowNodeName' != 'null' &amp;&amp; '@SqlReturn:workFlowNodeName'.length != 0">	 					
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
		</exec>
		<exec condition="@SqlReturn:FreightPayType ==1">
		<!--<exec condition="true">-->
	  <sql>delete from tblAccDetail where RefBillID=@ValueofDB:tblInvoiceFreight_id</sql>
	  <sql>delete from tblAccMain where RefBillID=@ValueofDB:tblInvoiceFreight_id</sql>
	  </exec>
<!--不启用审核流-->
	<exec condition="'@MEM:tblAccMain_IsStatart' == '0'">
	<sql type="define">tblInvoiceFreight_Delete_Balance</sql>
	</exec>
</sql>		
</define>


<define name="tblInvoiceFreight_Delete_Balance">
         <sql type="condition">
            <condition>
			  <select>select RefBillID,SCompanyID,SubCode,CurrencyTypeID,Amount,PeriodYear as AccYear,PeriodMonth as AccMonth,Period as AccPeriod,FreightPayType from tblInvoiceFreight where id=@ValueofDB:tblInvoiceFreight_id</select>
            </condition>
            <!--更新相关的科目余额表信息:科目平衡表、往来科目余额表、部门科目余额表、员工科目余额表-->
            
		<exec condition="@SqlReturn:FreightPayType ==1">
				<!--<exec condition="true">-->
              <sql type="procedure">
                <!-- 修改科目余额 应收帐款  销售费用-运输费 660105-->
                {call proc_updateAccBalance(660105,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,-@SqlReturn:Amount,0,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
              <sql type="procedure">
                <!-- 修改科目余额  现金或银行账户 -->
                {call proc_updateAccBalance(@SqlReturn:SubCode,@SqlReturn:AccPeriod,@SqlReturn:AccYear,@SqlReturn:AccMonth,0,-@SqlReturn:Amount,0,0,@SqlReturn:SCompanyID,@SqlReturn:CurrencyTypeID,retCode,retVal)}
              </sql>
            </exec>
		</sql>
</define>


<!--========================================================销售换货单=================================================================-->
<define name="tblSalesReplaceDetail_GoodsSeqSet">
	<sql type="condition">
		<condition><select>select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblSalesReplaceDetail_GoodsCode</select></condition>
		<exec condition="@SqlReturn:isUsed == 0">
			<error>goodsseq.set.res</error>       
		</exec>
	</sql>
</define>

<define name="tblSalesReplaceDet_GoodsSeqSet">
	<sql type="condition">
		<condition><select>select seqIsUsed as isUsed from tblGoods where classCode=@ValueofDB:tblSalesReplaceDet_GoodsCode</select></condition>
		<exec condition="@SqlReturn:isUsed == 0">
			<error>goodsseq.set.res</error>       
		</exec>
	</sql>
</define>	
	
<define name="tblSalesReplace_Add">	
	<sql type="condition"><!--如果引用销售出库单，做如下控制-->
		<exec condition="'@ValueofDB:tblSalesReplace_SalesOutStockID'.length&gt;0">
			<sql type="define">SalesReplace_QuoteSalesOut_validate</sql>
		</exec>
	</sql>
	<sql type="condition">
		<!--用户输入了收款金额，没有选择收款账户，给出错误提示-->
		<exec condition="@ValueofDB:tblSalesReplace_AccountAmount != 0 &amp;&amp; '@ValueofDB:tblSalesReplace_Account'.length==0"> 
			<error>sales.ReceiveAccCode.error</error>       
		</exec>
		<!--用户选择了收款账户，没有输入收款金额，给出错误提示-->
		<exec condition="@ValueofDB:tblSalesReplace_AccountAmount==0 &amp;&amp; '@ValueofDB:tblSalesReplace_Account'.length&gt;0"> 
			<error>buyOutStock.Receiveamount.error</error>       
		</exec>
		<!--差异金额大于等于0，收款金额小于0时给出错误提示-->
		<exec condition="@ValueofDB:tblSalesReplace_TotalTaxAmount&gt;=0 &amp;&amp; @ValueofDB:tblSalesReplace_AccountAmount&lt;0">
			<error>negtive.AlrAccAmt.error</error>       
		</exec>
		<!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->
		<exec condition="('@ValueofDB:tblSalesReplace_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblSalesReplace_Tax!=0)||@ValueofDB:tblSalesReplace_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>        
		</exec>
	</sql>	
	<sql type="condition"><!--退货明细，启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblSalesReplaceDet a left join tblgoods c on c.classCode=a.GoodsCode where c.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblSalesReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>       
	  </exec>
	</sql>
	<sql type="condition"><!--出库明细，启用了序列号属性，并且所选择的商品启用了序列号但没有录入序列号给出错误提示--> 
		<condition><select>select GoodsFullName as GoodsSeq from tblSalesReplaceDetail a left join tblgoods c on c.classCode=a.GoodsCode where c.seqIsUsed=0 and len(isnull(a.seq,''))=0 and (select isUsed from tblGoodsAttribute where propName='Seq')=1 and a.f_ref=@ValueofDB:tblSalesReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsSeq' != 'null'">	
			<error>enter.seq.error,@SqlReturn:GoodsSeq</error>       
	  </exec>
	</sql>
	<sql type="condition"><!--退货数量小于等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblSalesReplaceDet a,tblGoods b where isnull(a.Qty,0)&lt;=0 and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>
	<sql type="condition"><!--出库数量小于等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsQ from tblSalesReplaceDetail a,tblGoods b where isnull(a.Qty,0)&lt;=0 and b.classCode=a.GoodsCode and a.f_ref=@ValueofDB:tblSalesReplace_id</select></condition>
		<exec condition="'@SqlReturn:GoodsQ' != 'null'">			
			<error>common.qty.negative.error,@SqlReturn:GoodsQ</error>       
		</exec>
	</sql>
	<sql type="condition"><!--退货单，非赠品，样品单价小于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblSalesReplaceDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReplace_id and (isnull(a.Price,0)&lt;0) and b.classCode=a.GoodsCode and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>		
	<sql type="condition"><!--出库单，非赠品，样品单价小于等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsP,b.garniture from tblSalesReplaceDetail a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReplace_id and (isnull(a.Price,0)&lt;0 or (b.garniture='2' and isnull(a.Price,0)=0)) and b.classCode=a.GoodsCode and a.PresentSampleType not in ('1','2')</select></condition>
		<exec condition="'@SqlReturn:garniture'=='2' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePrice.error,@SqlReturn:GoodsP</error>                  
		</exec>	
		<exec condition="'@SqlReturn:garniture'=='1' &amp;&amp; '@SqlReturn:GoodsP' != 'null'">						
			<error>common.noSamplePriceGarniture.error,@SqlReturn:GoodsP</error>                  
		</exec>
	</sql>
	<sql type="condition"><!--退货单，赠品，样品单价不等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblSalesReplaceDet a,tblGoods b where  a.f_ref=@ValueofDB:tblSalesReplace_id and isnull(a.Price,0)!=0 and b.classCode=a.GoodsCode and a.PresentSampleType in ('1','2')</select>
		</condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>       
		</exec>
	</sql>
	<sql type="condition"><!--出库单，赠品，样品单价不等于0的商品判断-->
		<condition><select>select b.GoodsFullName as GoodsSample from tblSalesReplaceDetail a,tblGoods b where  a.f_ref=@ValueofDB:tblSalesReplace_id and isnull(a.Price,0)!=0 and b.classCode=a.GoodsCode and a.PresentSampleType in ('1','2')</select>
		</condition>
		<exec condition="'@SqlReturn:GoodsSample' != 'null'">			
			<error>common.samplePrice.error,@SqlReturn:GoodsSample</error>       
		</exec>
	</sql>
	<sql type="condition"><!--启用了价格控制，判断非赠品，样品商品单价是否在价格控制范围内-->
		<exec condition="@MEM:PriceControl==true">			
			<sql type="define">tblSalesReplace_Add_PriceControl_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--折扣不是0到100之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesReplaceDet a where a.f_ref=@ValueofDB:tblSalesReplace_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--折扣不是0到100之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesReplaceDetail a where a.f_ref=@ValueofDB:tblSalesReplace_id and (Discount&lt;=0 or Discount&gt;100)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>
	
<!--================================================外币控制======================================================-->
	<sql type="condition">
		<condition><select>select Currency as CURD from tblAccTypeInfo where AccNumber=@ValueofDB:tblSalesReplace_Account and SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID</select></condition>
		<!--币种不为空，收款帐户不为空时，选择的收款帐户核算的币种跟所选的币种不一致时提示-->
		<exec condition="'@ValueofDB:tblSalesReplace_Currency'.length != 0 &amp;&amp; '@ValueofDB:tblSalesReplace_Account'.length != 0 &amp;&amp; !( '@ValueofDB:Currency' == '@SqlReturn:CURD' || ('@SqlReturn:CURD' =='' &amp;&amp; '@SqlReturn:IsForCur'=='1'  )  ) ">
			 <error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>
		<!--币种为空，收款帐户不为空时，选择的收款帐户存在核算外币时提示-->
		<exec condition="'@ValueofDB:tblSalesReplace_Currency'.length == 0&amp;&amp; '@ValueofDB:tblSalesReplace_Account'.length !=0 &amp;&amp; ( '@SqlReturn:CURD'.length != 0 &amp;&amp; '@SqlReturn:CURD' !=' '  &amp;&amp; '@SqlReturn:CURD' != 'null' &amp;&amp; '@SqlReturn:CURD' != 'NULL')">		
			 <error>tblAccTypeInfo.ReceSelectCurType.error</error>       
		</exec>
		<!--如果是本位币帐户，不用录入汇率-->	
		<exec condition=" ('@ValueofDB:tblSalesReplace_Currency'.length == 0 &amp;&amp;@ValueofDB:tblSalesReplace_CurrencyRate&gt;0&amp;&amp;@ValueofDB:tblSalesReplace_CurrencyRate!=1)">		
			 <error>CurrencyRate.putErrors.error</error>       
		</exec>
	</sql>
<!--================================================以上外币控制======================================================-->	
	
	<sql type="condition"><!--启用了系统配置 信用额度控制，判断是否大于可用额度-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' == '1'&amp;&amp;@MEM:CustomerCreditLimit==true">
			<sql type="define">SalesReplace_Add_CustomerCreditLimit_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了控制低于最低限售，判断非赠品，样品商品折后单价是否低于最低限售-->
		<exec condition="@MEM:UnderLimitprice==true">			
			<sql type="define">tblSalesReplace_UnderLimitPrice_Validate</sql>
		</exec>
	</sql>
	<sql type="condition"><!--启用了控制低于成本价，判断非赠品，样品商品折后单价是否低于成本-->
		<exec condition="@MEM:UnderCostprice==true">			
			<sql type="define">tblSalesReplace_Add_UnderCostPrice_Validate</sql>
		</exec>
	</sql>		
	<sql type="condition"><!--启用了控制对超结算账期未收款客户销售-->
		<exec condition="@MEM:WithOutSettleCys==true">		
			<sql type="define">tblSalesReplace_Add_WithOutSettleCys_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果没有执行到最低限售，成本价销售的确定，取消，执行下面的define-->
		<exec condition="true">			
			<sql type="define">tblSalesReplace_Add_AccBefore</sql>
		</exec>
	</sql>
</define>
<define name="tblSalesReplace_Add_AccBefore1">
	<sql type="condition"><!--启用了控制低于成本价，判断非赠品，样品商品折后单价是否低于成本-->
		<exec condition="@MEM:UnderCostprice==true">			
			<sql type="define">tblSalesReplace_Add_UnderCostPrice_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--启用了控制对超结算账期未收款客户销售-->
		<exec condition="@MEM:WithOutSettleCys==true">		
			<sql type="define">tblSalesReplace_Add_WithOutSettleCys_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果没有执行到最低限售，成本价销售的确定，取消，执行下面的define-->
		<exec condition="true">			
			<sql type="define">tblSalesReplace_Add_AccBefore</sql>
		</exec>
	</sql>
</define>

<define name="tblSalesReplace_Add_AccBefore2">
	<sql type="condition"><!--启用了控制对超结算账期未收款客户销售-->
		<exec condition="@MEM:WithOutSettleCys==true">		
			<sql type="define">tblSalesReplace_Add_WithOutSettleCys_Validate</sql>
		</exec>
	</sql>	
	<sql type="condition"><!--如果没有执行到最低限售，成本价销售的确定，取消，执行下面的define-->
		<exec condition="true">			
			<sql type="define">tblSalesReplace_Add_AccBefore</sql>
		</exec>
	</sql>
</define>
<!--===========启用了“控制低于成本价销售出库”，根据逻辑给出相应提示=========-->
<define name="tblSalesReplace_Add_UnderCostPrice_Validate">
	<sql type="condition">
		<condition>
			<!--查询此用户是否有权限低于成本价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='allowLittleCostOut' and hasRight=1</select>
			<!--查询是否有折后单价低于其成本价限售的商品-->
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(c.lastPrice as numeric(18,4)) as lastPrice from tblSalesReplaceDetail a,tblGoods b,tblStocks c where a.f_ref=@ValueofDB:tblSalesReplace_id and a.goodsCode=b.classCode and a.goodsCode=c.goodsCode and (case when len(a.stockCode)=0 then @ValueofDB:tblSalesReplace_StockCode else a.stockCode end)=c.stockCode and a.BatchNo=c.BatchNo and a.yearNO=c.yearNO and a.ProDate=c.ProDate and a.Availably=c.Availably and a.Inch=c.Inch and a.Hue=c.Hue and a.PresentSampleType not in ('1','2') and a.DisPrice&lt;c.lastPrice</select>
			<!--查询此用户是否有查看成本价的权限-->
			<select>select count(0) as Cost from tblUserSunCompany a,tblRole b where a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%' and b.hiddenField like '%'+'1'+',%'</select>
		</condition>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，也不是系统管理员给出错误提示，用户没有查看成本价权限-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost!=0">
			<error>商品 @SqlReturn:GoodsFullName 的售价 @SqlReturn:DisPrice 低于其成本价，不允许保存！</error>       
		</exec>
		<!--查询出有低于成本价的商品，并且此用户没有权限低于成本价销售，也不是系统管理员给出错误提示，用户有查看成本价权限-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'&amp;&amp;@SqlReturn:Cost==0">
			<error>tblSalesOutStock.UnderCostPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</error>       
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户没有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost!=0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesReplace_Add_AccBefore2" noDefine="">tblSalesOutStock.UnderCostPrice.Cost.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice</confirm>
		</exec>
		<!--查询出有低于成本价的商品，但此用户有权限低于成本价销售或者是系统管理员，用户有查看成本价权限，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:Cost==0&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesReplace_Add_AccBefore2" noDefine="">tblSalesOutStock.UnderCostPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:lastPrice</confirm>
		</exec>
	</sql>
</define>		


<!--===========启用了“控制低于限售价销售出库”，根据逻辑给出相应提示=========-->
<define name="tblSalesReplace_UnderLimitPrice_Validate">
	<sql type="condition">
		<condition>
			<!--查询此用户是否有权限低于限售价销售-->
			<select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='UnderLimitprice' and hasRight=1</select>
			<!--查询是否有折后单价低于其最低限售的商品-->
			<select>select b.GoodsFullName as GoodsFullName,cast(a.DisPrice as numeric(18,4)) as DisPrice,cast(b.Pricefixing as numeric(18,4)) as Pricefixing from tblSalesReplaceDetail a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReplace_id and a.goodsCode=b.classCode and a.PresentSampleType not in ('1','2') and b.Pricefixing&gt;0 and a.DisPrice&lt;b.Pricefixing</select>
		</condition>
		<!--查询出有低于限售价的商品，并且此用户没有权限低于限售价销售，也不是系统管理员给出错误提示-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
			<error>tblSalesOutStock.UnderLimitPrice.error,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:Pricefixing</error>       
		</exec>
		<!--查询出有低于限售价的商品，但此用户有权限低于限售价销售或者是系统管理员，给出提示信息-->
		<exec condition="'@SqlReturn:GoodsFullName'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
			<confirm yesDefine="tblSalesReplace_Add_AccBefore1" noDefine="">tblSalesOutStock.UnderLimitPrice.confirm,@SqlReturn:GoodsFullName,@SqlReturn:DisPrice,@SqlReturn:Pricefixing</confirm>
		</exec>
	</sql>
</define> 

<!--判断用户是否有权限对超结算账期未收款客户销售-->
<define name="tblSalesReplace_Add_WithOutSettleCys_Validate">	
	<sql type="condition">
			<condition><select>select count(0) as allowCount from tblUserSunCompany a,tblRightType b where ((a.userid=@Sess:UserId and a.roleids like '%'+b.id+';%') or b.id=@Sess:UserId) and rightType='WithOutSettleCys' and hasRight=1</select>
							 <select>select tblSalesOutStock.BillNo,convert(int,DATEDIFF(DAY,tblSalesOutStock.AcceptDate,GETDATE())) as exceedtime from tblSalesOutStock join tblCompany on tblCompany.classCode=tblSalesOutStock.CompanyCode where tblSalesOutStock.CompanyCode=(select CompanyCode from tblSalesReplace where id=@ValueofDB:id) and tblSalesOutStock.NeedReturnAmt&gt;0 and convert(int,DATEDIFF(DAY,(case tblSalesOutStock.AcceptDate when '' then null else tblSalesOutStock.AcceptDate end),GETDATE()))&gt;0</select>
			</condition>
		<!--查询出有超结算账期未收款的客户，并且此用户没有权限超结算账期，也不是系统管理员给出错误提示-->
			<exec condition="'@SqlReturn:BillNo'!='null'&amp;&amp;@SqlReturn:allowCount==0&amp;&amp;'@Sess:UserId'!='1'">
					<error>tblSalesOutStock.SettleCys.error,@SqlReturn:BillNo</error>       
			</exec>			
   <!--查询出有超结算账期未收款的客户，并且此用户有权限超结算账期，或者是系统管理员给出提示-->
			<exec condition="'@SqlReturn:BillNo'!='null'&amp;&amp;(@SqlReturn:allowCount!=0||'@Sess:UserId'=='1')">
					<confirm yesDefine="tblSalesReplace_Add_AccBefore" noDefine="">tblSalesOutStock.SettleCys.confirm,@SqlReturn:BillNo</confirm>
			</exec>						
	</sql>
</define>
<!--=====出库数量不能大于可用库存======-->
<define name="tblSalesReplace_OutBillUseQty_validate">
	<sql type="condition">
		<condition><select>select d.GoodsFullName,tblStock.StockFullName as StockFullName,cast(case d.isCatalog when 0 then c.LastQty+c.inQtyNotAudit+c.SInQtyNotAudit-c.outQtyNotAudit-c.BOutQtyNotAudit else -99999999 end +isnull(b.Qty,0)- a.Qty as numeric(18,4)) as Qty from(select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblSalesReplaceDetail where f_ref=@ValueofDB:tblSalesReplace_id  group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode)a left join (select GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode,SUM(Qty) as Qty from tblSalesReplaceDet where f_ref=@ValueofDB:tblSalesReplace_id  group by GoodsCode,BatchNo,Hue,yearNO,Inch,Availably,ProDate,StockCode)b  on a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Hue=b.Hue and a.yearNO=b.yearNO and a.Inch=b.Inch and a.Availably=b.Availably and a.ProDate=b.ProDate and a.StockCode=b.StockCode left join tblStocks c on a.GoodsCode=c.GoodsCode and a.StockCode=c.StockCode and a.BatchNo=c.BatchNo and a.Hue=c.Hue and a.yearNO=c.yearNO and a.Inch=c.Inch and a.Availably=c.Availably and a.ProDate=c.ProDate left join tblGoods d on a.GoodsCode=d.classCode left join tblStock on tblStock.classCode=a.StockCode where  a.Qty&gt;(case d.isCatalog when 0 then c.LastQty+c.inQtyNotAudit+c.SInQtyNotAudit-c.outQtyNotAudit-c.BOutQtyNotAudit else -99999999 end)+isnull(b.Qty,0)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName' != 'null'">			
			<error>common.VirtualStock.excess.error,@ValueofDB:tblSalesReplace_BillNo,@SqlReturn:GoodsFullName,@SqlReturn:Qty,@SqlReturn:StockFullName</error>       
		</exec>	
	</sql>	
</define>
<define name="tblSalesReplace_Add_AccBefore">
	<sql type="condition">
		<!--查询是否存在非赠品，样品，但单价为0的商品-->
		<condition>
			<select>select b.GoodsFullName as GoodsNoSample from tblSalesReplaceDet a,tblGoods b where a.f_ref=@ValueofDB:tblSalesReplace_id and b.classCode=a.GoodsCode and isnull(a.Price,0)=0 and a.PresentSampleType not in ('1','2')</select>
			<select>select sum(TaxAmount) as sumDetailTaxAmt,sum(CurAmount) as CursumDetailTaxAmt,sum(Qty) as sumDetailQty from tblSalesReplaceDetail where f_ref=@ValueofDB:tblSalesReplace_id</select>			
		</condition>
		<!--没有启用多仓库更新明细表上的仓库值-->	
		<exec condition="'@MEM:ManyStockSales'=='false'">				  
			<sql>update tblSalesReplaceDetail set StockCode=@ValueofDB:tblSalesReplace_StockCode where f_ref=@ValueofDB:tblSalesReplace_id</sql>	
			<sql>update tblSalesReplaceDet set StockCode=@ValueofDB:tblSalesReplace_InStockCode where f_ref=@ValueofDB:tblSalesReplace_id</sql>
		</exec>
		<!--出库数量不能大于可用库存-->
		<exec condition="'@MEM:OutBillUseQtyCheck'=='true'">
			<sql type="define">tblSalesReplace_OutBillUseQty_validate</sql>
		</exec>
		<!--如果启用了系统配置“保质期”，根据情况修改保质期限和生产日期的值-->
		<exec condition="'@MEM:Availably'=='true'">		
			<sql type="procedure"><!--商品设置了保质期，没有录入保质期限，根据生产日期更新保质期限-->
			{call proc_iterateExeProc(select  b.id as id@SPFieldLink:case when tblGoods.AvailablyType='Day' then convert(varchar(10)@SPFieldLink:dateadd(Day@SPFieldLink:tblGoods.Validity@SPFieldLink:ProDate)@SPFieldLink:21) when tblGoods.AvailablyType='Month' then convert(varchar(10)@SPFieldLink:dateadd(Month@SPFieldLink:tblGoods.Validity@SPFieldLink:ProDate)@SPFieldLink:21) when tblGoods.AvailablyType='Year' then convert(varchar(10)@SPFieldLink:dateadd(Year@SPFieldLink:tblGoods.Validity@SPFieldLink:ProDate)@SPFieldLink:21) else '' end as Availably from tblSalesReplace a join tblSalesReplaceDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id='@ValueofDB:tblSalesReplace_id' and len(Availably)=0 and len(ProDate)!=0 and tblGoods.Validity!=0,proc_update,'tblSalesReplaceDet'@ParamLink:'Availably='+@Availably@ParamLink:'id='+@id,retCode,retVal)}
			</sql>
			<sql type="procedure"><!--商品设置了保质期，没有录入生产日期，根据保质期限更新生产日期-->
			{call proc_iterateExeProc(select  b.id as id@SPFieldLink:case when tblGoods.AvailablyType='Day' then convert(varchar(10)@SPFieldLink:dateadd(Day@SPFieldLink:(-1)*tblGoods.Validity@SPFieldLink:Availably)@SPFieldLink:21) when tblGoods.AvailablyType='Month' then convert(varchar(10)@SPFieldLink:dateadd(Month@SPFieldLink:(-1)*tblGoods.Validity@SPFieldLink:Availably)@SPFieldLink:21) when tblGoods.AvailablyType='Year' then convert(varchar(10)@SPFieldLink:dateadd(Year@SPFieldLink:(-1)*tblGoods.Validity@SPFieldLink:Availably)@SPFieldLink:21) else '' end as ProDate from tblSalesReplace a join tblSalesReplaceDet b on b.f_ref=a.id join tblGoods on tblGoods.classCode=b.GoodsCode where a.id='@ValueofDB:tblSalesReplace_id' and len(ProDate)=0 and len(Availably)!=0 and tblGoods.Validity!=0,proc_update,'tblSalesReplaceDet'@ParamLink:'ProDate='+@ProDate@ParamLink:'id='+@id,retCode,retVal)}
			 </sql>
		</exec>
		<!--如果存在单价为0的商品，更新这些销售价-->
		<exec condition="'@SqlReturn:GoodsNoSample'!='null'">
			<sql type="define">tblSalesReplace_Price_update</sql>
		</exec>
		<exec condition="true">
			<!--更新表头总金额-->	
			<sql>update tblSalesReplace set CertificateNo='',NeedReturnAmt=c.TaxAmount-b.TaxAmount-isnull(tblSalesReplace.DiscountAmount ,0)-isnull(tblSalesReplace.AccountAmount,0),TotalAmount=c.TaxAmount-b.TaxAmount,TotalTaxAmount=c.TaxAmount-b.TaxAmount-isnull(tblSalesReplace.DiscountAmount,0) from (select f_Ref as f_ref,sum(TaxAmount) as TaxAmount,sum(DisAmount) as DisAmount from tblSalesReplaceDet where f_Ref=@ValueofDB:tblSalesReplace_id group by f_ref) b left join (select f_Ref as f_ref,sum(TaxAmount) as TaxAmount,sum(DisBackAmt) as DisAmount from tblSalesReplaceDetail where f_Ref=@ValueofDB:tblSalesReplace_id group by f_ref) c on b.f_ref=c.f_ref where tblSalesReplace.id=@ValueofDB:tblSalesReplace_id</sql>
			
			<sql>update tblSalesReplace set CurNeedReturnAmt=dbo.getDigits('tblSalesReplaceDetail','CurAmount',NeedReturnAmt/CurrencyRate ),CurTotalAmount=dbo.getDigits('tblSalesReplaceDetail','CurAmount',TotalTaxAmount/CurrencyRate )   where tblSalesReplace.id=@ValueofDB:tblSalesReplace_id</sql>
			<sql>update tblSalesReplaceDetail set CurAmount=dbo.getDigits('tblSalesReplaceDetail','CurAmount',Qty*isnull(CurPrice,0)),CurPrice=dbo.getDigits('tblSalesReplaceDetail','CurPrice',isnull(CurPrice,0)) from tblGoods where tblGoods.classCode=tblSalesReplaceDetail.GoodsCode and Price!=0 and (tblSalesReplaceDetail.PresentSampleType = '' or tblSalesReplaceDetail.PresentSampleType is null)  and tblSalesReplaceDetail.f_ref=@ValueofDB:tblSalesReplace_id</sql>
		</exec>
		<!--如果启用了价格跟踪，将单价插入到价格管理表中-->	
		<exec condition="'@MEM:PriceTracking'=='true'">
			<sql type="define">tblSalesReplace_Add_PriceTracking</sql>
		</exec>	
		<!--引用了销售出库单更新销售出库单退货数，实际出库数及相关的销售订单-->
		<exec condition="'@ValueofDB:tblSalesReplace_SalesOutStockID'.length&gt;0">	
			<sql type="procedure">{call proc_SalesReplaceUpdateBillQty(@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_SalesOutStockID,add,retCode,retVal)}</sql>
		</exec>	
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDet.GoodsCode,@StockCode=tblSalesReplaceDet.StockCode,@BillType=tblSalesReplace,@InstoreQty=tblSalesReplaceDet.Qty,@OutstoreQty=0,@from=tblSalesReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDetail.GoodsCode,@StockCode=tblSalesReplaceDetail.StockCode,@BillType=tblSalesReplace,@InstoreQty=0,@OutstoreQty=tblSalesReplaceDetail.Qty,@from=tblSalesReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新未审核完毕的序列号出入明细-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
		
		<!--不启用审核流也不需要发票直接执行过账操作-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSalesReplace_Add_One</sql>
		</exec>
	</sql>
</define>
<!--==============更新退货明细中非赠品，样品的销售价======================-->
<define name="tblSalesReplace_Price_update">
	<!--更新没有销售价的商品,取此客户此商品在当前单据之前的最近售价-->
	<sql>update tblSalesReplaceDet set price=round(isnull((select dbo.getDigits('tblStockDet','SalesPrice',sum(SalesAmount)/sum(SalesQty)) from tblStockDet a where a.goodsCode=tblSalesReplaceDet.goodsCode and a.stockCode=tblSalesReplaceDet.stockCode and a.ProDate=tblSalesReplaceDet.ProDate and a.Availably=tblSalesReplaceDet.Availably and a.Hue=tblSalesReplaceDet.Hue and a.yearNO=tblSalesReplaceDet.yearNO and a.BatchNo=tblSalesReplaceDet.BatchNo and a.Inch=tblSalesReplaceDet.Inch and ((len(tblSalesReplaceDet.seq)=0 and len(a.seq)=0) or (len(tblSalesReplaceDet.seq)&gt;0 and len(a.seq)&gt;0 and charindex(a.seq+'~',tblSalesReplaceDet.seq)&gt;0)) and id=isnull((select top 1 id from tblStockDet b where a.goodPropHash=b.goodPropHash and b.billDate&lt;=@ValueofDB:tblSalesReplace_BillDate and BillType in ('tblSalesOutStock','tblSalesReplace') and b.OutstoreQty!=0 and b.companyCode=@ValueofDB:tblSalesReplace_CompanyCode and SalesPrice&gt;0 order by BillDate desc,createTime desc,itemOrder desc),0)),0),@MEM:DigitsPrice) where f_ref=@ValueofDB:tblSalesReplace_id and isnull(Price,0)=0 and tblSalesReplaceDet.PresentSampleType not in ('1','2')</sql>
	<!--更新没有销售价的商品,此商品在当前单据之前的最近售价-->
	<sql>update tblSalesReplaceDet set price=round(isnull((select dbo.getDigits('tblStockDet','SalesPrice',sum(SalesAmount)/sum(SalesQty)) from tblStockDet a where a.goodsCode=tblSalesReplaceDet.goodsCode and a.stockCode=tblSalesReplaceDet.stockCode and a.ProDate=tblSalesReplaceDet.ProDate and a.Availably=tblSalesReplaceDet.Availably and a.Hue=tblSalesReplaceDet.Hue and a.yearNO=tblSalesReplaceDet.yearNO and a.BatchNo=tblSalesReplaceDet.BatchNo and a.Inch=tblSalesReplaceDet.Inch and ((len(tblSalesReplaceDet.seq)=0 and len(a.seq)=0) or (len(tblSalesReplaceDet.seq)&gt;0 and len(a.seq)&gt;0 and charindex(a.seq+'~',tblSalesReplaceDet.seq)&gt;0)) and id=isnull((select top 1 id from tblStockDet b where a.goodPropHash=b.goodPropHash and b.billDate&lt;=@ValueofDB:tblSalesReplace_BillDate and BillType in ('tblSalesOutStock','tblSalesReplace') and b.OutstoreQty!=0 and SalesPrice&gt;0 order by BillDate desc,createTime desc,itemOrder desc),0)),0),@MEM:DigitsPrice) where f_ref=@ValueofDB:tblSalesReplace_id and isnull(Price,0)=0 and tblSalesReplaceDet.PresentSampleType not in ('1','2')</sql>
	<!--取此客户在客户表中设置的预设售价对应商品的价格-->
	<sql>update tblSalesReplaceDet set price=isnull((select CASE a.ComSalesType WHEN 'ProSalesPrice' THEN c.ProSalesPrice WHEN 'ProSalesPrice2' THEN c.ProSalesPrice2 WHEN 'ProSalesPrice3' THEN c.ProSalesPrice3 WHEN 'ProSalesPrice4' THEN c.ProSalesPrice4 WHEN 'ProjectPrice' THEN c.ProjectPrice WHEN 'ProSalesPrice5' THEN c.ProSalesPrice5 WHEN 'ProSalesPrice6' THEN c.ProSalesPrice6 WHEN 'ProSalesPrice7' THEN c.ProSalesPrice7 WHEN 'ProSalesPrice8' THEN c.ProSalesPrice8 WHEN 'ProSalesPrice9' THEN c.ProSalesPrice9 ELSE c.FacePrice END from tblCompany a,tblGoods c where a.classCode=@ValueofDB:tblSalesReplace_CompanyCode and c.classCode=tblSalesReplaceDet.goodsCode),0) where f_ref=@ValueofDB:tblSalesReplace_id and isnull(Price,0)=0 and tblSalesReplaceDet.PresentSampleType not in ('1','2')</sql>
	<!--取商品表中预设售价组中第一组的预设售价-->
	<sql>update tblSalesReplaceDet set price=isnull((SELECT TOP 1 Price FROM (select a.ProSalesPrice Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice2 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice3 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice4 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProjectPrice Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice5 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice6 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALl select a.ProSalesPrice7 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice8 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.ProSalesPrice9 Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode UNION ALL select a.FacePrice Price from tblGoods a where a.classCode=tblSalesReplaceDet.goodsCode) a),0) where f_ref=@ValueofDB:tblSalesReplace_id and isnull(Price,0)=0 and tblSalesReplaceDet.PresentSampleType not in ('1','2')</sql>	
	<!--更新 退货单入库总金额-->
 	<sql>update tblSalesReplaceDet set Amount=round(Qty*isnull(Price,0),@MEM:DigitsPrice),DisPrice=round(Discount*isnull(Price,0)/100,@MEM:DigitsPrice),DisAmount=round(Qty*Discount*isnull(Price,0)/100,@MEM:DigitsAmount),TaxPrice=round(isnull(Price,0)*(1+@ValueofDB:tblSalesReplace_Tax)*Discount/100,@MEM:DigitsPrice),TaxAmount=round(Qty*isnull(Price,0)*(1+@ValueofDB:tblSalesReplace_Tax)*Discount/100, @MEM:DigitsAmount),UnitPrice=case isnull(UnitQty,0) when 0 then 0 else round(Qty*isnull(Price,0)/UnitQty,@MEM:DigitsPrice) end where Price!=0 and f_ref=@ValueofDB:tblSalesReplace_id</sql>
</define>
<!--=======启用了价格跟踪，向价格管理表中插入数据================-->
<define name="tblSalesReplace_Add_PriceTracking">
	<sql type="condition">
		<condition>
			<select>select id as CPID from tblCustomerPrice where CompanyCode=@ValueofDB:tblSalesReplace_CompanyCode</select>
			<select>select lower(substring(replace(newid(),'-',''),1,28)) as NCPID</select>
		</condition>
		<!--判断如果价格管理表中没有此客户的记录，插入一条主表记录-->
		<exec condition="'@SqlReturn:CPID'=='null'">
			<sql>insert into tblCustomerPrice(id,classCode,workFlowNodeName,CompanyCode,createBy,lastUpdateBy,createTime,lastUpdateTime,statusId,SCompanyID) values(@SqlReturn:NCPID,'','finish',@ValueofDB:tblSalesReplace_CompanyCode,'1','1',@ValueofDB:tblSalesReplace_createTime,@ValueofDB:tblSalesReplace_lastUpdateTime,0,@ValueofDB:tblSalesReplace_SCompanyID)</sql>
		</exec>
		<!--查询在价格管理表中存在的商品，并且修改其最近售价，售价折扣-->
		<exec condition="'@SqlReturn:CPID'!='null'">
			<sql type="procedure">{call proc_iterateExeProc(select b.id as CDetID@SPFieldLink:(case @MEM:OutPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price@SPFieldLink:(case when '@MEM:OutDiscountTracke'='true' then Discount else 100 end) as Discount from tblSalesReplaceDetail a@SPFieldLink:tblCustomerPriceDet b where a.f_ref='@ValueofDB:tblSalesReplace_id' and b.f_ref='@SqlReturn:CPID' and a.goodsCode=b.goodsCode and a.Price&gt;0,proc_update,'tblCustomerPriceDet'@ParamLink:'Price='+@Price+'@ParamNum:@SPFieldLink:OutDiscount='+@Discount+'@ParamNum:'@ParamLink:'id='+@CDetID,retCode,retVal)}</sql>
		</exec>
		<!--查询在价格管理表中不存在的商品，并且插入最近进价，进价折扣-->
		<exec condition="true">
			<sql type="procedure">{call proc_iterateExeProc(select substring(replace(newid()@SPFieldLink:'-'@SPFieldLink:'')@SPFieldLink:1@SPFieldLink:30) as sdid@SPFieldLink:a.GoodsCode as GoodsCode@SPFieldLink:(case @MEM:OutPriceTrack when 'Price' then a.Price when 'TaxPrice' then a.TaxPrice else a.CurPrice end) as Price@SPFieldLink:isnull(a.SecUnit@SPFieldLink:'') as SecUnit@SPFieldLink:a.UnitPrice as UnitPrice@SPFieldLink:(case '@SqlReturn:CPID' when 'null' then '@SqlReturn:NCPID' else '@SqlReturn:CPID' end) as CID@SPFieldLink:'@ValueofDB:tblSalesOutStock_SCompanyID' as CSID@SPFieldLink:(case when '@MEM:OutDiscountTracke'='true' then Discount else 100 end) as Discount from tblSalesReplaceDetail a where a.f_ref='@ValueofDB:tblSalesReplace_id' and a.price&gt;0 and (select count(0) from tblCustomerPriceDet b where b.f_ref=(case '@SqlReturn:CPID' when 'null' then '@SqlReturn:NCPID' else '@SqlReturn:CPID' end) and a.goodsCode=b.goodsCode)=0,proc_insert,'tblCustomerPriceDet'@ParamLink:'id='+@sdid+'@SPFieldLink:f_ref='+@CID+'@SPFieldLink:GoodsCode='+@GoodsCode+'@SPFieldLink:Price='+@Price+'@ParamNum:@SPFieldLink:OutDiscount='+@Discount+'@SPFieldLink:SCompanyID='+@CSID,retCode,retVal)}</sql>
		</exec>		
	</sql>
</define>
<!--===========启用了信用额度控制，判断是否超出信用额度=========-->
<define name="SalesReplace_Add_CustomerCreditLimit_Validate">
	<sql type="condition">
		<condition>
			<!--查询此客户的之前的应收余额-->
			<select>select top 1 (isnull(b.ReceiveTotalRemain,0)-isnull(b.PreReceiveTotalRemain,0)-isnull(b.PayTotalRemain,0)+isnull(b.PrePayTotalRemain,0)) as RecRemain from tblCompany a left join tblCompanyTotal b on a.classCode=b.CompanyCode where a.classCode=@ValueofDB:tblSalesReplace_CompanyCode</select>
			<!--查询此客户在客户模块设置的额度,本单待收款-->
			<select>select a.Credit+isnull(b.Credit,0) as cred,dbo.getDigits('tblSalesOutStock','TotalTaxAmount',a.Credit+isnull(b.Credit,0)-cast(@SqlReturn:RecRemain as numeric(18,8))) as Credit,dbo.getDigits('tblSalesOutStock','TotalTaxAmount',cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))) as CurrBillRece from tblCompany a left join tblTempCreditApply b on a.classCode=b.CompanyCode and b.workFlowNodeName='finish' and @ValueofDB:tblSalesReplace_BillDate&gt;=StartDate and @ValueofDB:tblSalesReplace_BillDate&lt;=EndDate where a.classCode=@ValueofDB:tblSalesReplace_CompanyCode</select>
		</condition>
		<!--当本单待收款大于 信用额度-应收余额 给出错误提示-->
		<exec condition="@SqlReturn:cred&gt;0 &amp;&amp;@SqlReturn:CurrBillRece&gt;@SqlReturn:Credit"> 
			<error>tblSalesOutStock.CustomerCreditLimit.add.Notice,@SqlReturn:Credit</error>       
		</exec>
	</sql>
</define>
<!--==============销售换货单引用销售出库单的判断=================-->
<define name="SalesReplace_QuoteSalesOut_validate">
	<sql type="condition">
		<condition><select>select billDate as SalesOutDate,CompanyCode as SalesOutCom,InVoiceType as SalesOutInVoice from tblSalesOutStock where id=@ValueofDB:tblSalesReplace_SalesOutStockID</select></condition>
		<!--判断销售换货的单据日期在引用销售出库单前，给出错误提示-->
		<exec condition="'@ValueofDB:tblSalesReplace_BillDate' &lt; '@SqlReturn:SalesOutDate'">			
			<error>common.billDateLessByQuoteDate.error,@ValueofDB:tblSalesReplace_BillDate,@SqlReturn:SalesOutDate</error>       
		</exec>
		<!--客户不同，给出错误提示-->
		<exec condition="'@SqlReturn:SalesOutCom'!='@ValueofDB:tblSalesReplace_CompanyCode'">			
			<error>tblSalesOutStock.CompanyCode.error</error>       
		</exec>
		<!--发票类型不同，给出错误提示-->
		<exec condition="'@SqlReturn:SalesOutInVoice'!='@ValueofDB:tblSalesReplace_InVoiceType'">			
			<error>InVoiceType.Quote.error</error>       
		</exec>
	</sql>
	<sql type="condition"><!--退货数量大于实际出库数量，给出错误提示-->
		<condition><select>select l.BillNo,k.GoodsFullName from (select GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,Qty from tblSalesReplaceDet where f_ref=@ValueofDB:tblSalesReplace_id union all select GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,-1*Qty as Qty from tblSalesReplaceDetail where f_ref=@ValueofDB:tblSalesReplace_id) as a,tblGoods k,tblSalesOutStock l where a.GoodsCode=k.classCode and l.id=@ValueofDB:tblSalesReplace_SalesOutStockID group by l.BillNo,GoodsCode,BatchNo,Inch,Hue,yearNO,ProDate,Availably,k.GoodsFullName having SUM(Qty)&gt;(select sum(FactOutQty) from tblSalesOutStockDet b where b.f_ref=@ValueofDB:tblSalesReplace_SalesOutStockID and a.GoodsCode=b.GoodsCode and a.BatchNo=b.BatchNo and a.Inch=b.Inch and a.Hue=b.Hue and a.yearNO=b.yearNO and a.ProDate=b.ProDate and a.Availably=b.Availably)</select></condition>
		<exec condition="'@SqlReturn:GoodsFullName'!='null'">			
			<error>common.ReturnOutQtyQuote.error,@SqlReturn:BillNo,@SqlReturn:GoodsFullName</error>       
		</exec>
	</sql>
	
</define>
<!--===========启用了价格控制，判断商品价格是否在控制范围内的判断提示=========-->
<define name="tblSalesReplace_Add_PriceControl_Validate">
	<!--=======不含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesReplaceDetail a,ViewPriceControl b,tblGoods c where a.f_ref=@ValueofDB:tblSalesReplace_id and UserID=@ValueofDB:tblSalesReplace_createBy and b.ControlType='Sell' and b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and a.PresentSampleType not in ('1','2') and (a.DisPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.DisPrice&gt;b.HighestPrice))</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.priceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.priceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
	<!--=======含税单价的判断=======-->
	<sql type="condition">
		<condition><select>select c.GoodsFullName as GoodsLH,cast(isnull(b.LowestPrice,0) as decimal(18,4)) as LowestPrice,cast(isnull(b.HighestPrice,0) as decimal(18,4)) as HighestPrice from tblSalesReplaceDetail a,ViewPriceControl b,tblGoods c where b.GoodsCode=a.GoodsCode and c.classCode=a.GoodsCode and b.ControlType='SellTax' and UserID=@ValueofDB:tblSalesReplace_createBy and a.PresentSampleType not in ('1','2') and (a.TaxPrice&lt;b.LowestPrice or (b.HighestPrice&gt;0 and a.TaxPrice&gt;b.HighestPrice)) and a.f_ref=@ValueofDB:tblSalesReplace_id</select></condition>
		<!--有录入最低价，最高价时，判断要在此范围内-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.TaxPriceNotScope.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice,@SqlReturn:HighestPrice</error>       
		</exec>
		<!--有录入最低价，没有最高价时，判断要大于等于最低价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice&gt;0&amp;&amp;@SqlReturn:HighestPrice==0">	
			<error>common.TaxPriceLessLowest.error,@SqlReturn:GoodsLH,@SqlReturn:LowestPrice</error>       
		</exec>
		<!--有录入最高价，没有最低价时，判断要小于等于最高价-->
		<exec condition="'@SqlReturn:GoodsLH'!='null'&amp;&amp;@SqlReturn:LowestPrice==0&amp;&amp;@SqlReturn:HighestPrice&gt;0">	
			<error>common.TaxPriceMoreHighest.error,@SqlReturn:GoodsLH,@SqlReturn:HighestPrice</error>       
		</exec>
	</sql>
</define>
<define name="tblSalesReplace_Add_One">
<sql type="condition"><!--启用了系统配置 信用额度控制，判断是否大于可用额度-->
	<exec condition="@MEM:CustomerCreditLimit==true">
		<sql type="define">SalesReplace_Add_CustomerCreditLimit_Validate</sql>
	</exec>
	<!--如果启用审核流，删除已审核完毕的序列号出入明细-->
	<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,delete,retCode,retVal)}</sql>
	</exec>
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDet.GoodsCode,@StockCode=tblSalesReplaceDet.StockCode,@BillType=tblSalesReplace,@InstoreQty=-1*tblSalesReplaceDet.Qty,@OutstoreQty=0,@from=tblSalesReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDetail.GoodsCode,@StockCode=tblSalesReplaceDetail.StockCode,@BillType=tblSalesReplace,@InstoreQty=0,@OutstoreQty=-1*tblSalesReplaceDetail.Qty,@from=tblSalesReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
</sql>

<!--根据出库明细更新出入库明细-->
<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblSalesReplace_Period,@PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear,@PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth,@GoodsCode=tblSalesReplaceDetail.GoodsCode,@StockCode=tblSalesReplaceDetail.StockCode,@BillID=@ValueofDB:tblSalesReplace_id,@BillType=tblSalesReplace,@BillDate=@ValueofDB:tblSalesReplace_BillDate,@BillNo=@ValueofDB:tblSalesReplace_BillNo,@OutstoreQty=tblSalesReplaceDetail.Qty,@OutstorePrice=tblSalesReplaceDetail.CostPrice,@OutstoreAmount=tblSalesReplaceDetail.CostAmount,@createBy=@ValueofDB:tblSalesReplace_createBy,@lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy,@createTime=@ValueofDB:tblSalesReplace_finishTime,@lastUpdateTime=@MEM:sysLongDate,@SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID,@MRemark=@ValueofDB:tblSalesReplace_Remark,@DRemark=tblSalesReplaceDetail.Remark,@SourceID=tblSalesReplaceDetail.id,@CompanyCode=@ValueofDB:tblSalesReplace_CompanyCode,@EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID,@DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode,@SalesPrice=tblSalesReplaceDetail.TaxPrice,@SalesAmount=tblSalesReplaceDetail.Qty*tblSalesReplaceDetail.TaxPrice,@SalesQty=tblSalesReplaceDetail.Qty,@Amount=tblSalesReplaceDetail.Qty*tblSalesReplaceDetail.DisPrice,@Price=tblSalesReplaceDetail.DisPrice,@DiscountAmount=@ValueofDB:tblSalesReplace_DiscountAmount,@TrackNo=@ValueofDB:tblSalesReplace_TrackNo,@PresentSampleType=tblSalesReplaceDetail.PresentSampleType,@from=tblSalesReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
<!--根据入库明细更新出入库明细-->
<sql type="procedure">{call proc_insertStockDetGM(@Period=@ValueofDB:tblSalesReplace_Period,@PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear,@PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth,@GoodsCode=tblSalesReplaceDet.GoodsCode,@StockCode=tblSalesReplaceDet.StockCode,@BillID=@ValueofDB:tblSalesReplace_id,@BillType=tblSalesReplace,@BillDate=@ValueofDB:tblSalesReplace_BillDate,@BillNo=@ValueofDB:tblSalesReplace_BillNo,@InstoreQty=tblSalesReplaceDet.Qty,@InstorePrice=tblSalesReplaceDet.CostPrice,@InstoreAmount=tblSalesReplaceDet.CostAmount,@createBy=@ValueofDB:tblSalesReplace_createBy,@lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy,@createTime=@ValueofDB:tblSalesReplace_finishTime,@lastUpdateTime=@MEM:sysLongDate,@SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID,@MRemark=@ValueofDB:tblSalesReplace_Remark,@DRemark=tblSalesReplaceDet.Remark,@SourceID=tblSalesReplaceDet.id,@CompanyCode=@ValueofDB:tblSalesReplace_CompanyCode,@EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID,@DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode,@SalesPrice=tblSalesReplaceDet.TaxPrice,@SalesAmount=(-1)*tblSalesReplaceDet.Qty*tblSalesReplaceDet.TaxPrice,@SalesQty=(-1)*tblSalesReplaceDet.Qty,@Amount=(-1)*tblSalesReplaceDet.Qty*tblSalesReplaceDet.Price,@Price=tblSalesReplaceDet.Price,@DiscountAmount=@ValueofDB:tblSalesReplace_DiscountAmount,@TrackNo=@ValueofDB:tblSalesReplace_TrackNo,@PresentSampleType=tblSalesReplaceDet.PresentSampleType,@from=tblSalesReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
<!--验证序列号是否有重复-->
<sql type="define">validateSameSeq</sql>
<!--验证负库存-->
<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
<sql>update tblSalesReplace set TotalAlrAccAmt=AccountAmount,NeedReturnAmt=TotalTaxAmount-AccountAmount,CurTotalAlrAccAmt=CurAccountAmount,CurNeedReturnAmt=CurTotalAmount-CurAccountAmount where id=@ValueofDB:tblSalesReplace_id</sql>
<!--===========插入凭证，影响科目余额，影响往来===============-->
<sql type="condition">
	<condition>
		<!--得到凭证的审核状态-->
		<select>select TotalTaxAmount as totalAmt,CurTotalAmount as curTotalAmt,b.detailAmt-c.detAmt as taxAmt from tblSalesReplace a,(select isnull(sum(TaxAmount)-sum(DisBackAmt),0) as detailAmt from tblSalesReplaceDetail where f_ref=@ValueofDB:tblSalesReplace_id) as b,(select isnull(sum(TaxAmount)-sum(DisAmount),0) as detAmt from tblSalesReplaceDet where f_ref=@ValueofDB:tblSalesReplace_id) as c where a.id=@ValueofDB:tblSalesReplace_id</select>
	</condition>
	<!--差异金额不等于0，影响往来应收 借方金额=差异金额 往来单位明细 （1应付 2应收 3预付 4预收）-->
	<exec condition="@SqlReturn:totalAmt!=0">
		<sql type="procedure">{call proc_insertComIni(0@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_CompanyCode,2,@ValueofDB:tblSalesReplace_BillDate,Period=@ValueofDB:tblSalesReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth@SPFieldLink:ReceiveTotalDebit=@SqlReturn:totalAmt@ParamNum:@SPFieldLink:ReceiveTotalLend=0@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReplace_id@SPFieldLink:Currency=@ValueofDB:tblSalesReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReplace_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID@SPFieldLink:FcRecTotalDebit=@SqlReturn:curTotalAmt@ParamNum:@SPFieldLink:FcRecTotalCredit=0@SPFieldLink:BillType=tblSalesReplace@SPFieldLink:BillNo=@ValueofDB:tblSalesReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode@SPFieldLink:DiscountAmount=@ValueofDB:tblSalesReplace_DiscountAmount@SPFieldLink:Remark=@ValueofDB:tblSalesReplace_Remark,retCode,retVal)}</sql>
	</exec>	
	<exec condition="@SqlReturn:totalAmt&gt;=0&amp;&amp;@SqlReturn:totalAmt-(@ValueofDB:tblSalesReplace_AccountAmount)&lt;0">
		<!--差异金额大于等于0 且差异金额-收款金额 小于0 应收  贷方金额=差异金额-->
		<sql type="procedure">{call proc_insertComIni(1@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_CompanyCode,2,@ValueofDB:tblSalesReplace_BillDate,Period=@ValueofDB:tblSalesReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@ParamNum:@SPFieldLink:ReceiveTotalLend=@SqlReturn:totalAmt@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReplace_id@SPFieldLink:Currency=@ValueofDB:tblSalesReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReplace_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:FcRecTotalCredit=@SqlReturn:curTotalAmt@SPFieldLink:BillType=tblSalesReplace@SPFieldLink:BillNo=@ValueofDB:tblSalesReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode,retCode,retVal)}</sql>	
		<!--差异金额大于0 且差异金额-收款金额 小于0 预收  贷方金额=收款金额-差异金额-->
		<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_CompanyCode,4,@ValueofDB:tblSalesReplace_BillDate,Period=@ValueofDB:tblSalesReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@ParamNum:@SPFieldLink:PreReceiveTotalLend=@ValueofDB:tblSalesReplace_AccountAmount-@SqlReturn:totalAmt@ParamNum:@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReplace_id@SPFieldLink:Currency=@ValueofDB:tblSalesReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReplace_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:FcPreRecTotalCredit=@ValueofDB:tblSalesReplace_CurAccountAmount-@SqlReturn:curTotalAmt@ParamNum:@SPFieldLink:BillType=tblSalesReplace@SPFieldLink:BillNo=@ValueofDB:tblSalesReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode,retCode,retVal)}</sql>
	</exec>
	<!--有收款，差异金额大于0 且差异金额-收款金额 小于0 贷方金额=收款金额-差异金额-->
	<exec condition="@ValueofDB:tblSalesReplace_AccountAmount!=0&amp;&amp;!(@SqlReturn:totalAmt&gt;=0&amp;&amp;@SqlReturn:totalAmt-(@ValueofDB:tblSalesReplace_AccountAmount)&lt;0)">
		<sql type="procedure">{call proc_insertComIni(2@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_CompanyCode,2,@ValueofDB:tblSalesReplace_BillDate,Period=@ValueofDB:tblSalesReplace_Period@SPFieldLink:PeriodYear=@ValueofDB:tblSalesReplace_PeriodYear@SPFieldLink:PeriodMonth=@ValueofDB:tblSalesReplace_PeriodMonth@SPFieldLink:ReceiveTotalDebit=0@ParamNum:@SPFieldLink:ReceiveTotalLend=@ValueofDB:tblSalesReplace_AccountAmount@SPFieldLink:RelationDocID=@ValueofDB:tblSalesReplace_id@SPFieldLink:Currency=@ValueofDB:tblSalesReplace_Currency@SPFieldLink:CurrencyRate=@ValueofDB:tblSalesReplace_CurrencyRate@SPFieldLink:createBy=@ValueofDB:tblSalesReplace_createBy@SPFieldLink:createTime=@ValueofDB:tblSalesReplace_createTime@SPFieldLink:lastUpdateBy=@ValueofDB:tblSalesReplace_lastUpdateBy@SPFieldLink:lastUpdateTime=@ValueofDB:tblSalesReplace_lastUpdateTime@SPFieldLink:SCompanyID=@ValueofDB:tblSalesReplace_SCompanyID@SPFieldLink:FcRecTotalDebit=0@ParamNum:@SPFieldLink:FcRecTotalCredit=@ValueofDB:tblSalesReplace_CurAccountAmount@SPFieldLink:BillType=tblSalesReplace@SPFieldLink:BillNo=@ValueofDB:tblSalesReplace_BillNo@SPFieldLink:EmployeeID=@ValueofDB:tblSalesReplace_EmployeeID@SPFieldLink:DepartmentCode=@ValueofDB:tblSalesReplace_DepartmentCode,retCode,retVal)}</sql>
	</exec>
	<!--如果启用“自动产生凭证”，则自动插入凭证-->
	<exec condition="'@MEM:autoGenerateAcc'=='true'">
		<sql type="certificate">tblSalesReplace</sql>
	</exec>
	
	<!--如果收款金额大于0，要产生销售收款单-->
	<exec condition="@ValueofDB:tblSalesReplace_AccountAmount!=0">
		<sql type="define">tblSalesReplace_Add_CreateReceBill</sql>
	</exec>
    
	<!--初始化开票金额-->
	<exec condition="true">
        <sql>update tblSalesReplace set NoInvoiceAmount=TotalTaxAmount,InvoiceAmount=0 where id=@ValueofDB:tblSalesReplace_id </sql>
	</exec>    
</sql>
</define>



<define name="tblSalesReplace_Add_CreateReceBill">
<sql type="condition">
	<condition><select>select  case when (cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))&lt;=cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))) or (cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))&gt;0 and cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))&gt;=cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))) then 'TotalTaxAmount' when (cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))&lt;0 and cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))&gt;cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))) or (cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))&gt;0 and cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))&lt;cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))) then 'AccountAmount' else '0' end as ExeBalAmt,(cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8))) as NeedRec,(case when cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))&gt;0 and (cast(@ValueofDB:tblSalesReplace_TotalTaxAmount as numeric(18,8))-cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8)))&lt;0 then 'PreReceive' else 'Receive' end) as AcceptType,(case when @ValueofDB:tblSalesReplace_Account like '1001%' then 1 else 3 end) as SettleType</select></condition>

	<exec condition="true">
		<sql>insert into tblSaleReceive (id,BillDate,BillNo,CompanyCode,DepartmentCode,EmployeeID,SettleType,AcceptTypeID,ExeBalAmt,FactIncome,AccAmt,Currency,CurrencyRate,BillFcAmt,PeriodYear,PeriodMonth,Period,createBy,createTime,lastUpdateBy,lastUpdateTime,SCompanyID,AutoBillMarker,workFlowNodeName,workFlowNode,checkPersons,TrackNo) values ('0'+@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_BillDate,@CODE:[tblSaleReceive_BillNo],@ValueofDB:tblSalesReplace_CompanyCode,@ValueofDB:tblSalesReplace_DepartmentCode,@ValueofDB:tblSalesReplace_EmployeeID,@SqlReturn:SettleType,@SqlReturn:AcceptType,@ValueofDB:tblSalesReplace_AccountAmount,@ValueofDB:tblSalesReplace_CurAccountAmount ,@ValueofDB:tblSalesReplace_AccountAmount,@ValueofDB:tblSalesReplace_Currency,@ValueofDB:tblSalesReplace_CurrencyRate,@ValueofDB:tblSalesReplace_AccountAmount,@ValueofDB:tblSalesReplace_PeriodYear,@ValueofDB:tblSalesReplace_PeriodMonth,@ValueofDB:tblSalesReplace_Period,@ValueofDB:tblSalesReplace_createBy,@ValueofDB:tblSalesReplace_createTime,@ValueofDB:tblSalesReplace_lastUpdateBy,@ValueofDB:tblSalesReplace_lastUpdateTime,@ValueofDB:tblSalesReplace_SCompanyID,1,'finish','-1','',@ValueofDB:tblSalesReplace_TrackNo)</sql>
		<sql>insert into tblSaleReceivedet (id,f_ref,BillAmt,CurBillAmt,ExeBalAmt,ExeBalFcAmt,Currency,CurrencyRate,SettledAmt,WexeBalAmt,CurSettledAmt,CurWexeBalAmt,RefBillNo,SalesOrderNo,SalesOrderID,BackAmt,SCompanyID,CurBackAmt,RefbillID,ReceiveBillType) values ('1'+@ValueofDB:tblSalesReplace_id,'0'+@ValueofDB:tblSalesReplace_id,@ValueofDB:tblSalesReplace_TotalTaxAmount,@ValueofDB:tblSalesReplace_CurTotalAmount,(case @SqlReturn:ExeBalAmt when 'TotalTaxAmount' then @ValueofDB:tblSalesReplace_TotalTaxAmount when 'AccountAmount' then cast(@ValueofDB:tblSalesReplace_AccountAmount as numeric(18,8)) else 0.0 end),(case @SqlReturn:ExeBalAmt when 'TotalTaxAmount' then @ValueofDB:tblSalesReplace_CurTotalAmount when 'AccountAmount' then cast(@ValueofDB:tblSalesReplace_CurAccountAmount as numeric(18,8)) else 0.0 end),@ValueofDB:tblSalesReplace_Currency,@ValueofDB:tblSalesReplace_CurrencyRate,0,@ValueofDB:tblSalesReplace_TotalTaxAmount,0,@ValueofDB:tblSalesReplace_CurTotalAmount,@ValueofDB:tblSalesReplace_BillNo,@ValueofDB:tblSalesReplace_SalesOrderNo,@ValueofDB:tblSalesReplace_SalesOrderID,0,@ValueofDB:tblSalesReplace_SCompanyID,0,@ValueofDB:tblSalesReplace_id,'tblSalesReplace')</sql>
	</exec>
	<!--如果启用了多账户，向多账户明细表中插入数据-->
	<exec condition="true">
		<sql>insert into tblReceiveAccountDet (id,f_ref,SettleType,Amount,ExeBalFcAmt,Account,SCompanyID) values ('1'+@ValueofDB:tblSalesReplace_id,'0'+@ValueofDB:tblSalesReplace_id,@SqlReturn:SettleType,@ValueofDB:tblSalesReplace_AccountAmount,@ValueofDB:tblSalesReplace_CurAccountAmount,@ValueofDB:tblSalesReplace_Account,@ValueofDB:tblSalesReplace_SCompanyID)</sql>
	</exec>
	<!--自动生成的单据需更新单据编号连续-->
	<exec condition="'@MEM:BillNoSequence'=='true'">  
		<sql>update tblCodeGenerate set curValue=curValue+1 where code='SE'</sql>
	</exec>	
	<!--向追踪单号表中插入数据-->
	<exec condition="'@MEM:TrackNo'=='true'">  
		<sql>insert into tblTrackBill(id,RelationID,BillNo,BillType,BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID) select  substring(replace(newid(),'-',''),1,30),id,BillNo,'tblSaleReceive',BillDate,TrackNo,createby,lastupdateBy,createTime,lastupdateTime,ScompanyID from tblSaleReceive where id='0'+@ValueofDB:tblSalesReplace_id</sql>
	</exec>
</sql>
</define>

<define name="tblSalesReplace_Delete">	
	<sql type="condition">
		<condition>
          <select>select SalesOutStockID from tblSalesReplace where id=@ValueofDB:tblSalesReplace_id</select>
          <select>select  BillNo as InvoiceNo from tblSalesInfoDet,tblSalesInvoiceInfo where tblSalesInvoiceInfo.id=tblSalesInfoDet.f_ref and refbillID=@ValueofDB:tblSalesReplace_id and tblSalesInvoiceInfo.workFlowNodeName!='print'</select>
        </condition>
		<!--引用了销售出库单更新销售出库单退货数，实际出库数及相关的销售订单-->
		<exec condition="'@SqlReturn:SalesOutStockID'.length&gt;0">	
			<sql type="procedure">{call proc_SalesReplaceUpdateBillQty(@ValueofDB:tblSalesReplace_id,@SqlReturn:SalesOutStockID,delete,retCode,retVal)}</sql>
		</exec>
		<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDet.GoodsCode,@StockCode=tblSalesReplaceDet.StockCode,@BillType=tblSalesReplace,@InstoreQty=-1*tblSalesReplaceDet.Qty,@OutstoreQty=0,@from=tblSalesReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
			<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDetail.GoodsCode,@StockCode=tblSalesReplaceDetail.StockCode,@BillType=tblSalesReplace,@InstoreQty=0,@OutstoreQty=-1*tblSalesReplaceDetail.Qty,@from=tblSalesReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		</exec>
		
		<!--删除和修改操作时，更新序列号出入明细-->
		<exec condition="'@Sess:BillOper' =='delete'||'@Sess:BillOper' =='update'">
			<sql>delete from tblSeqAuditing where BillID=@ValueofDB:tblBuyInStock_id</sql>
		</exec>	
         <!--判断是否存在对应销售开票管理-->
        <exec condition="'@SqlReturn:InvoiceNo'!='null'">   
            <error>tblSalesInfoDet.BillNo.error,@SqlReturn:InvoiceBillNo</error>                   
        </exec>	
		<!--不启用审核流也不需要发票操作,执行过账-->
		<exec condition="'@MEM:tblSalesReplace_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">tblSalesReplace_Delete_One</sql>
		</exec>
	</sql> 
</define>

<define name="tblSalesReplace_Delete_One">
<!--凭证启用了审核流,判断是否存在关联此单据的凭证已经审核完毕-->
<sql type="condition">
	<condition><select>select CredTypeID,OrderNo from tblAccMain where @MEM:tblAccMain_IsStatart=1 and RefBillID=@ValueofDB:tblSalesReplace_id and  workFlowNodeName='finish'</select></condition>
	<exec condition="'@SqlReturn:OrderNo'!='null'">	
		<error>DelBill.RefAccMain.error,@SqlReturn:CredTypeID @SqlReturn:OrderNo</error>       
	</exec>
</sql>
<!--存在不是自动产生的销售收款单，不允许此操作-->
<sql type="condition">
	<condition><select>select a.BillNo as ReBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and a.AutoBillMarker=0 and b.RefbillID=@ValueofDB:tblSalesReplace_id</select></condition>
	<exec condition="'@SqlReturn:ReBillNo' != 'null'">	 					
		<error>DelBill.ReBillNo.error,@SqlReturn:ReBillNo</error>       
	</exec>
</sql>
<!--自动产生的收款单存在收款退款，不允许此操作-->
<sql type="condition">
	<condition><select>select a.BillNo as ReRBillNo from tblSaleReceive a,tblSaleReceiveDet b where a.id=b.f_ref and a.workFlowNodeName!='print' and b.RefbillID=(select c.id from tblSaleReceive c,tblSaleReceiveDet d where c.id=d.f_ref and c.AutoBillMarker=1 and d.RefbillID=@ValueofDB:tblSalesReplace_id)</select></condition>
	<exec condition="'@SqlReturn:ReRBillNo' != 'null'">	 					
		<error>tblsalereceive.ReturnBill.error,@SqlReturn:ReRBillNo</error>       
	</exec>
</sql>
<sql type="condition">
	<!--如果启用审核流，反审核时，时更新分序列号出入未审核完毕的序列号明细，-->
		<exec condition="&quot;@MEM:tblSalesReplace_IsStatart&quot;!= &quot;0&quot;&amp;&amp;&quot;@Sess:BillOper&quot;==&quot;returnAuditing&quot;">
			<sql type="procedure">{call proc_insertSeqOutInDet(@ValueofDB:id,add,retCode,retVal)}</sql>
		</exec>
</sql>

<sql type="condition">
	<!--如果启用审核流，则新增保存时更新分仓库存未审核字段-->
	<exec condition="'@MEM:tblSalesReplace_IsStatart' != '0'">
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDet.GoodsCode,@StockCode=tblSalesReplaceDet.StockCode,@BillType=tblSalesReplace,@InstoreQty=tblSalesReplaceDet.Qty,@OutstoreQty=0,@from=tblSalesReplaceDet,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
		<sql type="procedure">{call proc_updateStocksNotAudit(@GoodsCode=tblSalesReplaceDetail.GoodsCode,@StockCode=tblSalesReplaceDetail.StockCode,@BillType=tblSalesReplace,@InstoreQty=0,@OutstoreQty=tblSalesReplaceDetail.Qty,@from=tblSalesReplaceDetail,@where=f_ref='@ValueofDB:id',@retCode=retCode,@retVal=retVal)}</sql>
	</exec>
	<!--删除出入库明细信息-->
	<exec condition="true">
		<sql type="procedure">{call proc_delStockDet(@ValueofDB:tblSalesReplace_id,tblSalesReplace,2,retCode,retVal)}</sql>
	</exec>	
	<!--删除，反审核时判断序列号是否重复，是否存在负库存-->
	<exec condition="'@Sess:BillOper' !='update'">
		<sql type="define">validateSameSeq</sql>
		<sql type="procedure">{call proc_negativeStock(@Sess:Local,@ValueofDB:id,@Sess:SCompanyID,@Sess:UserId,NegativeCode,NegativeBillNo)}</sql>
	</exec>
</sql>

<sql type="condition">
	<condition><select>select AccountAmount,SalesOrderID,CurAccountAmount from tblSalesReplace where id=@ValueofDB:tblSalesReplace_id</select></condition>
	<!--删除本单据的多条往来记录（1应付 2应收 3预付 4预收-->
	<exec condition="true">
		<sql type="procedure">{call proc_iterateExeProc(select id as IniId@SPFieldLink:case when isnull(ReceiveTotalDebit@RepComma:0)!=0 or isnull(ReceiveTotalLend@RepComma:0)!=0 then 2 when isnull(PreReceiveTotalDebit@RepComma:0)!=0 or isnull(PreReceiveTotalLend@RepComma:0)!=0 then 4 end as ComType from tblCompanyIni where relationDocID='@ValueofDB:tblSalesReplace_id',proc_deleteComIni,@IniId@ParamLink:@ComType,retCode,retVal)}</sql>
	</exec>
	<!--启用“自动产生凭证”时，删除凭证审核流或者减少科目余额，删除凭证信息-->
    <exec condition=" '@MEM:autoGenerateAcc'=='true'">
		<sql type="procedure">{call proc_delAccAndRefOper(@MEM:tblAccMain_IsStatart,@Sess:BillOper,@ValueofDB:tblSalesReplace_id,retCode,retVal)}</sql>
	</exec>
	<!--收款金额大于0，删除自动产生的应收款-->
	<exec condition="@SqlReturn:AccountAmount!=0">
		<sql>delete from tblSaleReceive where id in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReplace_id)</sql>
		<sql>delete from tblSalesRecAccount where f_ref in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReplace_id)</sql>
		<sql>delete from tblTrackBill where RelationID in (select f_ref from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReplace_id)</sql>
		<sql>delete from tblSaleReceiveDet where RefbillID=@ValueofDB:tblSalesReplace_id</sql>
	</exec>
	<exec condition="true">
		<sql>update tblSalesReplace set TotalAlrAccAmt=0,NeedReturnAmt=TotalTaxAmount where id=@ValueofDB:tblSalesReplace_id</sql>
	</exec>
</sql>
</define>
<!--===================================================以上代码：销售换货单==========================================================-->

<!--========================================================销售开票单=====================================================-->
<define name="SalesInvoice_add">
	<sql type="condition"><!--发票类型是“收据凭证”，税率必须等于0,其他类型税率必须大于等于0-->		
		<exec condition="('@ValueofDB:tblSalesStandardInvoice_InVoiceType'=='3'&amp;&amp;@ValueofDB:tblSalesStandardInvoice_Tax!=0)||@ValueofDB:tblSalesStandardInvoice_Tax&lt;0">				
			<error>common.isReceipt.existsTax.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--销售出库时数量小于等于0，给出错误提示-->
		<condition><select>select c.BillNo as BillNoS,b.GoodsFullName as GoodsS,Qty from tblSalesStandardInvoiceDet a,tblGoods b,tblSalesOutStock c where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&lt;=0 and a.BillType='tblSalesOutStock' and a.RelationNo=c.id</select></condition>
		<exec condition="'@SqlReturn:GoodsS' != 'null'">						
			<error>SalesInvoice.SQty.error,@SqlReturn:BillNoS,@SqlReturn:GoodsS</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--销售退货数量大于等于0，给出错误提示-->
		<condition><select>select c.BillNo as BillNoR,b.GoodsFullName as GoodsR,Qty from tblSalesStandardInvoiceDet a,tblGoods b,tblSalesReturnStock c where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and b.classCode=a.GoodsCode and isnull(a.Qty,0)&gt;=0 and a.BillType='tblSalesReturnStock' and a.RelationNo=c.id</select></condition>
		<exec condition="'@SqlReturn:GoodsR' != 'null'">						
			<error>SalesInvoice.RQty.error,@SqlReturn:BillNoR,@SqlReturn:GoodsR</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--销售出库开票数量大于单据本身数量，给出错误提示-->
	<condition><select>select b.BillNo as BillNoInvoice,d.GoodsFullName as goodsInvoice,dbo.getDigits('tblSalesStandardInvoiceDet','Qty',c.NoInvoiceQty) as InvoiceQty from (select SourceID,SUM(Qty) as Qty from tblSalesStandardInvoiceDet where f_ref=@ValueofDB:tblSalesStandardInvoice_id and BillType='tblSalesOutStock' group by SourceID) as a,tblSalesOutStock b,tblSalesOutStockDet c,tblGoods d where a.SourceID=c.id and b.id=c.f_ref and c.GoodsCode=d.classCode and c.InvoiceQty+a.Qty&gt;c.Qty</select></condition>
		<exec condition="'@SqlReturn:goodsInvoice' != 'null'">						
			<error>openInvoice.Qty.error,@SqlReturn:BillNoInvoice,@SqlReturn:goodsInvoice,@SqlReturn:InvoiceQty</error>      
		</exec>	
	</sql>
	<sql type="condition"><!--销售退货开票数量大于单据本身数量，给出错误提示-->
		<condition><select>select b.BillNo as BillNoInvoiceR,d.GoodsFullName as goodsInvoiceR,dbo.getDigits('tblSalesStandardInvoiceDet','Qty',-1*c.NoInvoiceQty) as InvoiceQtyR from (select SourceID,SUM(Qty) as Qty from tblSalesStandardInvoiceDet where f_ref=@ValueofDB:tblSalesStandardInvoice_id and BillType='tblSalesReturnStock' group by SourceID) as a,tblSalesReturnStock b,tblSalesReturnStockDet c,tblGoods d where a.SourceID=c.id and b.id=c.f_ref and c.GoodsCode=d.classCode and c.InvoiceQty+ABS(a.Qty)&gt;c.Qty</select></condition>
		<exec condition="'@SqlReturn:goodsInvoiceR' != 'null'">						
			<error>openInvoice.Qty.error,@SqlReturn:BillNoInvoiceR,@SqlReturn:goodsInvoiceR,@SqlReturn:InvoiceQtyR</error>      
		</exec>	
	</sql>
	<sql type="condition"><!--销售出库单折后单价与所引用的单据的折后单价不同，给出错误提示-->
		<condition><select>select c.BillNo as BillNoSP,b.GoodsFullName as GoodsSP from tblSalesStandardInvoiceDet a,tblGoods b,tblSalesOutStock c,tblSalesOutStockDet d where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and b.classCode=a.GoodsCode and a.BillType='tblSalesOutStock' and a.SourceId=d.id and c.id=d.f_ref and a.DisPrice!=d.DisPrice</select></condition>
		<exec condition="'@SqlReturn:GoodsSP' != 'null'">						
			<error>SalesInvoice.SPrice.error,@SqlReturn:BillNoSP,@SqlReturn:GoodsSP</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--销售退货单折后单价与所引用的单据的折后单价不同，给出错误提示-->
		<condition><select>select c.BillNo as BillNoRP,b.GoodsFullName as GoodsRP from tblSalesStandardInvoiceDet a,tblGoods b,tblSalesReturnStock c,tblSalesReturnStockDet d where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and b.classCode=a.GoodsCode and a.BillType='tblSalesReturnStock' and a.SourceId=d.id and c.id=d.f_ref and a.DisPrice!=d.DisPrice</select></condition>
		<exec condition="'@SqlReturn:GoodsRP' != 'null'">						
			<error>SalesInvoice.RPrice.error,@SqlReturn:BillNoRP,@SqlReturn:GoodsRP</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--折扣不是0到1之间的数值时给出错误提示-->
		<condition><select>select 'disCountError' as disCountError from tblSalesStandardInvoiceDet a where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and (Discount&lt;=0 or Discount&gt;1)</select></condition>
		<exec condition="'@SqlReturn:disCountError' != 'null'">				
			<error>common.Discount.error</error>        
		</exec>
	</sql>
	<sql type="condition"><!--总金额与明细表合计金额不相等，给出错误提示-->
		<condition><select>select dbo.getDigits('tblSalesOrderDet','TaxAmount',sum(tblSalesStandardInvoiceDet.TaxAmount)) as SumDetAmt from tblSalesStandardInvoiceDet where f_ref=@ValueofDB:tblSalesStandardInvoice_id</select></condition>
		<exec condition=" @SqlReturn:SumDetAmt != @ValueofDB:tblSalesStandardInvoiceDet_TotalTaxAmount">				
			<error>common.mainDetilAmt.NotEqual.error,@ValueofDB:tblSalesStandardInvoiceDet_TotalTaxAmount,@SqlReturn:SumDetAmt</error>       
		</exec>	
	</sql>
	<sql type="condition"><!--如果不启用审核流，调用过账的define-->
		<exec condition="'@MEM:tblSalesStandardInvoice_IsStatart' == '0'&amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">SalesInvoice_Add_One</sql>
		</exec>
	</sql>
	<sql type="condition"><!--明细中供应商和主表不符-->
		<condition><select>select count(ViewSalesBillGoodsInfo.BillNo) as Bill  
				from tblSalesStandardInvoice 
					inner join tblSalesStandardInvoiceDet on tblSalesStandardInvoice.id = tblSalesStandardInvoiceDet.f_ref  
					left join ViewSalesBillGoodsInfo on ViewSalesBillGoodsInfo.DetId=tblSalesStandardInvoiceDet.SourceID where tblSalesStandardInvoice.id=@ValueofDB:tblSalesStandardInvoice_id  					and  ViewSalesBillGoodsInfo.CompanyCode!=tblSalesStandardInvoice.CompanyCode 
				</select>
		</condition>
		<exec condition="@SqlReturn:Bill !=0">				
			<error>SalesStandardInvoice.CompanyCode.error</error>              
		</exec>
	</sql>	
	<sql type="condition"><!--明细中供应商和主表不符-->
		<condition><select>select count(ViewSalesBillGoodsInfo.BillNo) as Bill  
				from tblSalesStandardInvoice 
					inner join tblSalesStandardInvoiceDet on tblSalesStandardInvoice.id = tblSalesStandardInvoiceDet.f_ref  
					left join ViewSalesBillGoodsInfo on ViewSalesBillGoodsInfo.DetId=tblSalesStandardInvoiceDet.SourceID where tblSalesStandardInvoice.id=@ValueofDB:tblSalesStandardInvoice_id  					and  ViewSalesBillGoodsInfo.inVoiceType!=tblSalesStandardInvoice.inVoiceType 
				</select>
		</condition>
		<exec condition="@SqlReturn:Bill !=0">				
			<error>tblBuyInvoice.VoiceType.error</error>              
		</exec>
	</sql>		
</define>

<!--=========销售开票过账操作==========-->
<define name="SalesInvoice_Add_One">		
	<!--回填销售出库单的开票数以及未开票数-->		
	<sql>update tblSalesOutStockDet set NoInvoiceQty=NoInvoiceQty-a.Qty,InvoiceQty=InvoiceQty+a.Qty from tblSalesStandardInvoiceDet as a where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and a.SourceID=tblSalesOutStockDet.id</sql>
	<!--回填销售退货单的开票数以及未开票数-->		
	<sql>update tblSalesReturnStockDet set NoInvoiceQty=NoInvoiceQty+a.Qty,InvoiceQty=InvoiceQty-a.Qty from tblSalesStandardInvoiceDet as a where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and a.SourceID=tblSalesReturnStockDet.id</sql>
</define>

<!--============删除销售开票单=============-->
<!--不管是否启用审核流，修改或者删除都会调用此define，但启用了审核流能够修改或者删除说明是未审核完成，未审核的单据不需要下面的判断-->
<define name="SalesInvoice_Del">
	<sql type="condition">
		<exec condition="@MEM:tblSalesStandardInvoice_IsStatart==0 &amp;&amp; @MEM:OpenInvoice==false">
			<sql type="define">SalesInvoice_Del_One</sql> 
		</exec>
	</sql>
</define>	
<define name="SalesInvoice_Del_One">
	<!--回填销售出库单的开票数以及未开票数-->		
	<sql>update tblSalesOutStockDet set NoInvoiceQty=NoInvoiceQty+a.Qty,InvoiceQty=InvoiceQty-a.Qty from tblSalesStandardInvoiceDet as a where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and a.SourceID=tblSalesOutStockDet.id</sql>
	<!--回填销售退货单的开票数以及未开票数-->		
	<sql>update tblSalesReturnStockDet set NoInvoiceQty=NoInvoiceQty-a.Qty,InvoiceQty=InvoiceQty+a.Qty from tblSalesStandardInvoiceDet as a where a.f_ref=@ValueofDB:tblSalesStandardInvoice_id and a.SourceID=tblSalesReturnStockDet.id</sql>
</define>		
<!--============================================================以上代码：销售开票单================================================-->
</defineSqls>